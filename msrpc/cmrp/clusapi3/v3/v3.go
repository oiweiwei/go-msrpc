package clusapi3

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcetypes "github.com/oiweiwei/go-msrpc/msrpc/dcetypes"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dcetypes.GoPackage
	_ = dtyp.GoPackage
)

var (
	// import guard
	GoPackage = "cmrp"
)

var (
	// Syntax UUID
	Clusapi3SyntaxUUID = &uuid.UUID{TimeLow: 0xb97db8b2, TimeMid: 0x4c63, TimeHiAndVersion: 0x11cf, ClockSeqHiAndReserved: 0xbf, ClockSeqLow: 0xf6, Node: [6]uint8{0x8, 0x0, 0x2b, 0xe2, 0x3f, 0x2f}}
	// Syntax ID
	Clusapi3SyntaxV3_0 = &dcerpc.SyntaxID{IfUUID: Clusapi3SyntaxUUID, IfVersionMajor: 3, IfVersionMinor: 0}
)

// clusapi3 interface.
type Clusapi3Client interface {

	// ApiOpenCluster operation.
	OpenCluster(context.Context, *OpenClusterRequest, ...dcerpc.CallOption) (*OpenClusterResponse, error)

	// ApiCloseCluster operation.
	CloseCluster(context.Context, *CloseClusterRequest, ...dcerpc.CallOption) (*CloseClusterResponse, error)

	// ApiSetClusterName operation.
	SetClusterName(context.Context, *SetClusterNameRequest, ...dcerpc.CallOption) (*SetClusterNameResponse, error)

	// ApiGetClusterName operation.
	GetClusterName(context.Context, *GetClusterNameRequest, ...dcerpc.CallOption) (*GetClusterNameResponse, error)

	// ApiGetClusterVersion operation.
	GetClusterVersion(context.Context, *GetClusterVersionRequest, ...dcerpc.CallOption) (*GetClusterVersionResponse, error)

	// ApiGetQuorumResource operation.
	GetQuorumResource(context.Context, *GetQuorumResourceRequest, ...dcerpc.CallOption) (*GetQuorumResourceResponse, error)

	// ApiSetQuorumResource operation.
	SetQuorumResource(context.Context, *SetQuorumResourceRequest, ...dcerpc.CallOption) (*SetQuorumResourceResponse, error)

	// ApiCreateEnum operation.
	CreateEnum(context.Context, *CreateEnumRequest, ...dcerpc.CallOption) (*CreateEnumResponse, error)

	// ApiOpenResource operation.
	OpenResource(context.Context, *OpenResourceRequest, ...dcerpc.CallOption) (*OpenResourceResponse, error)

	// ApiCreateResource operation.
	CreateResource(context.Context, *CreateResourceRequest, ...dcerpc.CallOption) (*CreateResourceResponse, error)

	// ApiDeleteResource operation.
	DeleteResource(context.Context, *DeleteResourceRequest, ...dcerpc.CallOption) (*DeleteResourceResponse, error)

	// ApiCloseResource operation.
	CloseResource(context.Context, *CloseResourceRequest, ...dcerpc.CallOption) (*CloseResourceResponse, error)

	// ApiGetResourceState operation.
	GetResourceState(context.Context, *GetResourceStateRequest, ...dcerpc.CallOption) (*GetResourceStateResponse, error)

	// ApiSetResourceName operation.
	SetResourceName(context.Context, *SetResourceNameRequest, ...dcerpc.CallOption) (*SetResourceNameResponse, error)

	// ApiGetResourceId operation.
	GetResourceID(context.Context, *GetResourceIDRequest, ...dcerpc.CallOption) (*GetResourceIDResponse, error)

	// ApiGetResourceType operation.
	GetResourceType(context.Context, *GetResourceTypeRequest, ...dcerpc.CallOption) (*GetResourceTypeResponse, error)

	// ApiFailResource operation.
	FailResource(context.Context, *FailResourceRequest, ...dcerpc.CallOption) (*FailResourceResponse, error)

	// ApiOnlineResource operation.
	OnlineResource(context.Context, *OnlineResourceRequest, ...dcerpc.CallOption) (*OnlineResourceResponse, error)

	// ApiOfflineResource operation.
	OfflineResource(context.Context, *OfflineResourceRequest, ...dcerpc.CallOption) (*OfflineResourceResponse, error)

	// ApiAddResourceDependency operation.
	AddResourceDependency(context.Context, *AddResourceDependencyRequest, ...dcerpc.CallOption) (*AddResourceDependencyResponse, error)

	// ApiRemoveResourceDependency operation.
	RemoveResourceDependency(context.Context, *RemoveResourceDependencyRequest, ...dcerpc.CallOption) (*RemoveResourceDependencyResponse, error)

	// ApiCanResourceBeDependent operation.
	CanResourceBeDependent(context.Context, *CanResourceBeDependentRequest, ...dcerpc.CallOption) (*CanResourceBeDependentResponse, error)

	// ApiCreateResEnum operation.
	CreateRestrictionEnum(context.Context, *CreateRestrictionEnumRequest, ...dcerpc.CallOption) (*CreateRestrictionEnumResponse, error)

	// ApiAddResourceNode operation.
	AddResourceNode(context.Context, *AddResourceNodeRequest, ...dcerpc.CallOption) (*AddResourceNodeResponse, error)

	// ApiRemoveResourceNode operation.
	RemoveResourceNode(context.Context, *RemoveResourceNodeRequest, ...dcerpc.CallOption) (*RemoveResourceNodeResponse, error)

	// ApiChangeResourceGroup operation.
	ChangeResourceGroup(context.Context, *ChangeResourceGroupRequest, ...dcerpc.CallOption) (*ChangeResourceGroupResponse, error)

	// ApiCreateResourceType operation.
	CreateResourceType(context.Context, *CreateResourceTypeRequest, ...dcerpc.CallOption) (*CreateResourceTypeResponse, error)

	// ApiDeleteResourceType operation.
	DeleteResourceType(context.Context, *DeleteResourceTypeRequest, ...dcerpc.CallOption) (*DeleteResourceTypeResponse, error)

	// ApiGetRootKey operation.
	GetRootKey(context.Context, *GetRootKeyRequest, ...dcerpc.CallOption) (*GetRootKeyResponse, error)

	// ApiCreateKey operation.
	CreateKey(context.Context, *CreateKeyRequest, ...dcerpc.CallOption) (*CreateKeyResponse, error)

	// ApiOpenKey operation.
	OpenKey(context.Context, *OpenKeyRequest, ...dcerpc.CallOption) (*OpenKeyResponse, error)

	// ApiEnumKey operation.
	EnumKey(context.Context, *EnumKeyRequest, ...dcerpc.CallOption) (*EnumKeyResponse, error)

	// ApiSetValue operation.
	SetValue(context.Context, *SetValueRequest, ...dcerpc.CallOption) (*SetValueResponse, error)

	// ApiDeleteValue operation.
	DeleteValue(context.Context, *DeleteValueRequest, ...dcerpc.CallOption) (*DeleteValueResponse, error)

	// ApiQueryValue operation.
	QueryValue(context.Context, *QueryValueRequest, ...dcerpc.CallOption) (*QueryValueResponse, error)

	// ApiDeleteKey operation.
	DeleteKey(context.Context, *DeleteKeyRequest, ...dcerpc.CallOption) (*DeleteKeyResponse, error)

	// ApiEnumValue operation.
	EnumValue(context.Context, *EnumValueRequest, ...dcerpc.CallOption) (*EnumValueResponse, error)

	// ApiCloseKey operation.
	CloseKey(context.Context, *CloseKeyRequest, ...dcerpc.CallOption) (*CloseKeyResponse, error)

	// ApiQueryInfoKey operation.
	QueryInfoKey(context.Context, *QueryInfoKeyRequest, ...dcerpc.CallOption) (*QueryInfoKeyResponse, error)

	// ApiSetKeySecurity operation.
	SetKeySecurity(context.Context, *SetKeySecurityRequest, ...dcerpc.CallOption) (*SetKeySecurityResponse, error)

	// ApiGetKeySecurity operation.
	GetKeySecurity(context.Context, *GetKeySecurityRequest, ...dcerpc.CallOption) (*GetKeySecurityResponse, error)

	// ApiOpenGroup operation.
	OpenGroup(context.Context, *OpenGroupRequest, ...dcerpc.CallOption) (*OpenGroupResponse, error)

	// ApiCreateGroup operation.
	CreateGroup(context.Context, *CreateGroupRequest, ...dcerpc.CallOption) (*CreateGroupResponse, error)

	// ApiDeleteGroup operation.
	DeleteGroup(context.Context, *DeleteGroupRequest, ...dcerpc.CallOption) (*DeleteGroupResponse, error)

	// ApiCloseGroup operation.
	CloseGroup(context.Context, *CloseGroupRequest, ...dcerpc.CallOption) (*CloseGroupResponse, error)

	// ApiGetGroupState operation.
	GetGroupState(context.Context, *GetGroupStateRequest, ...dcerpc.CallOption) (*GetGroupStateResponse, error)

	// ApiSetGroupName operation.
	SetGroupName(context.Context, *SetGroupNameRequest, ...dcerpc.CallOption) (*SetGroupNameResponse, error)

	// ApiGetGroupId operation.
	GetGroupID(context.Context, *GetGroupIDRequest, ...dcerpc.CallOption) (*GetGroupIDResponse, error)

	// ApiGetNodeId operation.
	GetNodeID(context.Context, *GetNodeIDRequest, ...dcerpc.CallOption) (*GetNodeIDResponse, error)

	// ApiOnlineGroup operation.
	OnlineGroup(context.Context, *OnlineGroupRequest, ...dcerpc.CallOption) (*OnlineGroupResponse, error)

	// ApiOfflineGroup operation.
	OfflineGroup(context.Context, *OfflineGroupRequest, ...dcerpc.CallOption) (*OfflineGroupResponse, error)

	// ApiMoveGroup operation.
	MoveGroup(context.Context, *MoveGroupRequest, ...dcerpc.CallOption) (*MoveGroupResponse, error)

	// ApiMoveGroupToNode operation.
	MoveGroupToNode(context.Context, *MoveGroupToNodeRequest, ...dcerpc.CallOption) (*MoveGroupToNodeResponse, error)

	// ApiCreateGroupResourceEnum operation.
	CreateGroupResourceEnum(context.Context, *CreateGroupResourceEnumRequest, ...dcerpc.CallOption) (*CreateGroupResourceEnumResponse, error)

	// ApiSetGroupNodeList operation.
	SetGroupNodeList(context.Context, *SetGroupNodeListRequest, ...dcerpc.CallOption) (*SetGroupNodeListResponse, error)

	// ApiCreateNotify operation.
	CreateNotify(context.Context, *CreateNotifyRequest, ...dcerpc.CallOption) (*CreateNotifyResponse, error)

	// ApiCloseNotify operation.
	CloseNotify(context.Context, *CloseNotifyRequest, ...dcerpc.CallOption) (*CloseNotifyResponse, error)

	// ApiAddNotifyCluster operation.
	AddNotifyCluster(context.Context, *AddNotifyClusterRequest, ...dcerpc.CallOption) (*AddNotifyClusterResponse, error)

	// ApiAddNotifyNode operation.
	AddNotifyNode(context.Context, *AddNotifyNodeRequest, ...dcerpc.CallOption) (*AddNotifyNodeResponse, error)

	// ApiAddNotifyGroup operation.
	AddNotifyGroup(context.Context, *AddNotifyGroupRequest, ...dcerpc.CallOption) (*AddNotifyGroupResponse, error)

	// ApiAddNotifyResource operation.
	AddNotifyResource(context.Context, *AddNotifyResourceRequest, ...dcerpc.CallOption) (*AddNotifyResourceResponse, error)

	// ApiAddNotifyKey operation.
	AddNotifyKey(context.Context, *AddNotifyKeyRequest, ...dcerpc.CallOption) (*AddNotifyKeyResponse, error)

	// ApiReAddNotifyNode operation.
	ReAddNotifyNode(context.Context, *ReAddNotifyNodeRequest, ...dcerpc.CallOption) (*ReAddNotifyNodeResponse, error)

	// ApiReAddNotifyGroup operation.
	ReAddNotifyGroup(context.Context, *ReAddNotifyGroupRequest, ...dcerpc.CallOption) (*ReAddNotifyGroupResponse, error)

	// ApiReAddNotifyResource operation.
	ReAddNotifyResource(context.Context, *ReAddNotifyResourceRequest, ...dcerpc.CallOption) (*ReAddNotifyResourceResponse, error)

	// ApiGetNotify operation.
	GetNotify(context.Context, *GetNotifyRequest, ...dcerpc.CallOption) (*GetNotifyResponse, error)

	// ApiOpenNode operation.
	OpenNode(context.Context, *OpenNodeRequest, ...dcerpc.CallOption) (*OpenNodeResponse, error)

	// ApiCloseNode operation.
	CloseNode(context.Context, *CloseNodeRequest, ...dcerpc.CallOption) (*CloseNodeResponse, error)

	// ApiGetNodeState operation.
	GetNodeState(context.Context, *GetNodeStateRequest, ...dcerpc.CallOption) (*GetNodeStateResponse, error)

	// ApiPauseNode operation.
	PauseNode(context.Context, *PauseNodeRequest, ...dcerpc.CallOption) (*PauseNodeResponse, error)

	// ApiResumeNode operation.
	ResumeNode(context.Context, *ResumeNodeRequest, ...dcerpc.CallOption) (*ResumeNodeResponse, error)

	// ApiEvictNode operation.
	EvictNode(context.Context, *EvictNodeRequest, ...dcerpc.CallOption) (*EvictNodeResponse, error)

	// ApiNodeResourceControl operation.
	NodeResourceControl(context.Context, *NodeResourceControlRequest, ...dcerpc.CallOption) (*NodeResourceControlResponse, error)

	// ApiResourceControl operation.
	ResourceControl(context.Context, *ResourceControlRequest, ...dcerpc.CallOption) (*ResourceControlResponse, error)

	// ApiNodeResourceTypeControl operation.
	NodeResourceTypeControl(context.Context, *NodeResourceTypeControlRequest, ...dcerpc.CallOption) (*NodeResourceTypeControlResponse, error)

	// ApiResourceTypeControl operation.
	ResourceTypeControl(context.Context, *ResourceTypeControlRequest, ...dcerpc.CallOption) (*ResourceTypeControlResponse, error)

	// ApiNodeGroupControl operation.
	NodeGroupControl(context.Context, *NodeGroupControlRequest, ...dcerpc.CallOption) (*NodeGroupControlResponse, error)

	// ApiGroupControl operation.
	GroupControl(context.Context, *GroupControlRequest, ...dcerpc.CallOption) (*GroupControlResponse, error)

	// ApiNodeNodeControl operation.
	NodeNodeControl(context.Context, *NodeNodeControlRequest, ...dcerpc.CallOption) (*NodeNodeControlResponse, error)

	// ApiNodeControl operation.
	NodeControl(context.Context, *NodeControlRequest, ...dcerpc.CallOption) (*NodeControlResponse, error)

	// Opnum80NotUsedOnWire operation.
	// Opnum80NotUsedOnWire

	// ApiOpenNetwork operation.
	OpenNetwork(context.Context, *OpenNetworkRequest, ...dcerpc.CallOption) (*OpenNetworkResponse, error)

	// ApiCloseNetwork operation.
	CloseNetwork(context.Context, *CloseNetworkRequest, ...dcerpc.CallOption) (*CloseNetworkResponse, error)

	// ApiGetNetworkState operation.
	GetNetworkState(context.Context, *GetNetworkStateRequest, ...dcerpc.CallOption) (*GetNetworkStateResponse, error)

	// ApiSetNetworkName operation.
	SetNetworkName(context.Context, *SetNetworkNameRequest, ...dcerpc.CallOption) (*SetNetworkNameResponse, error)

	// ApiCreateNetworkEnum operation.
	CreateNetworkEnum(context.Context, *CreateNetworkEnumRequest, ...dcerpc.CallOption) (*CreateNetworkEnumResponse, error)

	// ApiGetNetworkId operation.
	GetNetworkID(context.Context, *GetNetworkIDRequest, ...dcerpc.CallOption) (*GetNetworkIDResponse, error)

	// ApiSetNetworkPriorityOrder operation.
	SetNetworkPriorityOrder(context.Context, *SetNetworkPriorityOrderRequest, ...dcerpc.CallOption) (*SetNetworkPriorityOrderResponse, error)

	// ApiNodeNetworkControl operation.
	NodeNetworkControl(context.Context, *NodeNetworkControlRequest, ...dcerpc.CallOption) (*NodeNetworkControlResponse, error)

	// ApiNetworkControl operation.
	NetworkControl(context.Context, *NetworkControlRequest, ...dcerpc.CallOption) (*NetworkControlResponse, error)

	// ApiAddNotifyNetwork operation.
	AddNotifyNetwork(context.Context, *AddNotifyNetworkRequest, ...dcerpc.CallOption) (*AddNotifyNetworkResponse, error)

	// ApiReAddNotifyNetwork operation.
	ReAddNotifyNetwork(context.Context, *ReAddNotifyNetworkRequest, ...dcerpc.CallOption) (*ReAddNotifyNetworkResponse, error)

	// ApiOpenNetInterface operation.
	OpenNetInterface(context.Context, *OpenNetInterfaceRequest, ...dcerpc.CallOption) (*OpenNetInterfaceResponse, error)

	// ApiCloseNetInterface operation.
	CloseNetInterface(context.Context, *CloseNetInterfaceRequest, ...dcerpc.CallOption) (*CloseNetInterfaceResponse, error)

	// ApiGetNetInterfaceState operation.
	GetNetInterfaceState(context.Context, *GetNetInterfaceStateRequest, ...dcerpc.CallOption) (*GetNetInterfaceStateResponse, error)

	// ApiGetNetInterface operation.
	GetNetInterface(context.Context, *GetNetInterfaceRequest, ...dcerpc.CallOption) (*GetNetInterfaceResponse, error)

	// ApiGetNetInterfaceId operation.
	GetNetInterfaceID(context.Context, *GetNetInterfaceIDRequest, ...dcerpc.CallOption) (*GetNetInterfaceIDResponse, error)

	// ApiNodeNetInterfaceControl operation.
	NodeNetInterfaceControl(context.Context, *NodeNetInterfaceControlRequest, ...dcerpc.CallOption) (*NodeNetInterfaceControlResponse, error)

	// ApiNetInterfaceControl operation.
	NetInterfaceControl(context.Context, *NetInterfaceControlRequest, ...dcerpc.CallOption) (*NetInterfaceControlResponse, error)

	// ApiAddNotifyNetInterface operation.
	AddNotifyNetInterface(context.Context, *AddNotifyNetInterfaceRequest, ...dcerpc.CallOption) (*AddNotifyNetInterfaceResponse, error)

	// ApiReAddNotifyNetInterface operation.
	ReAddNotifyNetInterface(context.Context, *ReAddNotifyNetInterfaceRequest, ...dcerpc.CallOption) (*ReAddNotifyNetInterfaceResponse, error)

	// ApiCreateNodeEnum operation.
	CreateNodeEnum(context.Context, *CreateNodeEnumRequest, ...dcerpc.CallOption) (*CreateNodeEnumResponse, error)

	// ApiGetClusterVersion2 operation.
	GetClusterVersion2(context.Context, *GetClusterVersion2Request, ...dcerpc.CallOption) (*GetClusterVersion2Response, error)

	// ApiCreateResTypeEnum operation.
	CreateRestrictionTypeEnum(context.Context, *CreateRestrictionTypeEnumRequest, ...dcerpc.CallOption) (*CreateRestrictionTypeEnumResponse, error)

	// ApiBackupClusterDatabase operation.
	BackupClusterDatabase(context.Context, *BackupClusterDatabaseRequest, ...dcerpc.CallOption) (*BackupClusterDatabaseResponse, error)

	// ApiNodeClusterControl operation.
	NodeClusterControl(context.Context, *NodeClusterControlRequest, ...dcerpc.CallOption) (*NodeClusterControlResponse, error)

	// ApiClusterControl operation.
	ClusterControl(context.Context, *ClusterControlRequest, ...dcerpc.CallOption) (*ClusterControlResponse, error)

	// ApiUnblockGetNotifyCall operation.
	UnblockGetNotifyCall(context.Context, *UnblockGetNotifyCallRequest, ...dcerpc.CallOption) (*UnblockGetNotifyCallResponse, error)

	// ApiSetServiceAccountPassword operation.
	SetServiceAccountPassword(context.Context, *SetServiceAccountPasswordRequest, ...dcerpc.CallOption) (*SetServiceAccountPasswordResponse, error)

	// (Protocol Version 3) The ApiSetResourceDependencyExpression method instructs the
	// server to set the dependency relationship for the resource that is identified by
	// hResource to the complex dependency, as specified in section 3.1.1.1.2, using dependency
	// expression represented by lpszDependencyExpression. For successful completion of
	// the method, the server MUST add the dependency information to the nonvolatile cluster
	// state.
	//
	// Servers MUST maintain complex resource dependencies as nonvolatile configuration
	// data in their cluster state.
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                   RETURN                   |                                                                                  |
	//	|                 VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                   | Success.                                                                         |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE            | The data that is pointed to by the hResource parameter does not represent a      |
	//	|                                            | valid HRES_RPC context handle.                                                   |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER         | See the preceding text for details of when this error can occur.                 |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000423 ERROR_CIRCULAR_DEPENDENCY       | See the preceding text for details of when this error can occur.                 |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000138B ERROR_DEPENDENCY_ALREADY_EXISTS | See the preceding text for details of when this error can occur.                 |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000139B ERROR_RESOURCE_ONLINE           | See the preceding text for details of when this error can occur.                 |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000013CD ERROR_DEPENDENCY_NOT_ALLOWED    | Cannot depend on quorum resource.                                                |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors specified in section 3.2.4.6 as recoverable errors and initiate the
	// reconnect procedure as specified in section 3.2.4.6.
	SetResourceDependencyExpression(context.Context, *SetResourceDependencyExpressionRequest, ...dcerpc.CallOption) (*SetResourceDependencyExpressionResponse, error)

	// (Protocol Version 3) The ApiGetResourceDependencyExpression method instructs the
	// server to retrieve the complex dependency expression, as specified in section 3.1.1.1.2,
	// for the resource represented by hResource.
	//
	// The server SHOULD accept an ApiGetResourceDependencyExpression request if its protocol
	// server state is read-only, and the server MUST accept an ApiGetResourceDependencyExpression
	// request for processing if it is in the read/write state, as specified in section
	// 3.1.1.
	//
	// The server SHOULD accept an ApiGetResourceDependencyExpression request if the access
	// level associated with the hResource context handle is at least "Read" (section 3.1.4).
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | Success.                                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE | The data that is pointed to by the hResource parameter does not represent a      |
	//	|                                 | valid HRES_RPC context handle.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors as recoverable errors and initiate the reconnect procedure as specified
	// in section 3.2.4.6.
	GetResourceDependencyExpression(context.Context, *GetResourceDependencyExpressionRequest, ...dcerpc.CallOption) (*GetResourceDependencyExpressionResponse, error)

	// Opnum111NotUsedOnWire operation.
	// Opnum111NotUsedOnWire

	// (Protocol Version 3) The ApiGetResourceNetworkName method retrieves the NetBIOS computer
	// name associated with the resource upon which the designated resource depends and
	// whose resource type, as specified in section 3.1.4.2.16, matches the Unicode string
	// "Network Name".
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE       | The data that is pointed to by the hResource parameter does not represent a      |
	//	|                                       | valid HRES_RPC context handle.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000138A ERROR_DEPENDENCY_NOT_FOUND | A resource that has the resource type that matches the Unicode string "Network   |
	//	|                                       | Name" was not found in any dependency chains that start from the designated      |
	//	|                                       | resource.                                                                        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors specified in 3.2.4.6 as recoverable errors and initiate the reconnect
	// procedure as specified in section 3.2.4.6.
	GetResourceNetworkName(context.Context, *GetResourceNetworkNameRequest, ...dcerpc.CallOption) (*GetResourceNetworkNameResponse, error)

	// (Protocol Version 3) The ApiExecuteBatch method instructs the server to perform a
	// transacted series of modifications, relative to the designated key, to the cluster
	// registry. The contents of the registry are changed only if all the modifications
	// succeed; the first failure causes all previous modifications to be backed out.
	//
	// The modifications are described in a CLUSTER_REG_BATCH_UPDATE structure, as described
	// in section 2.2.3.17. Each batch update command instructs the server as to how the
	// registry is modified.
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS           | Success.                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE    | The data that is pointed to by the hKey parameter does not represent a valid     |
	//	|                                    | HKEY_RPC context handle.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A CLUSREG_SET_VALUE or CLUSREG_DELETE_VALUE command has been encountered prior   |
	//	|                                    | to a CLUSREG_CREATE_KEY command.                                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors specified in section 3.2.4.6 as recoverable errors and initiate the
	// reconnect procedure as specified in section 3.2.4.6.
	ExecuteBatch(context.Context, *ExecuteBatchRequest, ...dcerpc.CallOption) (*ExecuteBatchResponse, error)

	// (Protocol Version 3) The ApiCreateBatchPort method establishes context on the server
	// about client interaction with a cluster registry batch update notification port by
	// means of the current RPC connection. ApiCreateBatchPort returns a context handle
	// so that the client can refer to the context that is created in subsequent method
	// invocations.
	//
	// The server SHOULD accept an ApiCreateBatchPort request if the client's access level
	// is at least "Read" (section 3.1.4).
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | Success.                                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE | The data that is pointed to by the hKey parameter does not represent a valid     |
	//	|                                 | HKEY_RPC context handle.                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors as recoverable errors, and initiate the reconnect procedure as specified
	// in section 3.2.4.6.
	CreateBatchPort(context.Context, *CreateBatchPortRequest, ...dcerpc.CallOption) (*CreateBatchPortResponse, error)

	// (Protocol Version 3) The ApiGetBatchNotification method instructs the server to retrieve
	// the first queued batch update event indication from the designated batch update notification_port.
	// The server MUST NOT complete this method until an indication has been queued to the
	// port or the port has been closed through a separate call to the ApiCloseBatchPort
	// method.
	//
	// Upon successful completion of this method, the server MUST write a CLUSTER_REG_BATCH_UPDATE
	// structure, as specified in section 2.2.3.17, indicating the modifications that have
	// been made to the cluster registry. This information essentially mirrors the CLUSTER_REG_BATCH_UPDATE
	// structure provided to the ApiExecuteBatch method with the modification that a CLUSREG_VALUE_DELETED
	// command precedes every CLUSREG_SET_VALUE and CLUSREG_DELETE_VALUE command in the
	// returned notification data if the value has existing data. The Name field identifies
	// the name of the value that was modified, and the Data field contains the value data
	// that existed prior to executing the aforementioned value command.
	//
	// For example, the client calls ApiExecuteBatch with the following series of commands
	// for a value named "NotifyTest" that does not already exist in the registry:
	//
	// * Delete Value
	//
	// * Set Value to "hello world"
	//
	// * Set Value to "hello universe"
	//
	// * Delete Value
	//
	// The series of change notifications that the server returns to the client through
	// this method are as follows:
	//
	// * Delete Value
	//
	// * Set Value to "hello world"
	//
	// * Value Deleted with the data set to "hello world"
	//
	// * Set Value to "hello universe"
	//
	// * Value Deleted with the data set to "hello universe"
	//
	// * Delete Value
	//
	// The following diagrams illustrate the preceding command and notification sequence.
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | Success.                                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE | The data that is pointed to by the hBatchNotify parameter does not represent a   |
	//	|                                 | valid HBATCH_PORT_RPC context handle.                                            |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | The port referenced by the hBatchNotify parameter has been closed by a separate  |
	//	|                                 | call to the ApiCloseBatchPort method.                                            |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of those
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table.
	GetBatchNotification(context.Context, *GetBatchNotificationRequest, ...dcerpc.CallOption) (*GetBatchNotificationResponse, error)

	// (Protocol Version 3) The ApiCloseBatchPort method instructs the server to free any
	// context information that is created in a previous ApiCreateBatchPort method.
	//
	// The server SHOULD accept an ApiCloseBatchPort request if its protocol server state
	// is read-only, and the server MUST accept the request for processing if it is in the
	// read/write state, as specified in section 3.1.1.
	//
	// The server SHOULD accept an ApiCloseBatchPort request if the client's access level
	// is at least "Read" (section 3.1.4).
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | Success.                                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE | The data that is pointed to by the phBatchPort parameter does not represent a    |
	//	|                                 | valid HBATCH_PORT_RPC context handle.                                            |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method MUST return a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table.
	CloseBatchPort(context.Context, *CloseBatchPortRequest, ...dcerpc.CallOption) (*CloseBatchPortResponse, error)

	// (Protocol Version 3) The ApiOpenClusterEx method SHOULD<96> establish context on
	// the server about client interaction with the cluster by means of the current RPC
	// connection. ApiOpenClusterEx returns a context handle so that the client can refer
	// to the context that is created in subsequent method calls.
	//
	// Return Values: The method MUST return a valid HCLUSTER_RPC (section 2.2.1.1) context
	// handle to indicate success; otherwise, it MUST return NULL.
	OpenClusterEx(context.Context, *OpenClusterExRequest, ...dcerpc.CallOption) (*OpenClusterExResponse, error)

	// (Protocol Version 3) The ApiOpenNodeEx method SHOULD<97> establish context on the
	// server about the interaction of a client with the specified cluster node by using
	// the current RPC connection. ApiOpenNodeEx returns a context handle so that the client
	// can refer to the context that is created in subsequent method calls.
	//
	// Return Values: The method MUST return a valid HNODE_RPC (section 2.2.1.2) context
	// handle to indicate success; otherwise, it MUST return NULL.
	OpenNodeEx(context.Context, *OpenNodeExRequest, ...dcerpc.CallOption) (*OpenNodeExResponse, error)

	// (Protocol Version 3) The ApiOpenGroupEx method SHOULD<98> establish context on the
	// server about the interaction of a client with a specified cluster group by means
	// of the current RPC connection. ApiOpenGroupEx returns a context handle so that the
	// client can refer to the group in subsequent method calls.
	//
	// Return Values: The method MUST return a valid HGROUP_RPC context handle (section
	// 2.2.1.3) to indicate success; otherwise, it MUST return NULL.
	OpenGroupEx(context.Context, *OpenGroupExRequest, ...dcerpc.CallOption) (*OpenGroupExResponse, error)

	// (Protocol Version 3) The ApiOpenResourceEx method SHOULD<99> establish context on
	// the server about the interaction of a client with the specified cluster resource
	// by using the current RPC connection. ApiOpenResourceEx returns a context handle so
	// that the client can refer to the resource in subsequent method calls.
	//
	// Return Values: The method MUST return a valid HRES_RPC (section 2.2.1.4) context
	// handle to indicate success; otherwise, it MUST return NULL.
	OpenResourceEx(context.Context, *OpenResourceExRequest, ...dcerpc.CallOption) (*OpenResourceExResponse, error)

	// (Protocol Version 3) The ApiOpenNetworkEx method SHOULD<100> establish context on
	// the server about the interaction of a client with the specified cluster network by
	// using the current RPC connection. ApiOpenNetworkEx returns a context handle so that
	// the client can refer to the context that is created in subsequent method calls.
	//
	// Return Values: The method MUST return a valid HNETWORK_RPC (section 2.2.1.7) context
	// handle to indicate success; otherwise, it MUST return NULL.
	OpenNetworkEx(context.Context, *OpenNetworkExRequest, ...dcerpc.CallOption) (*OpenNetworkExResponse, error)

	// (Protocol Version 3) The ApiOpenNetInterfaceEx method SHOULD<101> establish context
	// on the server about the interaction of a client with the specified cluster network
	// interface by using the current RPC connection. ApiOpenNetInterfaceEx returns a context
	// handle so that the client can refer to the context that is created in subsequent
	// method calls.
	//
	// Return Values: The method MUST return a valid HNETINTERFACE_RPC (section 2.2.1.8)
	// context handle to indicate success; otherwise, it MUST return NULL.
	OpenNetInterfaceEx(context.Context, *OpenNetInterfaceExRequest, ...dcerpc.CallOption) (*OpenNetInterfaceExResponse, error)

	// (Protocol Version 3) The ApiChangeCsvState method SHOULD<102> instruct the server
	// to change the accessibility of the disk associated with hResource.
	//
	// If dwState is 1, the server MUST set ResourceSharedVolumes to TRUE and convert all
	// volumes associated with hResource to cluster shared volumes. The server MUST set
	// the initial state of all cluster shared volumes associated with hResource such that
	// volume maintenance mode, redirected mode, and backup mode are all disabled.
	//
	// If dwState is 1, the server SHOULD also designate the group associated with hResource
	// as a special group, as specified in section 3.1.1.1.4.
	//
	// If dwState is 0, the server MUST set ResourceSharedVolumes to FALSE and stop making
	// the volumes associated with hResource accessible to all nodes as cluster shared volumes.
	//
	// If dwState is 0, the server SHOULD also remove the special group designation of the
	// group associated with hResource.
	//
	// The server SHOULD accept an ApiChangeCsvState request if its protocol server state
	// is read-only, and the server MUST accept the request for processing if it is in the
	// read/write state, as specified in section 3.1.1.
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                     RETURN                     |                                                                                  |
	//	|                   VALUE/CODE                   |                                   DESCRIPTION                                    |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                       | Success.                                                                         |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000003E5 ERROR_IO_PENDING                    | The operation is still in progress.                                              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000046 ERROR_SHARING_PAUSED                | The current protocol server state of the server is not read/write.               |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006D1 RPC_S_PROCNUM_OUT_OF_RANGE          | The server does not support this method.                                         |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000013B8 ERROR_CLUSTER_INVALID_REQUEST       | The operation is invalid for the cluster or for the specified resource . It is   |
	//	|                                                | invalid for the cluster if the dwState parameter is 1 and the requested state is |
	//	|                                                | not enabled for the cluster; for instance, the server EnableSharedVolumes state  |
	//	|                                                | is FALSE (indicating that the server does not support cluster shared volumes)    |
	//	|                                                | (see section 3.1.1.4). The operation is invalid for the specified resource if    |
	//	|                                                | any of the following conditions are met: The dwState parameter is 1, and the     |
	//	|                                                | specified resource is already deployed to an application/service. The dwState    |
	//	|                                                | parameter is 1, and the specified resource is in maintenance mode (see section   |
	//	|                                                | 3.1.1.1.1.2). The dwState parameter is 1, and the specified resource depends on  |
	//	|                                                | one or more additional resources. The dwState parameter is 0, and the specified  |
	//	|                                                | resource does not currently allow volumes to be shared to all nodes in a cluster |
	//	|                                                | (ResourceSharedVolumes is already FALSE).                                        |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000013D7 ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED | The dwState parameter is 1 and the specified resource is not of the correct      |
	//	|                                                | type. Shared access can only be enabled for resources that are of the Physical   |
	//	|                                                | Disk Resource type.                                                              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000138C ERROR_RESOURCE_NOT_ONLINE           | The dwState parameter is 1 and the specified resource is not online. The         |
	//	|                                                | resource MUST be online to enable shared access.                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method returns a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client treats
	// errors specified in 3.2.4.6 as recoverable errors and initiate the reconnect procedure
	// as specified in section 3.2.4.6.
	ChangeCSVState(context.Context, *ChangeCSVStateRequest, ...dcerpc.CallOption) (*ChangeCSVStateResponse, error)

	// (Protocol Version 3) The ApiCreateNodeEnumEx method SHOULD<103> return two ENUM_LIST
	// structures of equal length containing the ID and Name attributes of the requested
	// objects of the specified enumeration type from the cluster state. Each Element in
	// the ReturnIdEnum parameter corresponds to the ID of the element at the same offset
	// in the ReturnNameEnum parameter.
	//
	// If multiple enumeration types are indicated, the resulting ENUM_LIST contains zero
	// or more entries of each type, and the type of each entry in the lists are indicated
	// by the ENUM_ENTRY data structure, as specified in section 2.2.3.4.
	//
	// The server SHOULD accept an ApiCreateNodeEnumEx request if its protocol server state
	// is read-only, and the server MUST accept the request for processing if it is in the
	// read/write state, as specified in section 3.1.1.
	//
	// Return Values: The method MUST return the following error codes for the specified
	// conditions.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000057 ERROR_INVALID_PARAMETER   | The dwType parameter is not one of the specified values, or the dwOptions        |
	//	|                                       | parameter is not 0x00000000.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006D1 RPC_S_PROCNUM_OUT_OF_RANGE | The server does not support this method.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, this method returns a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. The client SHOULD
	// treat errors specified in 3.2.4.6 as recoverable errors and initiate the reconnect
	// procedure as specified in section 3.2.4.6.
	CreateNodeEnumEx(context.Context, *CreateNodeEnumExRequest, ...dcerpc.CallOption) (*CreateNodeEnumExResponse, error)

	// (Protocol Version 3) The ApiCreateEnumEx method SHOULD<104> return two ENUM_LIST
	// structures of equal length containing the ID and Name attributes of the requested
	// objects of the specified enumeration type from the cluster state. Each Element in
	// the ReturnIdEnum parameter corresponds to the ID of the element at the same offset
	// in the ReturnNameEnum parameter.
	//
	// If multiple enumeration types are indicated, the resulting ENUM_LIST contains zero
	// or more entries of each type, and the type of each entry in the list is indicated
	// by the ENUM_ENTRY data structure, as specified in section 2.2.3.4.
	//
	// The server SHOULD accept an ApiCreateEnumEx request if its protocol server state
	// is read-only, as specified in section 3.1.1, and the dwType parameter is CLUSTER_ENUM_NODE.
	// The server MUST accept an ApiCreateEnumEx request if its protocol server state is
	// read/write.
	//
	// Return Values: The method MUST return the following error codes for the conditions
	// that are specified as follows.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY    | The server failed to allocate enough memory for the ReturnEnum parameter.        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000057 ERROR_INVALID_PARAMETER   | The enumeration type that is specified by dwType is not valid or dwOptions is    |
	//	|                                       | not set to 0x00000000.                                                           |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006D1 RPC_S_PROCNUM_OUT_OF_RANGE | The server does not support this method.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST behave in one consistent, identical
	// manner for all values that are not listed in the preceding table. However, the client
	// SHOULD treat errors specified in 3.2.4.6 as recoverable errors and initiate the reconnect
	// procedure as specified in section 3.2.4.6.
	CreateEnumEx(context.Context, *CreateEnumExRequest, ...dcerpc.CallOption) (*CreateEnumExResponse, error)

	// (Protocol Version 3) The ApiPauseNodeEx method SHOULD<105> instruct the server to
	// suspend group ownership and failover activity on the designated node and, optionally,
	// to move groups on the designated node to different nodes in the cluster.
	//
	// Return Values: The method MUST return one of the following error codes.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                        |                                                                                  |
	//	|                      VALUE/CODE                      |                                   DESCRIPTION                                    |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The method completed successfully.                                               |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE                      | The data that is designated by the hNode parameter does not represent a valid    |
	//	|                                                      | HNODE_RPC context handle.                                                        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000013BA ERROR_CLUSTER_NODE_DOWN                   | There are no nodes in the cluster that are in the ClusterNodeUp state other than |
	//	|                                                      | the node designated by the hNode parameter.                                      |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000003E5 ERROR_IO_PENDING                          | The server is in the process of evacuating the specified node.                   |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000174A ERROR_CLUSTER_NODE_EVACUATION_IN_PROGRESS | The server is already evacuating the specified node due to a prior call to this  |
	//	|                                                      | method.                                                                          |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST behave identically for all return
	// values that are not listed in the preceding table; however, the client SHOULD treat
	// errors specified in section 3.2.4.6 as recoverable errors and initiate the reconnect
	// procedure as specified in that section.
	PauseNodeEx(context.Context, *PauseNodeExRequest, ...dcerpc.CallOption) (*PauseNodeExResponse, error)

	// (Protocol Version 3) The ApiPauseNodeWithDrainTarget method SHOULD<106> instruct
	// the server to suspend group ownership and failover activity on the designated target
	// node and to move all groups from the designated node to a designated node in the
	// cluster.
	//
	// This server MUST handle this method in the same manner as ApiPauseNodeEx (section
	// 3.1.4.2.125) except that the server MUST attempt to move groups hosted by the node
	// specified by the hNode parameter to the node specified by the hNodeDrainTarget parameter.
	// The server SHOULD move the groups according to preferences, limitations, and other
	// policies as if ApiMoveGroupToNode (section 3.1.4.2.53) or ApiMoveGroupToNodeEx (section
	// 3.1.4.2.132) had been called for each of these groups individually.
	//
	// Return Values: This method MUST return one of the error codes returned by ApiPauseNodeEx
	// (section 3.1.4.2.125) or one of the following values:
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000138D ERROR_HOST_NODE_NOT_AVAILABLE | The node designated by the hNodeDrainTarget parameter is in an invalid state.    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000072 ERROR_INVALID_TARGET_HANDLE   | The node designated by the hNodeDrainTarget parameter is an invalid destination  |
	//	|                                          | node. This method MUST return ERROR_INVALID_TARGET_HANDLE if the node designated |
	//	|                                          | by the hNodeDrainTarget parameter is the same as the node designated by the      |
	//	|                                          | hNode parameter.                                                                 |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST behave identically for all return
	// values that are not listed in the preceding table; however, the client SHOULD treat
	// errors specified in section 3.2.4.6 as recoverable errors and initiate the reconnect
	// procedure as specified in that section.
	PauseNodeWithDrainTarget(context.Context, *PauseNodeWithDrainTargetRequest, ...dcerpc.CallOption) (*PauseNodeWithDrainTargetResponse, error)

	// ApiResumeNodeEx operation.
	ResumeNodeEx(context.Context, *ResumeNodeExRequest, ...dcerpc.CallOption) (*ResumeNodeExResponse, error)

	// (Protocol Version 3) The ApiCreateGroupEx method SHOULD<108> extend functionality
	// of the ApiCreateGroup (section 3.1.4.2.43) method, allowing the client to provide
	// additional information about the group being created.
	//
	// Return Values: This method MUST return a valid HGROUP_RPC context handle, as specified
	// in section 2.2.1.3, to indicate success. Otherwise, it MUST return NULL.
	CreateGroupEx(context.Context, *CreateGroupExRequest, ...dcerpc.CallOption) (*CreateGroupExResponse, error)

	// (Protocol Version 3) The ApiOnlineGroupEx method SHOULD<109> instruct the server
	// to make all the resources in the designated group active or available on the node
	// that is hosting the group. The persistent state of the group is set to Online and
	// is updated in the nonvolatile cluster state.
	//
	// Return Values: This method MUST return the same error codes as specified for ApiOnlineGroup
	// (section 3.1.4.2.50), in addition to the following return value.
	//
	//	+------------------------------------+-----------------------------------------------------------------+
	//	|               RETURN               |                                                                 |
	//	|             VALUE/CODE             |                           DESCRIPTION                           |
	//	|                                    |                                                                 |
	//	+------------------------------------+-----------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwOnlineFlags parameter is not one of the specified values. |
	//	+------------------------------------+-----------------------------------------------------------------+
	OnlineGroupEx(context.Context, *OnlineGroupExRequest, ...dcerpc.CallOption) (*OnlineGroupExResponse, error)

	// (Protocol Version 3) The ApiOfflineGroupEx method SHOULD<113> instruct the server
	// to make all the resources in the designated group inactive or unavailable on the
	// node that is hosting the group.
	//
	// Return Values: This method MUST return the same error codes as specified for ApiOfflineGroup
	// (section 3.1.4.2.51).
	OfflineGroupEx(context.Context, *OfflineGroupExRequest, ...dcerpc.CallOption) (*OfflineGroupExResponse, error)

	// (Protocol Version 3) The ApiMoveGroupEx method SHOULD<114> instruct the server to
	// move ownership of the specified group to another node in the cluster.
	//
	// Return Values: This method MUST return the same error codes as specified for ApiMoveGroup
	// (section 3.1.4.2.52), in addition to the following return value.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client included both the CLUSAPI_GROUP_MOVE_IGNORE_RESOURCE_STATUS and       |
	//	|                                    | CLUSAPI_GROUP_MOVE_QUEUE_ENABLED flags in the dwMoveFlags parameter.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	MoveGroupEx(context.Context, *MoveGroupExRequest, ...dcerpc.CallOption) (*MoveGroupExResponse, error)

	// (Protocol Version 3) The ApiMoveGroupToNodeEx method SHOULD<116> instructs the server
	// to move ownership of a group to the specified node in the cluster.
	//
	// Return Values: This method MUST return the same error codes as specified for ApiMoveGroupToNode
	// (section 3.1.4.2.53) and ApiMoveGroupEx (section 3.1.4.2.131).
	MoveGroupToNodeEx(context.Context, *MoveGroupToNodeExRequest, ...dcerpc.CallOption) (*MoveGroupToNodeExResponse, error)

	// (Protocol Version 3) The ApiCancelClusterGroupOperation SHOULD<117>allow a client
	// to cancel a pending group move operation.
	//
	// Return Values: This method MUST return one of the following values.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS           | The method completed successfully.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwCancelFlags parameter is not set to 0.                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE    | The hGroup parameter does not represent a valid HGROUP_RPC context handle.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000003E5 ERROR_IO_PENDING        | The server has accepted the request and will process it asynchronously.          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000139F ERROR_INVALID_STATE     | The specified group is not moving or the group move operation is no longer       |
	//	|                                    | cancellable.                                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST treat all values that are not listed
	// in the preceding table identically. However, the client SHOULD treat errors specified
	// in section 3.2.4.6 as recoverable errors and initiate the reconnect procedure as
	// specified in section 3.2.4.6.
	CancelClusterGroupOperation(context.Context, *CancelClusterGroupOperationRequest, ...dcerpc.CallOption) (*CancelClusterGroupOperationResponse, error)

	// (Protocol Version 3) The ApiOnlineResourceEx method SHOULD<118> instruct the server
	// to make the specified resource active or available on the node that currently owns
	// it.
	//
	// Return Values: This method MUST return the same error codes as returned by the ApiOnlineResource
	// (section 3.1.4.2.18) method, in addition to the following return value.
	//
	//	+------------------------------------+-----------------------------------------------------------------+
	//	|               RETURN               |                                                                 |
	//	|             VALUE/CODE             |                           DESCRIPTION                           |
	//	|                                    |                                                                 |
	//	+------------------------------------+-----------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwOnlineFlags parameter is not one of the specified values. |
	//	+------------------------------------+-----------------------------------------------------------------+
	OnlineResourceEx(context.Context, *OnlineResourceExRequest, ...dcerpc.CallOption) (*OnlineResourceExResponse, error)

	// (Protocol Version 3) The ApiOfflineResourceEx SHOULD<121> instruct the server to
	// make the designated resource inactive or unavailable on the node that currently owns
	// it.
	//
	// Return Values: This method MUST return the same error codes returned by the ApiOfflineResource
	// (section 3.1.4.2.19) method, in addition to the following return value.
	//
	//	+------------------------------------+------------------------------------------------------------------+
	//	|               RETURN               |                                                                  |
	//	|             VALUE/CODE             |                           DESCRIPTION                            |
	//	|                                    |                                                                  |
	//	+------------------------------------+------------------------------------------------------------------+
	//	+------------------------------------+------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwOfflineFlags parameter is not one of the specified values. |
	//	+------------------------------------+------------------------------------------------------------------+
	OfflineResourceEx(context.Context, *OfflineResourceExRequest, ...dcerpc.CallOption) (*OfflineResourceExResponse, error)

	// (Protocol Version 3) The ApiCreateNotifyV2 method uses the current RPC connection
	// to establish a context on the server about the interaction of a client with a cluster
	// version 2 notification port.
	//
	// Return Values: The method MUST return a valid HNOTIFY_RPC context handle, as specified
	// in section 2.2.1.6, to indicate success. Otherwise, it MUST return NULL.
	CreateNotifyV2(context.Context, *CreateNotifyV2Request, ...dcerpc.CallOption) (*CreateNotifyV2Response, error)

	// (Protocol Version 3) The ApiAddNotifyV2 method SHOULD<123> register for notifications
	// for the object and type specified on an HNOTIFY_RPC context handle previously returned
	// by a call to ApiCreateNotifyV2 (section 3.1.4.2.136). Clients can use this method
	// to register for multiple notifications for a given object in a single call. However,
	// clients MUST call this method for every object for which it needs to receive notifications.
	//
	// Clients MUST only call this method with an HNOTIFY_RPC handle returned by the ApiCreateNotifyV2
	// (section 3.1.4.2.136) method. The server MUST use the root key of the cluster registry
	// as the key for which state and configuration changes are monitored if the object
	// type specified in the filter parameter is CLUSTER_OBJECT_TYPE_REGISTRY.
	//
	// If the filter includes the CLUSTER_CHANGE_REGISTRY_SUBTREE_V2 value, the server MUST
	// extend the scope of monitoring to include all subkeys, all subkey security descriptors,
	// and all values under the root key. The server MUST also report changes under the
	// specified key and all subkeys.
	//
	// The server SHOULD accept an ApiAddNotifyV2 request if its protocol server state is
	// read-only and MUST accept the request if its state is read/write, as specified in
	// section 3.1.1.
	//
	// The server SHOULD accept an ApiAddNotifyV2 request if the client's access level is
	// at least "Read" (section 3.1.4).
	//
	// Return Values: This method MUST return one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS           | The method completed successfully.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE    | Either the hNotify parameter does not represent a valid HNOTIFY_RPC context      |
	//	|                                    | handle, or the hObject parameter does not represent a valid HGENERIC_RPC context |
	//	|                                    | handle, or both.                                                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | Any of the following conditions: The filter parameter contains invalid flags.    |
	//	|                                    | The filter parameter specifies an invalid object type. The dwVersion parameter   |
	//	|                                    | contains an invalid value.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the above table. The client MUST treat all values that are not listed in
	// the preceding table identically, except for recoverable errors specified in section
	// 3.2.4.6, for which the client SHOULD initiate the reconnect procedure.
	AddNotifyV2(context.Context, *AddNotifyV2Request, ...dcerpc.CallOption) (*AddNotifyV2Response, error)

	// (Protocol Version 3) The ApiGetNotifyV2 method is an asynchronous RPC method that
	// SHOULD<124> instruct the server to return a set of queued events from a designated
	// version 2 notification port corresponding to a particular context handle. The server
	// MUST NOT complete this method until an indication has been queued to the port or
	// the port has been closed through a separate call to the ApiUnblockGetNotifyCall (section
	// 3.1.4.2.107) or ApiCloseNotify (section 3.1.4.2.57) method.
	//
	// Return Values: This method MUST return the following error codes for the following
	// conditions.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS          | The method completed successfully.                                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE   | The data that is pointed to by the hNotify parameter does not represent a valid  |
	//	|                                   | HNOTIFY_RPC context handle.                                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS    | The notification port represented by the hNotify parameter has been closed.      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 ERROR_INVALID_FUNCTION | Either the ApiUnblockGetNotifyCall (section 3.1.4.2.107) method or the           |
	//	|                                   | ApiCloseNotify (section 3.1.4.2.57) method has been called in another thread.    |
	//	|                                   | The client SHOULD terminate the notification thread.                             |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST treat all such values identically,
	// with the exception of errors specified in section 3.2.4.6, which are recoverable
	// and for which the client SHOULD initiate the reconnect procedure.
	GetNotifyV2(context.Context, *GetNotifyV2Request, ...dcerpc.CallOption) (*GetNotifyV2Response, error)

	// Opnum140NotUsedOnWire operation.
	// Opnum140NotUsedOnWire

	// Opnum141NotUsedOnWire operation.
	// Opnum141NotUsedOnWire

	// Opnum142NotUsedOnWire operation.
	// Opnum142NotUsedOnWire

	// (Protocol Version 3) The ApiCreateGroupEnum method SHOULD<126> return an enumeration
	// of groups from the current set of groups in the cluster.
	//
	// Return Values: This method MUST return the following values for the following conditions.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS           | The method completed successfully.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client specified a property name in the pProperties or pRoProperties         |
	//	|                                    | parameters that is not the name of a group common or private property,           |
	//	|                                    | respectively.                                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. Clients MUST treat all such values identically, with
	// the exception of errors specified in section 3.2.4.6, which are recoverable errors
	// for which the client SHOULD initiate the reconnect procedure.
	CreateGroupEnum(context.Context, *CreateGroupEnumRequest, ...dcerpc.CallOption) (*CreateGroupEnumResponse, error)

	// (Protocol Version 3) The ApiCreateResourceEnum method SHOULD<127> return an enumeration
	// of resources from the current set of resources in the cluster.
	//
	// Return Values: This method MUST return the following values for the following conditions.
	//
	//	+--------------------------+------------------------------------+
	//	|          RETURN          |                                    |
	//	|        VALUE/CODE        |            DESCRIPTION             |
	//	|                          |                                    |
	//	+--------------------------+------------------------------------+
	//	+--------------------------+------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The method completed successfully. |
	//	+--------------------------+------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. Clients MUST treat all such values identically, with
	// the exception of errors specified in section 3.2.4.6, which are recoverable errors
	// for which the client SHOULD initiate the reconnect procedure.
	CreateResourceEnum(context.Context, *CreateResourceEnumRequest, ...dcerpc.CallOption) (*CreateResourceEnumResponse, error)

	// ApiExecuteReadBatch operation.
	ExecuteReadBatch(context.Context, *ExecuteReadBatchRequest, ...dcerpc.CallOption) (*ExecuteReadBatchResponse, error)

	// The ApiRestartResource method SHOULD<129> instruct the server to restart a resource
	// without affecting the resource's persistent state. The server SHOULD bring the resource
	// offline, then bring the resource back to its persistent state.
	//
	// Return Values: This method MUST return ERROR_SUCCESS (0x00000000) on success, or
	// a different value for any other condition. Clients MUST treat all values other than
	// ERROR_SUCCESS identically, except for recoverable errors as specified in section
	// 3.2.4.6, for which the client MUST initiate the reconnect procedure.
	RestartResource(context.Context, *RestartResourceRequest, ...dcerpc.CallOption) (*RestartResourceResponse, error)

	// (Protocol Version 3) The ApiGetNotifyAsync method is an asynchronous RPC method that
	// SHOULD<130> be used instead of ApiGetNotify to instruct the server to return the
	// next set of queued events corresponding to a particular context handle. The server
	// MUST NOT complete this method until an indication has been queued to the port or
	// the port has been closed through a separate call to the ApiUnblockGetNotifyCall or
	// ApiCloseNotify method.
	//
	// Return Values: This method MUST return one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS          | The method completed successfully.                                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE   | The data that is pointed to by the hNotify parameter does not represent a valid  |
	//	|                                   | HNOTIFY_RPC context handle.                                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS    | The notification port represented by the hNotify parameter has been closed.      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 ERROR_INVALID_FUNCTION | Either the ApiUnblockGetNotifyCall (section 3.1.4.2.107) method or the           |
	//	|                                   | ApiCloseNotify (section 3.1.4.2.57) method has been called in another thread.    |
	//	|                                   | The client SHOULD terminate the notification thread.                             |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// For any other condition, the server returns a value that is not one of the values
	// listed in the preceding table. The client MUST treat all such values identically,
	// with the exception of errors specified in section 3.2.4.6, which are recoverable
	// and for which the client SHOULD initiate the reconnect procedure.
	GetNotifyAsync(context.Context, *GetNotifyAsyncRequest, ...dcerpc.CallOption) (*GetNotifyAsyncResponse, error)

	// Opnum148NotUsedOnWire operation.
	// Opnum148NotUsedOnWire

	// Opnum149otUsedOnWire operation.
	Opnum149otUsedOnWire(context.Context, *Opnum149otUsedOnWireRequest, ...dcerpc.CallOption) (*Opnum149otUsedOnWireResponse, error)

	// Opnum150NotUsedOnWire operation.
	// Opnum150NotUsedOnWire

	// Opnum151NotUsedOnWire operation.
	// Opnum151NotUsedOnWire

	// Opnum152NotUsedOnWire operation.
	// Opnum152NotUsedOnWire

	// Opnum153NotUsedOnWire operation.
	// Opnum153NotUsedOnWire

	// Opnum154NotUsedOnWire operation.
	// Opnum154NotUsedOnWire

	// ApiAddNotifyResourceTypeV2 operation.
	AddNotifyResourceTypeV2(context.Context, *AddNotifyResourceTypeV2Request, ...dcerpc.CallOption) (*AddNotifyResourceTypeV2Response, error)

	// Opnum156NotUsedOnWire operation.
	// Opnum156NotUsedOnWire

	// ApiExecuteReadBatchEx operation.
	ExecuteReadBatchEx(context.Context, *ExecuteReadBatchExRequest, ...dcerpc.CallOption) (*ExecuteReadBatchExResponse, error)

	// Opnum158NotUsedOnWire operation.
	// Opnum158NotUsedOnWire

	// Opnum159NotUsedOnWire operation.
	// Opnum159NotUsedOnWire

	// Opnum160NotUsedOnWire operation.
	// Opnum160NotUsedOnWire

	// Opnum161NotUsedOnWire operation.
	// Opnum161NotUsedOnWire

	// Opnum162NotUsedOnWire operation.
	// Opnum162NotUsedOnWire

	// ApiCreateGroupSet operation.
	CreateGroupSet(context.Context, *CreateGroupSetRequest, ...dcerpc.CallOption) (*CreateGroupSetResponse, error)

	// ApiOpenGroupSet operation.
	OpenGroupSet(context.Context, *OpenGroupSetRequest, ...dcerpc.CallOption) (*OpenGroupSetResponse, error)

	// ApiCloseGroupSet operation.
	CloseGroupSet(context.Context, *CloseGroupSetRequest, ...dcerpc.CallOption) (*CloseGroupSetResponse, error)

	// ApiDeleteGroupSet operation.
	DeleteGroupSet(context.Context, *DeleteGroupSetRequest, ...dcerpc.CallOption) (*DeleteGroupSetResponse, error)

	// ApiAddGroupToGroupSet operation.
	AddGroupToGroupSet(context.Context, *AddGroupToGroupSetRequest, ...dcerpc.CallOption) (*AddGroupToGroupSetResponse, error)

	// ApiRemoveGroupFromGroupSet operation.
	RemoveGroupFromGroupSet(context.Context, *RemoveGroupFromGroupSetRequest, ...dcerpc.CallOption) (*RemoveGroupFromGroupSetResponse, error)

	// ApiMoveGroupToGroupSet operation.
	MoveGroupToGroupSet(context.Context, *MoveGroupToGroupSetRequest, ...dcerpc.CallOption) (*MoveGroupToGroupSetResponse, error)

	// Opnum170NotUsedOnWire operation.
	// Opnum170NotUsedOnWire

	// ApiAddGroupSetDependency operation.
	AddGroupSetDependency(context.Context, *AddGroupSetDependencyRequest, ...dcerpc.CallOption) (*AddGroupSetDependencyResponse, error)

	// ApiAddGroupToGroupSetDependency operation.
	AddGroupToGroupSetDependency(context.Context, *AddGroupToGroupSetDependencyRequest, ...dcerpc.CallOption) (*AddGroupToGroupSetDependencyResponse, error)

	// ApiNodeGroupSetControl operation.
	NodeGroupSetControl(context.Context, *NodeGroupSetControlRequest, ...dcerpc.CallOption) (*NodeGroupSetControlResponse, error)

	// ApiGroupSetControl operation.
	GroupSetControl(context.Context, *GroupSetControlRequest, ...dcerpc.CallOption) (*GroupSetControlResponse, error)

	// ApiSetGroupDependencyExpression operation.
	SetGroupDependencyExpression(context.Context, *SetGroupDependencyExpressionRequest, ...dcerpc.CallOption) (*SetGroupDependencyExpressionResponse, error)

	// ApiRemoveClusterGroupDependency operation.
	RemoveClusterGroupDependency(context.Context, *RemoveClusterGroupDependencyRequest, ...dcerpc.CallOption) (*RemoveClusterGroupDependencyResponse, error)

	// ApiSetGroupSetDependencyExpression operation.
	SetGroupSetDependencyExpression(context.Context, *SetGroupSetDependencyExpressionRequest, ...dcerpc.CallOption) (*SetGroupSetDependencyExpressionResponse, error)

	// ApiRemoveGroupSetDependency operation.
	RemoveGroupSetDependency(context.Context, *RemoveGroupSetDependencyRequest, ...dcerpc.CallOption) (*RemoveGroupSetDependencyResponse, error)

	// ApiRemoveClusterGroupToGroupSetDependency operation.
	RemoveClusterGroupToGroupSetDependency(context.Context, *RemoveClusterGroupToGroupSetDependencyRequest, ...dcerpc.CallOption) (*RemoveClusterGroupToGroupSetDependencyResponse, error)

	// ApiCreateGroupSetEnum operation.
	CreateGroupSetEnum(context.Context, *CreateGroupSetEnumRequest, ...dcerpc.CallOption) (*CreateGroupSetEnumResponse, error)

	// ApiCreateNetInterfaceEnum operation.
	CreateNetInterfaceEnum(context.Context, *CreateNetInterfaceEnumRequest, ...dcerpc.CallOption) (*CreateNetInterfaceEnumResponse, error)

	// ApiChangeCsvStateEx operation.
	ChangeCSVStateEx(context.Context, *ChangeCSVStateExRequest, ...dcerpc.CallOption) (*ChangeCSVStateExResponse, error)

	// ApiAddGroupToGroupSetEx operation.
	AddGroupToGroupSetEx(context.Context, *AddGroupToGroupSetExRequest, ...dcerpc.CallOption) (*AddGroupToGroupSetExResponse, error)

	// ApiChangeResourceGroupEx operation.
	ChangeResourceGroupEx(context.Context, *ChangeResourceGroupExRequest, ...dcerpc.CallOption) (*ChangeResourceGroupExResponse, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error
}

// MaxClusterControlCodeBufferSize represents the MAX_CLUSTER_CONTROL_CODE_BUFFER_SIZE RPC constant
var MaxClusterControlCodeBufferSize = 2147483647

// GroupSet structure represents HGROUPSET_RPC RPC structure.
type GroupSet dcetypes.ContextHandle

func (o *GroupSet) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *GroupSet) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupSet) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupSet) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Cluster structure represents HCLUSTER_RPC RPC structure.
type Cluster dcetypes.ContextHandle

func (o *Cluster) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Cluster) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Cluster) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Cluster) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Node structure represents HNODE_RPC RPC structure.
type Node dcetypes.ContextHandle

func (o *Node) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Node) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Node) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Node) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Group structure represents HGROUP_RPC RPC structure.
type Group dcetypes.ContextHandle

func (o *Group) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Group) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Group) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Group) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Resource structure represents HRES_RPC RPC structure.
type Resource dcetypes.ContextHandle

func (o *Resource) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Resource) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Resource) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Resource) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Key structure represents HKEY_RPC RPC structure.
type Key dcetypes.ContextHandle

func (o *Key) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Key) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Key) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Key) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Notify structure represents HNOTIFY_RPC RPC structure.
type Notify dcetypes.ContextHandle

func (o *Notify) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Notify) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Notify) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Notify) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Network structure represents HNETWORK_RPC RPC structure.
type Network dcetypes.ContextHandle

func (o *Network) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Network) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Network) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Network) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// NetInterface structure represents HNETINTERFACE_RPC RPC structure.
type NetInterface dcetypes.ContextHandle

func (o *NetInterface) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *NetInterface) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// BatchPort structure represents HBATCH_PORT_RPC RPC structure.
type BatchPort dcetypes.ContextHandle

func (o *BatchPort) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *BatchPort) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *BatchPort) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *BatchPort) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SecurityDescriptor structure represents RPC_SECURITY_DESCRIPTOR RPC structure.
//
// The RPC_SECURITY_DESCRIPTOR structure is a container for passing a security descriptor
// that can be marshaled and unmarshaled by RPC. In this protocol it is part of the
// RPC_SECURITY_ATTRIBUTES structure (section 2.2.3.2).
type SecurityDescriptor struct {
	// lpSecurityDescriptor: A variable-length buffer that contains a security descriptor
	// in self-relative form.
	SecurityDescriptor []byte `idl:"name:lpSecurityDescriptor;size_is:(cbInSecurityDescriptor);length_is:(cbOutSecurityDescriptor)" json:"security_descriptor"`
	// cbInSecurityDescriptor: The size, in bytes, of memory that is allocated for the security
	// descriptor. If no security descriptor is specified, this field MUST be zero.
	InSecurityDescriptorLength uint32 `idl:"name:cbInSecurityDescriptor" json:"in_security_descriptor_length"`
	// cbOutSecurityDescriptor: The number of bytes of the lpSecurityDescriptor to be transmitted.
	// If no security descriptor is specified, this field MUST be zero.
	OutSecurityDescriptorLength uint32 `idl:"name:cbOutSecurityDescriptor" json:"out_security_descriptor_length"`
}

func (o *SecurityDescriptor) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.InSecurityDescriptorLength == 0 {
		o.InSecurityDescriptorLength = uint32(len(o.SecurityDescriptor))
	}
	if o.SecurityDescriptor != nil && o.OutSecurityDescriptorLength == 0 {
		o.OutSecurityDescriptorLength = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityDescriptor) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.InSecurityDescriptorLength > 0 {
		_ptr_lpSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.InSecurityDescriptorLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64(o.OutSecurityDescriptorLength)
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_lpSecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.InSecurityDescriptorLength); err != nil {
		return err
	}
	if err := w.WriteData(o.OutSecurityDescriptorLength); err != nil {
		return err
	}
	return nil
}
func (o *SecurityDescriptor) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_lpSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_lpSecurityDescriptor, _ptr_lpSecurityDescriptor); err != nil {
		return err
	}
	if err := w.ReadData(&o.InSecurityDescriptorLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutSecurityDescriptorLength); err != nil {
		return err
	}
	return nil
}

// SecurityAttributes structure represents RPC_SECURITY_ATTRIBUTES RPC structure.
//
// The RPC_SECURITY_ATTRIBUTES structure represents security attributes that can be
// marshaled and unmarshaled by RPC.
//
// The RPC_SECURITY_ATTRIBUTES is used by a client to indicate the security attributes
// that are assigned when creating a new cluster registry key, as specified in section
// 3.1.4.2.30.
type SecurityAttributes struct {
	// nLength: The length of the structure, in bytes.
	Length uint32 `idl:"name:nLength" json:"length"`
	// RpcSecurityDescriptor: A self-relative security descriptor that can be marshaled
	// and unmarshaled by RPC, as specified in section 2.2.3.1.
	SecurityDescriptor *SecurityDescriptor `idl:"name:RpcSecurityDescriptor" json:"security_descriptor"`
	// bInheritHandle: Any nonzero value if a new spawned process inherits the handle; however,
	// because cluster registry keys are not inheritable, this field MUST be set to zero
	// for use in ApiCreateKey (section 3.1.4.2.30).
	InheritHandle int32 `idl:"name:bInheritHandle" json:"inherit_handle"`
}

func (o *SecurityAttributes) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityAttributes) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil {
		if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.InheritHandle); err != nil {
		return err
	}
	return nil
}
func (o *SecurityAttributes) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if o.SecurityDescriptor == nil {
		o.SecurityDescriptor = &SecurityDescriptor{}
	}
	if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.InheritHandle); err != nil {
		return err
	}
	return nil
}

// ClusterOperationalVersionInfo structure represents CLUSTER_OPERATIONAL_VERSION_INFO RPC structure.
//
// The CLUSTER_OPERATIONAL_VERSION_INFO structure contains information about the versions
// of cluster software with which all nodes in the cluster are compatible.
type ClusterOperationalVersionInfo struct {
	// dwSize: The size, in bytes, of this structure. MUST be set to 20 bytes.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// dwClusterHighestVersion: The highest version of cluster software with which all nodes
	// in the cluster are compatible. The upper 2 bytes of dwClusterHighestVersion identify
	// the cluster software internal major version number, and the lower 2 bytes identify
	// the cluster software internal minor version number. Note that the internal version
	// and build numbers are not necessarily identical to the operating system version and
	// build numbers. The dwClusterHighestVersion member SHOULD<23> be set to one of the
	// following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000100e0 | One or more nodes support an internal version that is no higher than 0x0001 with |
	//	|            | internal build number 0x00e0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000200e0 | One or more nodes support an internal version that is no higher than 0x0002 with |
	//	|            | internal build number 0x00e0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00030893 | One or more nodes support an internal version that is no higher than 0x0003 with |
	//	|            | internal build number 0x0893.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00040ECE | One or more nodes support an internal version that is no higher than 0x0004 with |
	//	|            | internal build number 0x0ECE.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00051771 | One or more nodes support an internal version that is no higher than 0x0005 with |
	//	|            | internal build number 0x1771.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00061DB0 | One or more nodes support an internal version that is no higher than 0x0006 with |
	//	|            | internal build number 0x1DB0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00061DB1 | One or more nodes support an internal version that is no higher than 0x0006 with |
	//	|            | internal build number 0x1DB1.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000723F0 | One or more nodes support an internal version that is no higher than 0x0007 with |
	//	|            | internal build number 0x23F0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00082580 | One or more nodes support an internal version that is no higher than 0x0008 with |
	//	|            | internal build number 0x2580.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00090003 | One or more nodes support an internal version that is no higher than 0x0009 with |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0001 | One or more nodes support an internal version that is no higher than 0x000a with |
	//	|            | internal build number 0x0001.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0002 | One or more nodes support an internal version that is no higher than 0x000a with |
	//	|            | internal build number 0x0002.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0003 | One or more nodes support an internal version that is no higher than 0x000a with |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000b0003 | One or more nodes support an internal version that is no higher than 0x000b with |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000c0004 | One or more nodes support an internal version that is no higher than 0x000c with |
	//	|            | internal build number 0x0004.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	ClusterHighestVersion uint32 `idl:"name:dwClusterHighestVersion" json:"cluster_highest_version"`
	// dwClusterLowestVersion: The lowest version of cluster software with which all nodes
	// in the cluster are compatible. The upper 2 bytes of dwClusterLowestVersion identify
	// the cluster software internal major version number, and the lower 2 bytes of dwClusterLowestVersion
	// identify the cluster software internal minor version number. The dwClusterLowestVersion
	// member SHOULD<24> be set to one of the following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000100e0 | One or more nodes support an internal version that is no lower than 0x0001 with  |
	//	|            | internal build number 0x00e0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000200e0 | One or more nodes support an internal version that is no lower than 0x0002 with  |
	//	|            | internal build number 0x00e0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00030893 | One or more nodes support an internal version that is no lower than 0x0003 with  |
	//	|            | internal build number 0x0893.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00040ECE | One or more nodes support an internal version that is no lower than 0x0004 with  |
	//	|            | internal build number 0x0ECE.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00051771 | One or more nodes support an internal version that is no lower than 0x0005 with  |
	//	|            | internal build number 0x1771.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00061DB0 | One or more nodes support an internal version that is no lower than 0x0006 with  |
	//	|            | internal build number 0x1DB0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00061DB1 | One or more nodes support an internal version that is no lower than 0x0003 with  |
	//	|            | internal build number 0x1DB1.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000723F0 | One or more nodes support an internal version that is no lower than 0x0007 with  |
	//	|            | internal build number 0x23F0.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00082580 | One or more nodes support an internal version that is no lower than 0x0008 with  |
	//	|            | internal build number 0x2580.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00090003 | One or more nodes support an internal version that is no lower than 0x0009 with  |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0001 | One or more nodes support an internal version that is no lower than 0x000a with  |
	//	|            | internal build number 0x0001.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0002 | One or more nodes support an internal version that is no lower than 0x000a with  |
	//	|            | internal build number 0x0002.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000a0003 | One or more nodes support an internal version that is no higher than 0x000a with |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000b0003 | One or more nodes support an internal version that is no lower than 0x000b with  |
	//	|            | internal build number 0x0003.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x000c0004 | One or more nodes support an internal version that is no lower than 0x000c with  |
	//	|            | internal build number 0x0004.                                                    |
	//	+------------+----------------------------------------------------------------------------------+
	ClusterLowestVersion uint32 `idl:"name:dwClusterLowestVersion" json:"cluster_lowest_version"`
	// dwFlags:  The flags that identify the characteristics of the cluster operational
	// version. The dwFlags member MUST be set to one of the following values.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|                   VALUE                    |                                     MEANING                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                                 | All nodes in the cluster are running the same version of the cluster software.   |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_VERSION_FLAG_MIXED_MODE 0x00000001 | The cluster is configured with nodes that are running different versions of the  |
	//	|                                            | cluster software.                                                                |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// dwReserved: Reserved. MUST be set to 0 and ignored by the client.
	_ uint32 `idl:"name:dwReserved"`
}

func (o *ClusterOperationalVersionInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ClusterOperationalVersionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.ClusterHighestVersion); err != nil {
		return err
	}
	if err := w.WriteData(o.ClusterLowestVersion); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *ClusterOperationalVersionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.ClusterHighestVersion); err != nil {
		return err
	}
	if err := w.ReadData(&o.ClusterLowestVersion); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	return nil
}

// ClusterSetPasswordStatus structure represents IDL_CLUSTER_SET_PASSWORD_STATUS RPC structure.
//
// The IDL_CLUSTER_SET_PASSWORD_STATUS structure contains information about the results
// of a service account password change, as specified in section 3.1.4.2.108, on a particular
// node in the cluster.
type ClusterSetPasswordStatus struct {
	// NodeId: A 32-bit integer containing the ID of a configured node in the cluster.
	NodeID uint32 `idl:"name:NodeId" json:"node_id"`
	// SetAttempted: A Boolean where TRUE indicates that the password change was attempted
	// on this node; any other value indicates that no attempt was made.
	SetAttempted bool `idl:"name:SetAttempted" json:"set_attempted"`
	// ReturnStatus: The Win32 error code associated with the attempt. This field MUST be
	// ignored if the SetAttempted field is FALSE.
	ReturnStatus uint32 `idl:"name:ReturnStatus" json:"return_status"`
}

func (o *ClusterSetPasswordStatus) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ClusterSetPasswordStatus) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.NodeID); err != nil {
		return err
	}
	if err := w.WriteData(o.SetAttempted); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnStatus); err != nil {
		return err
	}
	return nil
}
func (o *ClusterSetPasswordStatus) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.NodeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.SetAttempted); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnStatus); err != nil {
		return err
	}
	return nil
}

// ClusterSetPasswordFlags type represents IDL_CLUSTER_SET_PASSWORD_FLAGS RPC enumeration.
//
// The IDL_CLUSTER_SET_PASSWORD_FLAGS enumeration defines the possible values for the
// dwFlags parameter of the method ApiSetServiceAccountPassword (section 3.1.4.1.108).
// The valid constant values are as follows. All other values are reserved.
type ClusterSetPasswordFlags uint16

var (
	// IDL_CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES:  Indicates to the server to proceed
	// with the password change operation even if there are nodes configured in the cluster
	// that are currently in the ClusterNodeUp state, as specified in section 3.1.4.1.69.
	ClusterSetPasswordFlagsIgnoreDownNodes ClusterSetPasswordFlags = 1
)

func (o ClusterSetPasswordFlags) String() string {
	switch o {
	case ClusterSetPasswordFlagsIgnoreDownNodes:
		return "ClusterSetPasswordFlagsIgnoreDownNodes"
	}
	return "Invalid"
}

// ClusterCreateGroupInfoRPC structure represents CLUSTER_CREATE_GROUP_INFO_RPC RPC structure.
//
// The CLUSTER_CREATE_GROUP_INFO_RPC structure contains information about the creation
// of a group, as specified in ApiCreateGroupEx (section 3.1.4.2.128).<26>
type ClusterCreateGroupInfoRPC struct {
	// dwVersion: The version of the CLUSTER_CREATE_GROUP_INFO_RPC data structure.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwGroupType: Designates the type of group.
	GroupType uint32 `idl:"name:dwGroupType" json:"group_type"`
}

func (o *ClusterCreateGroupInfoRPC) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ClusterCreateGroupInfoRPC) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupType); err != nil {
		return err
	}
	return nil
}
func (o *ClusterCreateGroupInfoRPC) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupType); err != nil {
		return err
	}
	return nil
}

// EnumEntry structure represents ENUM_ENTRY RPC structure.
//
// The ENUM_ENTRY structure contains information about a single element in an ENUM_LIST
// (section 2.2.3.5). An ENUM_ENTRY contains the name of a cluster object.
type EnumEntry struct {
	// Type: Specifies the type of the object that is represented by the list element. This
	// member MUST be set to one of the following values.
	//
	// If the ENUM_LIST is returned by a call to ApiCreateEnum (section 3.1.4.2.8) or ApiCreateEnumEx
	// (section 3.1.4.2.124), Type is set to one of the following values.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                |                                                                                  |
	//	|                     VALUE                      |                                     MEANING                                      |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NODE 0x00000001                   | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name     |
	//	|                                                | of a cluster node. If returned by ApiCreateEnumEx, this ENUM_ENTRY list element  |
	//	|                                                | contains the name or ID, as specified in ApiCreateEnumEx, of a cluster node.     |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_RESTYPE 0x00000002                | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name of  |
	//	|                                                | a cluster resource type. If returned by ApiCreateEnumEx, this ENUM_ENTRY list    |
	//	|                                                | element contains the name or ID, as specified in ApiCreateEnumEx, of a cluster   |
	//	|                                                | resource type.                                                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_RESOURCE 0x00000004               | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name of  |
	//	|                                                | a cluster resource. If returned by ApiCreateEnumEx, this ENUM_ENTRY list element |
	//	|                                                | contains the name or ID, as specified in ApiCreateEnumEx, of a cluster resource. |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_GROUP 0x00000008                  | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name of  |
	//	|                                                | a cluster group. If returned by ApiCreateEnumEx, this ENUM_ENTRY list element    |
	//	|                                                | contains the name or ID, as specified in ApiCreateEnumEx, of a cluster group.    |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NETWORK 0x00000010                | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name of  |
	//	|                                                | a cluster network. If returned by ApiCreateEnumEx, this ENUM_ENTRY list element  |
	//	|                                                | contains the name or ID, as specified in ApiCreateEnumEx, of a cluster network.  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NETINTERFACE 0x00000020           | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name     |
	//	|                                                | of a cluster network interface. If returned by ApiCreateEnumEx, this ENUM_ENTRY  |
	//	|                                                | list element contains the name or ID, as specified in ApiCreateEnumEx, of a      |
	//	|                                                | cluster network interface.                                                       |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_SHARED_VOLUME_RESOURCE 0x40000000 | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name of  |
	//	|                                                | a cluster shared volume. If returned by ApiCreateEnumEx, this ENUM_ENTRY list    |
	//	|                                                | element contains the name or ID, as specified in ApiCreateEnumEx, of a cluster   |
	//	|                                                | shared volume.                                                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_INTERNAL_NETWORK 0x80000000       | If returned by ApiCreateEnum, this ENUM_ENTRY list element contains the name     |
	//	|                                                | of a cluster network used only for internal cluster communications. If returned  |
	//	|                                                | by ApiCreateEnumEx, this ENUM_ENTRY list element contains the name or ID,        |
	//	|                                                | as specified in ApiCreateEnumEx, of a cluster network used only for internal     |
	//	|                                                | cluster communications.                                                          |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateResEnum (section 3.1.4.2.23),
	// Type is set to one of the following values.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                           |                                                                                  |
	//	|                   VALUE                   |                                     MEANING                                      |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_ENUM_DEPENDS 0x00000001  | This ENUM_ENTRY list element contains the name of a cluster resource that is     |
	//	|                                           | depended upon, as described in Resources (section 3.1.1.1.1) by the resource     |
	//	|                                           | designated in the call to ApiCreateResEnum.                                      |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_ENUM_PROVIDES 0x00000002 | This ENUM_ENTRY list element contains the name of a cluster resource that        |
	//	|                                           | depends upon, as described in Resources by the resource designated in the call   |
	//	|                                           | to ApiCreateResEnum.                                                             |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_ENUM_NODES 0x00000004    | This ENUM_ENTRY list element contains the name of a cluster node that can host   |
	//	|                                           | the resource designated in the call to ApiCreateResEnum.                         |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateGroupResourceEnum (section 3.1.4.2.54),
	// Type is set to one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_GROUP_ENUM_CONTAINS 0x00000001 | This ENUM_ENTRY list element contains the name of a cluster resource that is     |
	//	|                                        | contained in the group designated in the call to ApiCreateGroupResourceEnum.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_GROUP_ENUM_NODES 0x00000002    | This ENUM_ENTRY list element contains the name of a cluster node that can host   |
	//	|                                        | the group designated in the call to ApiCreateGroupResourceEnum.                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateNetworkEnum (section 3.1.4.2.85),
	// Type is set to one of the following values.
	//
	//	+-----------------------------------------------+--------------------------------------------------------------------------------+
	//	|                                               |                                                                                |
	//	|                     VALUE                     |                                    MEANING                                     |
	//	|                                               |                                                                                |
	//	+-----------------------------------------------+--------------------------------------------------------------------------------+
	//	+-----------------------------------------------+--------------------------------------------------------------------------------+
	//	| CLUSTER_NETWORK_ENUM_NETINTERFACES 0x00000001 | This ENUM_ENTRY list element contains the name of a cluster network interface. |
	//	+-----------------------------------------------+--------------------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateNodeEnum (section 3.1.4.2.101)
	// or ApiCreateNodeEnumEx (section 3.1.4.2.123), Type is set to one of the following
	// values.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|                   VALUE                    |                                     MEANING                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_NODE_ENUM_NETINTERFACES 0x00000001 | This ENUM_ENTRY list element contains the name of a cluster network interface.   |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_NODE_ENUM_GROUPS 0x00000002        | If returned by ApiCreateNodeEnum, this ENUM_ENTRY list element contains the      |
	//	|                                            | name of a cluster group. If returned by ApiCreateNodeEnumEx, this ENUM_ENTRY     |
	//	|                                            | list element contains the name or ID, as specified in ApiCreateNodeEnumEx, of a  |
	//	|                                            | cluster group.                                                                   |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateResTypeEnum (section 3.1.4.2.103),
	// Type is set to one of the following values.
	//
	//	+-------------------------------------------------+-----------------------------------------------------------------------+
	//	|                                                 |                                                                       |
	//	|                      VALUE                      |                                MEANING                                |
	//	|                                                 |                                                                       |
	//	+-------------------------------------------------+-----------------------------------------------------------------------+
	//	+-------------------------------------------------+-----------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_TYPE_ENUM_NODES 0x00000001     | This ENUM_ENTRY list element contains the name of a cluster node.     |
	//	+-------------------------------------------------+-----------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_TYPE_ENUM_RESOURCES 0x00000002 | This ENUM_ENTRY list element contains the name of a cluster resource. |
	//	+-------------------------------------------------+-----------------------------------------------------------------------+
	//
	// If the ENUM_LIST is returned by a call to ApiCreateNetInterfaceEnum, as specified
	// in section 3.1.4.2.163, Type is set to one of the following values.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                                      |                                                                                  |
	//	|                VALUE                 |                                     MEANING                                      |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NETINTERFACE 0x00000020 | If returned by ApiCreateNetInterfaceEnum, this ENUM_ENTRY list element contains  |
	//	|                                      | the list of cluster network interfaces.                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	Type uint32 `idl:"name:Type" json:"type"`
	// Name: If the ENUM_LIST is returned by a call to ApiCreateNodeEnumEx, it contains
	// the return data specified in section 3.1.4.2.123.
	//
	// If the ENUM_LIST is returned by a call to ApiCreateEnumEx, it contains the return
	// data specified in section 3.1.4.2.124.
	Name string `idl:"name:Name;string" json:"name"`
}

func (o *EnumEntry) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	return nil
}

// EnumList structure represents ENUM_LIST RPC structure.
//
// The ENUM_LIST structure is a container for a list of ENUM_ENTRY (section 2.2.3.4)
// structures. An ENUM_LIST encapsulates the results of a query that is performed on
// the cluster state. The semantics of the collection of named cluster objects depends
// on the query that is performed. For example, the ApiCreateEnum (section 3.1.4.2.8)
// method can be used to query a list of nodes in the cluster or a list of resources
// in the cluster. The result of either query is returned to the client as an ENUM_LIST.
type EnumList struct {
	// EntryCount: An unsigned 32-bit integer. The number of elements in the field Entry.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// Entry: An array of ENUM_ENTRY structures that represents the contents of the list.
	Entry []*EnumEntry `idl:"name:Entry;size_is:(EntryCount)" json:"entry"`
}

func (o *EnumList) xxx_PreparePayload(ctx context.Context) error {
	if o.Entry != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.Entry))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *EnumList) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntryCount)
	return []uint64{
		dimSize1,
	}
}
func (o *EnumList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	for i1 := range o.Entry {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Entry[i1] != nil {
			if err := o.Entry[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EnumEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Entry); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&EnumEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntryCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntryCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Entry", sizeInfo[0])
	}
	o.Entry = make([]*EnumEntry, sizeInfo[0])
	for i1 := range o.Entry {
		i1 := i1
		if o.Entry[i1] == nil {
			o.Entry[i1] = &EnumEntry{}
		}
		if err := o.Entry[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// GroupEnumEntry structure represents GROUP_ENUM_ENTRY RPC structure.
//
// The GROUP_ENUM_ENTRY structure contains information for each group in the enumeration
// list returned by ApiCreateGroupEnum (section 3.1.4.2.139).
type GroupEnumEntry struct {
	// Name: The name of the group.
	Name string `idl:"name:Name;string" json:"name"`
	// Id: The Id of the group.
	ID string `idl:"name:Id;string" json:"id"`
	// dwState: The state of the group, as specified in section 3.1.4.2.46.
	State uint32 `idl:"name:dwState" json:"state"`
	// Owner: The name of the group's current owner node.
	Owner string `idl:"name:Owner;string" json:"owner"`
	// dwFlags: The group's flags, as would be returned by CLUSCTL_GROUP_GET_FLAGS (section
	// 3.1.4.3.3.3).
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// cbProperties: The size in bytes of the buffer pointed to by the Properties field.
	PropertiesLength uint32 `idl:"name:cbProperties" json:"properties_length"`
	// Properties: A PROPERTY_LIST (section 2.2.3.10) containing common properties of the
	// group.
	Properties []byte `idl:"name:Properties;size_is:(cbProperties)" json:"properties"`
	// cbRoProperties: The size in bytes of the buffer pointed to by the RoProperties field.
	ReadOnlyPropertiesLength uint32 `idl:"name:cbRoProperties" json:"read_only_properties_length"`
	// RoProperties: A PROPERTY_LIST containing read-only common properties of the group.
	ReadOnlyProperties []byte `idl:"name:RoProperties;size_is:(cbRoProperties)" json:"read_only_properties"`
}

func (o *GroupEnumEntry) xxx_PreparePayload(ctx context.Context) error {
	if o.Properties != nil && o.PropertiesLength == 0 {
		o.PropertiesLength = uint32(len(o.Properties))
	}
	if o.ReadOnlyProperties != nil && o.ReadOnlyPropertiesLength == 0 {
		o.ReadOnlyPropertiesLength = uint32(len(o.ReadOnlyProperties))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupEnumEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ID != "" {
		_ptr_Id := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ID, _ptr_Id); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if o.Owner != "" {
		_ptr_Owner := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Owner); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Owner, _ptr_Owner); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.PropertiesLength); err != nil {
		return err
	}
	if o.Properties != nil || o.PropertiesLength > 0 {
		_ptr_Properties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PropertiesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Properties {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Properties[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Properties); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Properties, _ptr_Properties); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ReadOnlyPropertiesLength); err != nil {
		return err
	}
	if o.ReadOnlyProperties != nil || o.ReadOnlyPropertiesLength > 0 {
		_ptr_RoProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ReadOnlyPropertiesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ReadOnlyProperties {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.ReadOnlyProperties[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.ReadOnlyProperties); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReadOnlyProperties, _ptr_RoProperties); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupEnumEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	_ptr_Id := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ID); err != nil {
			return err
		}
		return nil
	})
	_s_Id := func(ptr interface{}) { o.ID = *ptr.(*string) }
	if err := w.ReadPointer(&o.ID, _s_Id, _ptr_Id); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	_ptr_Owner := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Owner); err != nil {
			return err
		}
		return nil
	})
	_s_Owner := func(ptr interface{}) { o.Owner = *ptr.(*string) }
	if err := w.ReadPointer(&o.Owner, _s_Owner, _ptr_Owner); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.PropertiesLength); err != nil {
		return err
	}
	_ptr_Properties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PropertiesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PropertiesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Properties", sizeInfo[0])
		}
		o.Properties = make([]byte, sizeInfo[0])
		for i1 := range o.Properties {
			i1 := i1
			if err := w.ReadData(&o.Properties[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Properties := func(ptr interface{}) { o.Properties = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Properties, _s_Properties, _ptr_Properties); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReadOnlyPropertiesLength); err != nil {
		return err
	}
	_ptr_RoProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ReadOnlyPropertiesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ReadOnlyPropertiesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ReadOnlyProperties", sizeInfo[0])
		}
		o.ReadOnlyProperties = make([]byte, sizeInfo[0])
		for i1 := range o.ReadOnlyProperties {
			i1 := i1
			if err := w.ReadData(&o.ReadOnlyProperties[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_RoProperties := func(ptr interface{}) { o.ReadOnlyProperties = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.ReadOnlyProperties, _s_RoProperties, _ptr_RoProperties); err != nil {
		return err
	}
	return nil
}

// ResourceEnumEntry structure represents RESOURCE_ENUM_ENTRY RPC structure.
//
// The RESOURCE_ENUM_ENTRY (section 2.2.3.27) structure represents information for each
// resource in the enumeration list returned by ApiCreateResourceEnum (section 3.1.4.2.140).
type ResourceEnumEntry struct {
	// Name: The name of the resource.
	Name string `idl:"name:Name;string" json:"name"`
	// Id: The Id of the resource.
	ID string `idl:"name:Id;string" json:"id"`
	// OwnerName: The name of the group that contains this resource.
	OwnerName string `idl:"name:OwnerName;string" json:"owner_name"`
	// OwnerId: The Id of the group that contains this resource.
	OwnerID string `idl:"name:OwnerId;string" json:"owner_id"`
	// cbProperties: The size in bytes of the buffer pointed to by the Properties field.
	PropertiesLength uint32 `idl:"name:cbProperties" json:"properties_length"`
	// Properties: A PROPERTY_LIST (section 2.2.3.10) containing the common properties of
	// the resource.
	Properties []byte `idl:"name:Properties;size_is:(cbProperties)" json:"properties"`
	// cbRoProperties: The size in bytes of the buffer pointed to by the RoProperties field.
	ReadOnlyPropertiesLength uint32 `idl:"name:cbRoProperties" json:"read_only_properties_length"`
	// RoProperties: A PROPERTY_LIST containing the common read-only properties of the resource.
	ReadOnlyProperties []byte `idl:"name:RoProperties;size_is:(cbRoProperties)" json:"read_only_properties"`
}

func (o *ResourceEnumEntry) xxx_PreparePayload(ctx context.Context) error {
	if o.Properties != nil && o.PropertiesLength == 0 {
		o.PropertiesLength = uint32(len(o.Properties))
	}
	if o.ReadOnlyProperties != nil && o.ReadOnlyPropertiesLength == 0 {
		o.ReadOnlyPropertiesLength = uint32(len(o.ReadOnlyProperties))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ResourceEnumEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ID != "" {
		_ptr_Id := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ID, _ptr_Id); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OwnerName != "" {
		_ptr_OwnerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.OwnerName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.OwnerName, _ptr_OwnerName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OwnerID != "" {
		_ptr_OwnerId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.OwnerID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.OwnerID, _ptr_OwnerId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PropertiesLength); err != nil {
		return err
	}
	if o.Properties != nil || o.PropertiesLength > 0 {
		_ptr_Properties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PropertiesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Properties {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Properties[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Properties); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Properties, _ptr_Properties); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ReadOnlyPropertiesLength); err != nil {
		return err
	}
	if o.ReadOnlyProperties != nil || o.ReadOnlyPropertiesLength > 0 {
		_ptr_RoProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ReadOnlyPropertiesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ReadOnlyProperties {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.ReadOnlyProperties[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.ReadOnlyProperties); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReadOnlyProperties, _ptr_RoProperties); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ResourceEnumEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	_ptr_Id := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ID); err != nil {
			return err
		}
		return nil
	})
	_s_Id := func(ptr interface{}) { o.ID = *ptr.(*string) }
	if err := w.ReadPointer(&o.ID, _s_Id, _ptr_Id); err != nil {
		return err
	}
	_ptr_OwnerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.OwnerName); err != nil {
			return err
		}
		return nil
	})
	_s_OwnerName := func(ptr interface{}) { o.OwnerName = *ptr.(*string) }
	if err := w.ReadPointer(&o.OwnerName, _s_OwnerName, _ptr_OwnerName); err != nil {
		return err
	}
	_ptr_OwnerId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.OwnerID); err != nil {
			return err
		}
		return nil
	})
	_s_OwnerId := func(ptr interface{}) { o.OwnerID = *ptr.(*string) }
	if err := w.ReadPointer(&o.OwnerID, _s_OwnerId, _ptr_OwnerId); err != nil {
		return err
	}
	if err := w.ReadData(&o.PropertiesLength); err != nil {
		return err
	}
	_ptr_Properties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PropertiesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PropertiesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Properties", sizeInfo[0])
		}
		o.Properties = make([]byte, sizeInfo[0])
		for i1 := range o.Properties {
			i1 := i1
			if err := w.ReadData(&o.Properties[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Properties := func(ptr interface{}) { o.Properties = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Properties, _s_Properties, _ptr_Properties); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReadOnlyPropertiesLength); err != nil {
		return err
	}
	_ptr_RoProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ReadOnlyPropertiesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ReadOnlyPropertiesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ReadOnlyProperties", sizeInfo[0])
		}
		o.ReadOnlyProperties = make([]byte, sizeInfo[0])
		for i1 := range o.ReadOnlyProperties {
			i1 := i1
			if err := w.ReadData(&o.ReadOnlyProperties[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_RoProperties := func(ptr interface{}) { o.ReadOnlyProperties = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.ReadOnlyProperties, _s_RoProperties, _ptr_RoProperties); err != nil {
		return err
	}
	return nil
}

// GroupEnumList structure represents GROUP_ENUM_LIST RPC structure.
//
// The GROUP_ENUM_LIST structure is a container for a list of GROUP_ENUM_ENTRY (section
// 2.2.3.25) structures. This structure encapsulates the results of a call to ApiCreateGroupEnum
// (section 3.1.4.2.139), which clients use to enumerate the groups in a cluster.
type GroupEnumList struct {
	// EntryCount: The number of GROUP_ENUM_ENTRY structures contained in the Entry field.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// Entry: An array of GROUP_ENUM_ENTRY structures that represent information for the
	// groups being enumerated.
	Entry []*GroupEnumEntry `idl:"name:Entry;size_is:(EntryCount)" json:"entry"`
}

func (o *GroupEnumList) xxx_PreparePayload(ctx context.Context) error {
	if o.Entry != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.Entry))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *GroupEnumList) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntryCount)
	return []uint64{
		dimSize1,
	}
}
func (o *GroupEnumList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	for i1 := range o.Entry {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Entry[i1] != nil {
			if err := o.Entry[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupEnumEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Entry); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&GroupEnumEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupEnumList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntryCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntryCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Entry", sizeInfo[0])
	}
	o.Entry = make([]*GroupEnumEntry, sizeInfo[0])
	for i1 := range o.Entry {
		i1 := i1
		if o.Entry[i1] == nil {
			o.Entry[i1] = &GroupEnumEntry{}
		}
		if err := o.Entry[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ResourceEnumList structure represents RESOURCE_ENUM_LIST RPC structure.
//
// The RESOURCE_ENUM_LIST structure is a container for a list of RESOURCE_ENUM_ENTRY
// (section 2.2.3.27) structures. This structure encapsulates the results of a call
// to ApiCreateResourceEnum (section 3.1.4.2.140), which clients use to enumerate resources.
type ResourceEnumList struct {
	// EntryCount: The number of RESOURCE_ENUM_ENTRY in the Entry field.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// Entry: An array of RESOURCE_ENUM_ENTRY that contain information for each enumerated
	// resource.
	Entry []*ResourceEnumEntry `idl:"name:Entry;size_is:(EntryCount)" json:"entry"`
}

func (o *ResourceEnumList) xxx_PreparePayload(ctx context.Context) error {
	if o.Entry != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.Entry))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *ResourceEnumList) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntryCount)
	return []uint64{
		dimSize1,
	}
}
func (o *ResourceEnumList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	for i1 := range o.Entry {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Entry[i1] != nil {
			if err := o.Entry[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ResourceEnumEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Entry); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&ResourceEnumEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ResourceEnumList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntryCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntryCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Entry", sizeInfo[0])
	}
	o.Entry = make([]*ResourceEnumEntry, sizeInfo[0])
	for i1 := range o.Entry {
		i1 := i1
		if o.Entry[i1] == nil {
			o.Entry[i1] = &ResourceEnumEntry{}
		}
		if err := o.Entry[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// Generic structure represents HGENERIC_RPC RPC structure.
type Generic dcetypes.ContextHandle

func (o *Generic) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Generic) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Generic) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Generic) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// NotifyFilterAndTypeRPC structure represents NOTIFY_FILTER_AND_TYPE_RPC RPC structure.
//
// The NOTIFY_FILTER_AND_TYPE_RPC structure contains information about notifications
// that clients register for by using ApiAddNotifyV2 (section 3.1.4.2.137) or that clients
// get notification for by using ApiGetNotifyV2 (section 3.1.4.2.138).<27>
type NotifyFilterAndTypeRPC struct {
	// dwObjectType: The type of object for which the notification is generated (see section
	// 2.2.2.12).
	ObjectType uint32 `idl:"name:dwObjectType" json:"object_type"`
	// FilterFlags: A set of flags indicating the particular notification that was generated
	// for the object. See ApiCreateNotifyV2 (section 3.1.4.2.136) for the list of object-specific
	// notifications.
	FilterFlags int64 `idl:"name:FilterFlags" json:"filter_flags"`
}

func (o *NotifyFilterAndTypeRPC) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyFilterAndTypeRPC) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ObjectType); err != nil {
		return err
	}
	if err := w.WriteData(o.FilterFlags); err != nil {
		return err
	}
	return nil
}
func (o *NotifyFilterAndTypeRPC) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectType); err != nil {
		return err
	}
	if err := w.ReadData(&o.FilterFlags); err != nil {
		return err
	}
	return nil
}

// NotificationDataRPC structure represents NOTIFICATION_DATA_RPC RPC structure.
//
// The NOTIFICATION_DATA_RPC structure contains the information for a specific notification.
// See ApiGetNotifyV2 (section 3.1.4.2.138) for the exact values the fields of this
// structure use for specific notification objects and their types.<28>
type NotificationDataRPC struct {
	// FilterAndType: A NOTIFY_FILTER_AND_TYPE_RPC (section 2.2.3.22) structure containing
	// the object type and notification value.
	FilterAndType *NotifyFilterAndTypeRPC `idl:"name:FilterAndType" json:"filter_and_type"`
	// buffer: A pointer to the payload buffer. The format of this buffer is specific to
	// the notification type. For details, see ApiGetNotifyV2.
	Buffer []byte `idl:"name:buffer;size_is:(dwBufferSize)" json:"buffer"`
	// dwBufferSize: The size in bytes of the buffer field.
	BufferSize uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
	// ObjectId: A buffer of 16-bit Unicode characters containing the Id of the object for
	// which the notification was generated. This field MUST be followed by 0 or more bytes
	// of padding, which MUST be ignored.
	ObjectID string `idl:"name:ObjectId;string" json:"object_id"`
	// ParentId: A buffer of 16-bit Unicode characters containing the Id of the parent of
	// the object represented by the ObjectId field. This field MUST be followed by 0 or
	// more bytes of padding, which MUST be ignored.
	ParentID string `idl:"name:ParentId;string" json:"parent_id"`
	// Name: A buffer of 16-bit Unicode characters containing the name of the object for
	// which the notification was generated. This field MUST be followed by 0 or more bytes
	// of padding, which MUST be ignored.
	Name string `idl:"name:Name;string" json:"name"`
	// Type: A buffer of 16-bit Unicode characters containing the object type for which
	// the notification was generated. This field MUST be followed by 0 or more bytes of
	// padding, which MUST be ignored.
	Type string `idl:"name:Type;string" json:"type"`
}

func (o *NotificationDataRPC) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationDataRPC) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.FilterAndType != nil {
		if err := o.FilterAndType.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NotifyFilterAndTypeRPC{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Buffer != nil || o.BufferSize > 0 {
		_ptr_buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.BufferSize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.BufferSize); err != nil {
		return err
	}
	if o.ObjectID != "" {
		_ptr_ObjectId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ObjectID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectID, _ptr_ObjectId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ParentID != "" {
		_ptr_ParentId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ParentID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParentID, _ptr_ParentId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Type != "" {
		_ptr_Type := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Type); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Type, _ptr_Type); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationDataRPC) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.FilterAndType == nil {
		o.FilterAndType = &NotifyFilterAndTypeRPC{}
	}
	if err := o.FilterAndType.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.BufferSize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.BufferSize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_buffer, _ptr_buffer); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferSize); err != nil {
		return err
	}
	_ptr_ObjectId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ObjectID); err != nil {
			return err
		}
		return nil
	})
	_s_ObjectId := func(ptr interface{}) { o.ObjectID = *ptr.(*string) }
	if err := w.ReadPointer(&o.ObjectID, _s_ObjectId, _ptr_ObjectId); err != nil {
		return err
	}
	_ptr_ParentId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ParentID); err != nil {
			return err
		}
		return nil
	})
	_s_ParentId := func(ptr interface{}) { o.ParentID = *ptr.(*string) }
	if err := w.ReadPointer(&o.ParentID, _s_ParentId, _ptr_ParentId); err != nil {
		return err
	}
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	_ptr_Type := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Type); err != nil {
			return err
		}
		return nil
	})
	_s_Type := func(ptr interface{}) { o.Type = *ptr.(*string) }
	if err := w.ReadPointer(&o.Type, _s_Type, _ptr_Type); err != nil {
		return err
	}
	return nil
}

// NotificationRPC structure represents NOTIFICATION_RPC RPC structure.
//
// The NOTIFICATION_RPC structure associates the NOTIFICATION_DATA_RPC structure with
// the notify key that was passed as a parameter to ApiAddNotifyV2 (section 3.1.4.2.137).
type NotificationRPC struct {
	// dwNotifyKey: A 32-bit value provided by the client.
	NotifyKey uint64 `idl:"name:dwNotifyKey" json:"notify_key"`
	// NotificationData: A NOTIFICATION_DATA_RPC structure as defined in section 2.2.3.23.
	NotificationData *NotificationDataRPC `idl:"name:NotificationData" json:"notification_data"`
}

func (o *NotificationRPC) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationRPC) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(ndr.Uint3264(o.NotifyKey)); err != nil {
		return err
	}
	if o.NotificationData != nil {
		if err := o.NotificationData.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NotificationDataRPC{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationRPC) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData((*ndr.Uint3264)(&o.NotifyKey)); err != nil {
		return err
	}
	if o.NotificationData == nil {
		o.NotificationData = &NotificationDataRPC{}
	}
	if err := o.NotificationData.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// NotificationDataAsyncRPC structure represents NOTIFICATION_DATA_ASYNC_RPC RPC structure.
//
// The NOTIFICATION_DATA_ASYNC_RPC structure contains the information for a specific
// notification. See ApiGetNotifyAsync (section 3.1.4.2.143) for more information.
type NotificationDataAsyncRPC struct {
	// dwNotifyKey: The address of a 32-bit integer that the server MUST write upon successful
	// completion of this method. The value was supplied as the dwNotifyKey parameter in
	// a previous call to one of the following methods: ApiAddNotifyCluster (section 3.1.4.1.58),
	// ApiAddNotifyNode (section 3.1.4.1.59), ApiAddNotifyGroup (section 3.1.4.1.60), ApiAddNotifyResource
	// (section 3.1.4.1.61), ApiAddNotifyKey (section 3.1.4.1.62), ApiAddNotifyNetwork (section
	// 3.1.4.1.90), ApiAddNotifyNetInterface (section 3.1.4.1.99), ApiReAddNotifyNode (section
	// 3.1.4.1.63), ApiReAddNotifyGroup (section 3.1.4.1.64), ApiReAddNotifyResource (section
	// 3.1.4.1.65), ApiReAddNotifyNetwork (section 3.1.4.1.91), or ApiReAddNotifyNetInterface
	// (section 3.1.4.1.100).
	NotifyKey uint32 `idl:"name:dwNotifyKey" json:"notify_key"`
	// dwFilter: The address of a 32-bit integer value that the server MUST write upon successful
	// completion of this method, which contains the CLUSTER_CHANGE (section 2.2.2.7) enumeration
	// value, indicating the type of event. The value MUST match one or more filter blocks
	// that were provided in a previous call to one of the following methods: ApiAddNotifyCluster,
	// ApiAddNotifyNode, ApiAddNotifyGroup, ApiAddNotifyResource, ApiAddNotifyKey, ApiAddNotifyNetwork,
	// ApiAddNotifyNetInterface, ApiReAddNotifyNode, ApiReAddNotifyGroup, ApiReAddNotifyResource,
	// ApiReAddNotifyNetwork, or ApiReAddNotifyNetInterface.
	Filter uint32 `idl:"name:dwFilter" json:"filter"`
	// Name: The address of a pointer where the server MUST write, upon successful completion
	// of this method, the address of a Unicode string buffer that contains the name of
	// the object to which the event pertains. If a name is not associated with the event,
	// then the buffer contains the null Unicode string.
	Name string `idl:"name:Name;string" json:"name"`
}

func (o *NotificationDataAsyncRPC) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationDataAsyncRPC) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NotifyKey); err != nil {
		return err
	}
	if err := w.WriteData(o.Filter); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotificationDataAsyncRPC) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotifyKey); err != nil {
		return err
	}
	if err := w.ReadData(&o.Filter); err != nil {
		return err
	}
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	return nil
}

// DiskIDEnum type represents CLUSDSK_DISKID_ENUM RPC enumeration.
//
// The CLUSDSK_DISKID_ENUM enumeration defines the possible values of the disk ID types.
type DiskIDEnum uint16

var (
	// DiskIdSignature: This value indicates a master boot record (MBR) disk type.
	DiskIDEnumSignature DiskIDEnum = 1
	// DiskIdGuid: This value indicates a GPT disk type.
	DiskIDEnumGUID DiskIDEnum = 2
	// DiskIdUnKnown: This value indicates a disk whose partition type is unknown.
	DiskIDEnumUnknown DiskIDEnum = 5000
)

func (o DiskIDEnum) String() string {
	switch o {
	case DiskIDEnumSignature:
		return "DiskIDEnumSignature"
	case DiskIDEnumGUID:
		return "DiskIDEnumGUID"
	case DiskIDEnumUnknown:
		return "DiskIDEnumUnknown"
	}
	return "Invalid"
}

// DiskID structure represents CLUSDSK_DISKID RPC structure.
//
// The CLUSDSK_DISKID structure contains the identification information of the disk
// of the designated storage class resource type.
type DiskID struct {
	// DiskIdType: A 32-bit integer indicating disk ID type. See CLUSDSK_DISKID_ENUM (section
	// 2.2.2.22).
	DiskIDType DiskIDEnum     `idl:"name:DiskIdType" json:"disk_id_type"`
	DiskID     *DiskID_DiskID `idl:"name:DiskID;switch_is:DiskIdType" json:"disk_id"`
}

func (o *DiskID) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(uint16(o.DiskIDType)); err != nil {
		return err
	}
	_swDiskID := uint16(o.DiskIDType)
	if o.DiskID != nil {
		if err := o.DiskID.MarshalUnionNDR(ctx, w, _swDiskID); err != nil {
			return err
		}
	} else {
		if err := (&DiskID_DiskID{}).MarshalUnionNDR(ctx, w, _swDiskID); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData((*uint16)(&o.DiskIDType)); err != nil {
		return err
	}
	if o.DiskID == nil {
		o.DiskID = &DiskID_DiskID{}
	}
	_swDiskID := uint16(o.DiskIDType)
	if err := o.DiskID.UnmarshalUnionNDR(ctx, w, _swDiskID); err != nil {
		return err
	}
	return nil
}

// DiskID_DiskID structure represents CLUSDSK_DISKID union anonymous member.
//
// The CLUSDSK_DISKID structure contains the identification information of the disk
// of the designated storage class resource type.
type DiskID_DiskID struct {
	// Types that are assignable to Value
	//
	// *DiskID_DiskSignature
	// *DiskID_DiskGUID
	Value is_DiskID_DiskID `json:"value"`
}

func (o *DiskID_DiskID) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *DiskID_DiskSignature:
		if value != nil {
			return value.DiskSignature
		}
	case *DiskID_DiskGUID:
		if value != nil {
			return value.DiskGUID
		}
	}
	return nil
}

type is_DiskID_DiskID interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_DiskID_DiskID()
}

func (o *DiskID_DiskID) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *DiskID_DiskSignature:
		return uint16(1)
	case *DiskID_DiskGUID:
		return uint16(2)
	}
	return uint16(0)
}

func (o *DiskID_DiskID) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteSwitch(uint16(sw)); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		_o, _ := o.Value.(*DiskID_DiskSignature)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DiskID_DiskSignature{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(2):
		_o, _ := o.Value.(*DiskID_DiskGUID)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DiskID_DiskGUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *DiskID_DiskID) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadSwitch((*uint16)(&sw)); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		o.Value = &DiskID_DiskSignature{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(2):
		o.Value = &DiskID_DiskGUID{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// DiskID_DiskSignature structure represents DiskID_DiskID RPC union arm.
//
// It has following labels: 1
type DiskID_DiskSignature struct {
	// DiskSignature: Identification information of the disk is an MBR disk signature.
	DiskSignature uint32 `idl:"name:DiskSignature" json:"disk_signature"`
}

func (*DiskID_DiskSignature) is_DiskID_DiskID() {}

func (o *DiskID_DiskSignature) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteData(o.DiskSignature); err != nil {
		return err
	}
	return nil
}
func (o *DiskID_DiskSignature) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadData(&o.DiskSignature); err != nil {
		return err
	}
	return nil
}

// DiskID_DiskGUID structure represents DiskID_DiskID RPC union arm.
//
// It has following labels: 2
type DiskID_DiskGUID struct {
	// DiskGuid: Identification information of the disk is a GPT disk ID, which is a 128-bit
	// GUID.
	DiskGUID *dtyp.GUID `idl:"name:DiskGuid" json:"disk_guid"`
}

func (*DiskID_DiskGUID) is_DiskID_DiskID() {}

func (o *DiskID_DiskGUID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DiskGUID != nil {
		if err := o.DiskGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskID_DiskGUID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.DiskGUID == nil {
		o.DiskGUID = &dtyp.GUID{}
	}
	if err := o.DiskGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultClusapi3Client struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultClusapi3Client) OpenCluster(ctx context.Context, in *OpenClusterRequest, opts ...dcerpc.CallOption) (*OpenClusterResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenClusterResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseCluster(ctx context.Context, in *CloseClusterRequest, opts ...dcerpc.CallOption) (*CloseClusterResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseClusterResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetClusterName(ctx context.Context, in *SetClusterNameRequest, opts ...dcerpc.CallOption) (*SetClusterNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetClusterNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetClusterName(ctx context.Context, in *GetClusterNameRequest, opts ...dcerpc.CallOption) (*GetClusterNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClusterNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetClusterVersion(ctx context.Context, in *GetClusterVersionRequest, opts ...dcerpc.CallOption) (*GetClusterVersionResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClusterVersionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetQuorumResource(ctx context.Context, in *GetQuorumResourceRequest, opts ...dcerpc.CallOption) (*GetQuorumResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetQuorumResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetQuorumResource(ctx context.Context, in *SetQuorumResourceRequest, opts ...dcerpc.CallOption) (*SetQuorumResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetQuorumResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateEnum(ctx context.Context, in *CreateEnumRequest, opts ...dcerpc.CallOption) (*CreateEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenResource(ctx context.Context, in *OpenResourceRequest, opts ...dcerpc.CallOption) (*OpenResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateResource(ctx context.Context, in *CreateResourceRequest, opts ...dcerpc.CallOption) (*CreateResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteResource(ctx context.Context, in *DeleteResourceRequest, opts ...dcerpc.CallOption) (*DeleteResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseResource(ctx context.Context, in *CloseResourceRequest, opts ...dcerpc.CallOption) (*CloseResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetResourceState(ctx context.Context, in *GetResourceStateRequest, opts ...dcerpc.CallOption) (*GetResourceStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetResourceStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetResourceName(ctx context.Context, in *SetResourceNameRequest, opts ...dcerpc.CallOption) (*SetResourceNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetResourceNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetResourceID(ctx context.Context, in *GetResourceIDRequest, opts ...dcerpc.CallOption) (*GetResourceIDResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetResourceIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetResourceType(ctx context.Context, in *GetResourceTypeRequest, opts ...dcerpc.CallOption) (*GetResourceTypeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetResourceTypeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) FailResource(ctx context.Context, in *FailResourceRequest, opts ...dcerpc.CallOption) (*FailResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OnlineResource(ctx context.Context, in *OnlineResourceRequest, opts ...dcerpc.CallOption) (*OnlineResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OnlineResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OfflineResource(ctx context.Context, in *OfflineResourceRequest, opts ...dcerpc.CallOption) (*OfflineResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OfflineResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddResourceDependency(ctx context.Context, in *AddResourceDependencyRequest, opts ...dcerpc.CallOption) (*AddResourceDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddResourceDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveResourceDependency(ctx context.Context, in *RemoveResourceDependencyRequest, opts ...dcerpc.CallOption) (*RemoveResourceDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveResourceDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CanResourceBeDependent(ctx context.Context, in *CanResourceBeDependentRequest, opts ...dcerpc.CallOption) (*CanResourceBeDependentResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CanResourceBeDependentResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateRestrictionEnum(ctx context.Context, in *CreateRestrictionEnumRequest, opts ...dcerpc.CallOption) (*CreateRestrictionEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateRestrictionEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddResourceNode(ctx context.Context, in *AddResourceNodeRequest, opts ...dcerpc.CallOption) (*AddResourceNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddResourceNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveResourceNode(ctx context.Context, in *RemoveResourceNodeRequest, opts ...dcerpc.CallOption) (*RemoveResourceNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveResourceNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ChangeResourceGroup(ctx context.Context, in *ChangeResourceGroupRequest, opts ...dcerpc.CallOption) (*ChangeResourceGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeResourceGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateResourceType(ctx context.Context, in *CreateResourceTypeRequest, opts ...dcerpc.CallOption) (*CreateResourceTypeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateResourceTypeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteResourceType(ctx context.Context, in *DeleteResourceTypeRequest, opts ...dcerpc.CallOption) (*DeleteResourceTypeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteResourceTypeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetRootKey(ctx context.Context, in *GetRootKeyRequest, opts ...dcerpc.CallOption) (*GetRootKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetRootKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...dcerpc.CallOption) (*CreateKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenKey(ctx context.Context, in *OpenKeyRequest, opts ...dcerpc.CallOption) (*OpenKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) EnumKey(ctx context.Context, in *EnumKeyRequest, opts ...dcerpc.CallOption) (*EnumKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetValue(ctx context.Context, in *SetValueRequest, opts ...dcerpc.CallOption) (*SetValueResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetValueResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteValue(ctx context.Context, in *DeleteValueRequest, opts ...dcerpc.CallOption) (*DeleteValueResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteValueResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) QueryValue(ctx context.Context, in *QueryValueRequest, opts ...dcerpc.CallOption) (*QueryValueResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryValueResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...dcerpc.CallOption) (*DeleteKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) EnumValue(ctx context.Context, in *EnumValueRequest, opts ...dcerpc.CallOption) (*EnumValueResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumValueResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseKey(ctx context.Context, in *CloseKeyRequest, opts ...dcerpc.CallOption) (*CloseKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) QueryInfoKey(ctx context.Context, in *QueryInfoKeyRequest, opts ...dcerpc.CallOption) (*QueryInfoKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryInfoKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetKeySecurity(ctx context.Context, in *SetKeySecurityRequest, opts ...dcerpc.CallOption) (*SetKeySecurityResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetKeySecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetKeySecurity(ctx context.Context, in *GetKeySecurityRequest, opts ...dcerpc.CallOption) (*GetKeySecurityResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetKeySecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenGroup(ctx context.Context, in *OpenGroupRequest, opts ...dcerpc.CallOption) (*OpenGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...dcerpc.CallOption) (*CreateGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...dcerpc.CallOption) (*DeleteGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseGroup(ctx context.Context, in *CloseGroupRequest, opts ...dcerpc.CallOption) (*CloseGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetGroupState(ctx context.Context, in *GetGroupStateRequest, opts ...dcerpc.CallOption) (*GetGroupStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetGroupStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetGroupName(ctx context.Context, in *SetGroupNameRequest, opts ...dcerpc.CallOption) (*SetGroupNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGroupNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetGroupID(ctx context.Context, in *GetGroupIDRequest, opts ...dcerpc.CallOption) (*GetGroupIDResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetGroupIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNodeID(ctx context.Context, in *GetNodeIDRequest, opts ...dcerpc.CallOption) (*GetNodeIDResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNodeIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OnlineGroup(ctx context.Context, in *OnlineGroupRequest, opts ...dcerpc.CallOption) (*OnlineGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OnlineGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OfflineGroup(ctx context.Context, in *OfflineGroupRequest, opts ...dcerpc.CallOption) (*OfflineGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OfflineGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) MoveGroup(ctx context.Context, in *MoveGroupRequest, opts ...dcerpc.CallOption) (*MoveGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &MoveGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) MoveGroupToNode(ctx context.Context, in *MoveGroupToNodeRequest, opts ...dcerpc.CallOption) (*MoveGroupToNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &MoveGroupToNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroupResourceEnum(ctx context.Context, in *CreateGroupResourceEnumRequest, opts ...dcerpc.CallOption) (*CreateGroupResourceEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupResourceEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetGroupNodeList(ctx context.Context, in *SetGroupNodeListRequest, opts ...dcerpc.CallOption) (*SetGroupNodeListResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGroupNodeListResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNotify(ctx context.Context, in *CreateNotifyRequest, opts ...dcerpc.CallOption) (*CreateNotifyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNotifyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseNotify(ctx context.Context, in *CloseNotifyRequest, opts ...dcerpc.CallOption) (*CloseNotifyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseNotifyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyCluster(ctx context.Context, in *AddNotifyClusterRequest, opts ...dcerpc.CallOption) (*AddNotifyClusterResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyClusterResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyNode(ctx context.Context, in *AddNotifyNodeRequest, opts ...dcerpc.CallOption) (*AddNotifyNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyGroup(ctx context.Context, in *AddNotifyGroupRequest, opts ...dcerpc.CallOption) (*AddNotifyGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyResource(ctx context.Context, in *AddNotifyResourceRequest, opts ...dcerpc.CallOption) (*AddNotifyResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyKey(ctx context.Context, in *AddNotifyKeyRequest, opts ...dcerpc.CallOption) (*AddNotifyKeyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ReAddNotifyNode(ctx context.Context, in *ReAddNotifyNodeRequest, opts ...dcerpc.CallOption) (*ReAddNotifyNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReAddNotifyNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ReAddNotifyGroup(ctx context.Context, in *ReAddNotifyGroupRequest, opts ...dcerpc.CallOption) (*ReAddNotifyGroupResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReAddNotifyGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ReAddNotifyResource(ctx context.Context, in *ReAddNotifyResourceRequest, opts ...dcerpc.CallOption) (*ReAddNotifyResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReAddNotifyResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNotify(ctx context.Context, in *GetNotifyRequest, opts ...dcerpc.CallOption) (*GetNotifyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNotifyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNode(ctx context.Context, in *OpenNodeRequest, opts ...dcerpc.CallOption) (*OpenNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseNode(ctx context.Context, in *CloseNodeRequest, opts ...dcerpc.CallOption) (*CloseNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNodeState(ctx context.Context, in *GetNodeStateRequest, opts ...dcerpc.CallOption) (*GetNodeStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNodeStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) PauseNode(ctx context.Context, in *PauseNodeRequest, opts ...dcerpc.CallOption) (*PauseNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PauseNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ResumeNode(ctx context.Context, in *ResumeNodeRequest, opts ...dcerpc.CallOption) (*ResumeNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ResumeNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) EvictNode(ctx context.Context, in *EvictNodeRequest, opts ...dcerpc.CallOption) (*EvictNodeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EvictNodeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeResourceControl(ctx context.Context, in *NodeResourceControlRequest, opts ...dcerpc.CallOption) (*NodeResourceControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeResourceControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ResourceControl(ctx context.Context, in *ResourceControlRequest, opts ...dcerpc.CallOption) (*ResourceControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ResourceControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeResourceTypeControl(ctx context.Context, in *NodeResourceTypeControlRequest, opts ...dcerpc.CallOption) (*NodeResourceTypeControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeResourceTypeControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ResourceTypeControl(ctx context.Context, in *ResourceTypeControlRequest, opts ...dcerpc.CallOption) (*ResourceTypeControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ResourceTypeControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeGroupControl(ctx context.Context, in *NodeGroupControlRequest, opts ...dcerpc.CallOption) (*NodeGroupControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeGroupControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GroupControl(ctx context.Context, in *GroupControlRequest, opts ...dcerpc.CallOption) (*GroupControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GroupControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeNodeControl(ctx context.Context, in *NodeNodeControlRequest, opts ...dcerpc.CallOption) (*NodeNodeControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeNodeControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeControl(ctx context.Context, in *NodeControlRequest, opts ...dcerpc.CallOption) (*NodeControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNetwork(ctx context.Context, in *OpenNetworkRequest, opts ...dcerpc.CallOption) (*OpenNetworkResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNetworkResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseNetwork(ctx context.Context, in *CloseNetworkRequest, opts ...dcerpc.CallOption) (*CloseNetworkResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseNetworkResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNetworkState(ctx context.Context, in *GetNetworkStateRequest, opts ...dcerpc.CallOption) (*GetNetworkStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetworkStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetNetworkName(ctx context.Context, in *SetNetworkNameRequest, opts ...dcerpc.CallOption) (*SetNetworkNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetNetworkNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNetworkEnum(ctx context.Context, in *CreateNetworkEnumRequest, opts ...dcerpc.CallOption) (*CreateNetworkEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNetworkEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNetworkID(ctx context.Context, in *GetNetworkIDRequest, opts ...dcerpc.CallOption) (*GetNetworkIDResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetworkIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetNetworkPriorityOrder(ctx context.Context, in *SetNetworkPriorityOrderRequest, opts ...dcerpc.CallOption) (*SetNetworkPriorityOrderResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetNetworkPriorityOrderResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeNetworkControl(ctx context.Context, in *NodeNetworkControlRequest, opts ...dcerpc.CallOption) (*NodeNetworkControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeNetworkControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NetworkControl(ctx context.Context, in *NetworkControlRequest, opts ...dcerpc.CallOption) (*NetworkControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NetworkControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyNetwork(ctx context.Context, in *AddNotifyNetworkRequest, opts ...dcerpc.CallOption) (*AddNotifyNetworkResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyNetworkResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ReAddNotifyNetwork(ctx context.Context, in *ReAddNotifyNetworkRequest, opts ...dcerpc.CallOption) (*ReAddNotifyNetworkResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReAddNotifyNetworkResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNetInterface(ctx context.Context, in *OpenNetInterfaceRequest, opts ...dcerpc.CallOption) (*OpenNetInterfaceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNetInterfaceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseNetInterface(ctx context.Context, in *CloseNetInterfaceRequest, opts ...dcerpc.CallOption) (*CloseNetInterfaceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseNetInterfaceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNetInterfaceState(ctx context.Context, in *GetNetInterfaceStateRequest, opts ...dcerpc.CallOption) (*GetNetInterfaceStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetInterfaceStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNetInterface(ctx context.Context, in *GetNetInterfaceRequest, opts ...dcerpc.CallOption) (*GetNetInterfaceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetInterfaceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNetInterfaceID(ctx context.Context, in *GetNetInterfaceIDRequest, opts ...dcerpc.CallOption) (*GetNetInterfaceIDResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetInterfaceIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeNetInterfaceControl(ctx context.Context, in *NodeNetInterfaceControlRequest, opts ...dcerpc.CallOption) (*NodeNetInterfaceControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeNetInterfaceControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NetInterfaceControl(ctx context.Context, in *NetInterfaceControlRequest, opts ...dcerpc.CallOption) (*NetInterfaceControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NetInterfaceControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyNetInterface(ctx context.Context, in *AddNotifyNetInterfaceRequest, opts ...dcerpc.CallOption) (*AddNotifyNetInterfaceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyNetInterfaceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ReAddNotifyNetInterface(ctx context.Context, in *ReAddNotifyNetInterfaceRequest, opts ...dcerpc.CallOption) (*ReAddNotifyNetInterfaceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReAddNotifyNetInterfaceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNodeEnum(ctx context.Context, in *CreateNodeEnumRequest, opts ...dcerpc.CallOption) (*CreateNodeEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNodeEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetClusterVersion2(ctx context.Context, in *GetClusterVersion2Request, opts ...dcerpc.CallOption) (*GetClusterVersion2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClusterVersion2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateRestrictionTypeEnum(ctx context.Context, in *CreateRestrictionTypeEnumRequest, opts ...dcerpc.CallOption) (*CreateRestrictionTypeEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateRestrictionTypeEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) BackupClusterDatabase(ctx context.Context, in *BackupClusterDatabaseRequest, opts ...dcerpc.CallOption) (*BackupClusterDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &BackupClusterDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeClusterControl(ctx context.Context, in *NodeClusterControlRequest, opts ...dcerpc.CallOption) (*NodeClusterControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeClusterControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ClusterControl(ctx context.Context, in *ClusterControlRequest, opts ...dcerpc.CallOption) (*ClusterControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ClusterControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) UnblockGetNotifyCall(ctx context.Context, in *UnblockGetNotifyCallRequest, opts ...dcerpc.CallOption) (*UnblockGetNotifyCallResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UnblockGetNotifyCallResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetServiceAccountPassword(ctx context.Context, in *SetServiceAccountPasswordRequest, opts ...dcerpc.CallOption) (*SetServiceAccountPasswordResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServiceAccountPasswordResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetResourceDependencyExpression(ctx context.Context, in *SetResourceDependencyExpressionRequest, opts ...dcerpc.CallOption) (*SetResourceDependencyExpressionResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetResourceDependencyExpressionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetResourceDependencyExpression(ctx context.Context, in *GetResourceDependencyExpressionRequest, opts ...dcerpc.CallOption) (*GetResourceDependencyExpressionResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetResourceDependencyExpressionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetResourceNetworkName(ctx context.Context, in *GetResourceNetworkNameRequest, opts ...dcerpc.CallOption) (*GetResourceNetworkNameResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetResourceNetworkNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ExecuteBatch(ctx context.Context, in *ExecuteBatchRequest, opts ...dcerpc.CallOption) (*ExecuteBatchResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ExecuteBatchResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateBatchPort(ctx context.Context, in *CreateBatchPortRequest, opts ...dcerpc.CallOption) (*CreateBatchPortResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateBatchPortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetBatchNotification(ctx context.Context, in *GetBatchNotificationRequest, opts ...dcerpc.CallOption) (*GetBatchNotificationResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetBatchNotificationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseBatchPort(ctx context.Context, in *CloseBatchPortRequest, opts ...dcerpc.CallOption) (*CloseBatchPortResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseBatchPortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenClusterEx(ctx context.Context, in *OpenClusterExRequest, opts ...dcerpc.CallOption) (*OpenClusterExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenClusterExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNodeEx(ctx context.Context, in *OpenNodeExRequest, opts ...dcerpc.CallOption) (*OpenNodeExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNodeExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenGroupEx(ctx context.Context, in *OpenGroupExRequest, opts ...dcerpc.CallOption) (*OpenGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenResourceEx(ctx context.Context, in *OpenResourceExRequest, opts ...dcerpc.CallOption) (*OpenResourceExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenResourceExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNetworkEx(ctx context.Context, in *OpenNetworkExRequest, opts ...dcerpc.CallOption) (*OpenNetworkExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNetworkExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenNetInterfaceEx(ctx context.Context, in *OpenNetInterfaceExRequest, opts ...dcerpc.CallOption) (*OpenNetInterfaceExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenNetInterfaceExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ChangeCSVState(ctx context.Context, in *ChangeCSVStateRequest, opts ...dcerpc.CallOption) (*ChangeCSVStateResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeCSVStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNodeEnumEx(ctx context.Context, in *CreateNodeEnumExRequest, opts ...dcerpc.CallOption) (*CreateNodeEnumExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNodeEnumExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateEnumEx(ctx context.Context, in *CreateEnumExRequest, opts ...dcerpc.CallOption) (*CreateEnumExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateEnumExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) PauseNodeEx(ctx context.Context, in *PauseNodeExRequest, opts ...dcerpc.CallOption) (*PauseNodeExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PauseNodeExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) PauseNodeWithDrainTarget(ctx context.Context, in *PauseNodeWithDrainTargetRequest, opts ...dcerpc.CallOption) (*PauseNodeWithDrainTargetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PauseNodeWithDrainTargetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ResumeNodeEx(ctx context.Context, in *ResumeNodeExRequest, opts ...dcerpc.CallOption) (*ResumeNodeExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ResumeNodeExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroupEx(ctx context.Context, in *CreateGroupExRequest, opts ...dcerpc.CallOption) (*CreateGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OnlineGroupEx(ctx context.Context, in *OnlineGroupExRequest, opts ...dcerpc.CallOption) (*OnlineGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OnlineGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OfflineGroupEx(ctx context.Context, in *OfflineGroupExRequest, opts ...dcerpc.CallOption) (*OfflineGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OfflineGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) MoveGroupEx(ctx context.Context, in *MoveGroupExRequest, opts ...dcerpc.CallOption) (*MoveGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &MoveGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) MoveGroupToNodeEx(ctx context.Context, in *MoveGroupToNodeExRequest, opts ...dcerpc.CallOption) (*MoveGroupToNodeExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &MoveGroupToNodeExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CancelClusterGroupOperation(ctx context.Context, in *CancelClusterGroupOperationRequest, opts ...dcerpc.CallOption) (*CancelClusterGroupOperationResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CancelClusterGroupOperationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OnlineResourceEx(ctx context.Context, in *OnlineResourceExRequest, opts ...dcerpc.CallOption) (*OnlineResourceExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OnlineResourceExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OfflineResourceEx(ctx context.Context, in *OfflineResourceExRequest, opts ...dcerpc.CallOption) (*OfflineResourceExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OfflineResourceExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNotifyV2(ctx context.Context, in *CreateNotifyV2Request, opts ...dcerpc.CallOption) (*CreateNotifyV2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNotifyV2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyV2(ctx context.Context, in *AddNotifyV2Request, opts ...dcerpc.CallOption) (*AddNotifyV2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyV2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNotifyV2(ctx context.Context, in *GetNotifyV2Request, opts ...dcerpc.CallOption) (*GetNotifyV2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNotifyV2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroupEnum(ctx context.Context, in *CreateGroupEnumRequest, opts ...dcerpc.CallOption) (*CreateGroupEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateResourceEnum(ctx context.Context, in *CreateResourceEnumRequest, opts ...dcerpc.CallOption) (*CreateResourceEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateResourceEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ExecuteReadBatch(ctx context.Context, in *ExecuteReadBatchRequest, opts ...dcerpc.CallOption) (*ExecuteReadBatchResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ExecuteReadBatchResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RestartResource(ctx context.Context, in *RestartResourceRequest, opts ...dcerpc.CallOption) (*RestartResourceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RestartResourceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GetNotifyAsync(ctx context.Context, in *GetNotifyAsyncRequest, opts ...dcerpc.CallOption) (*GetNotifyAsyncResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNotifyAsyncResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) Opnum149otUsedOnWire(ctx context.Context, in *Opnum149otUsedOnWireRequest, opts ...dcerpc.CallOption) (*Opnum149otUsedOnWireResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &Opnum149otUsedOnWireResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddNotifyResourceTypeV2(ctx context.Context, in *AddNotifyResourceTypeV2Request, opts ...dcerpc.CallOption) (*AddNotifyResourceTypeV2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddNotifyResourceTypeV2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ExecuteReadBatchEx(ctx context.Context, in *ExecuteReadBatchExRequest, opts ...dcerpc.CallOption) (*ExecuteReadBatchExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ExecuteReadBatchExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroupSet(ctx context.Context, in *CreateGroupSetRequest, opts ...dcerpc.CallOption) (*CreateGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) OpenGroupSet(ctx context.Context, in *OpenGroupSetRequest, opts ...dcerpc.CallOption) (*OpenGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != nil {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CloseGroupSet(ctx context.Context, in *CloseGroupSetRequest, opts ...dcerpc.CallOption) (*CloseGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) DeleteGroupSet(ctx context.Context, in *DeleteGroupSetRequest, opts ...dcerpc.CallOption) (*DeleteGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddGroupToGroupSet(ctx context.Context, in *AddGroupToGroupSetRequest, opts ...dcerpc.CallOption) (*AddGroupToGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddGroupToGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveGroupFromGroupSet(ctx context.Context, in *RemoveGroupFromGroupSetRequest, opts ...dcerpc.CallOption) (*RemoveGroupFromGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveGroupFromGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) MoveGroupToGroupSet(ctx context.Context, in *MoveGroupToGroupSetRequest, opts ...dcerpc.CallOption) (*MoveGroupToGroupSetResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &MoveGroupToGroupSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddGroupSetDependency(ctx context.Context, in *AddGroupSetDependencyRequest, opts ...dcerpc.CallOption) (*AddGroupSetDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddGroupSetDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddGroupToGroupSetDependency(ctx context.Context, in *AddGroupToGroupSetDependencyRequest, opts ...dcerpc.CallOption) (*AddGroupToGroupSetDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddGroupToGroupSetDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) NodeGroupSetControl(ctx context.Context, in *NodeGroupSetControlRequest, opts ...dcerpc.CallOption) (*NodeGroupSetControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NodeGroupSetControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) GroupSetControl(ctx context.Context, in *GroupSetControlRequest, opts ...dcerpc.CallOption) (*GroupSetControlResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GroupSetControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetGroupDependencyExpression(ctx context.Context, in *SetGroupDependencyExpressionRequest, opts ...dcerpc.CallOption) (*SetGroupDependencyExpressionResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGroupDependencyExpressionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveClusterGroupDependency(ctx context.Context, in *RemoveClusterGroupDependencyRequest, opts ...dcerpc.CallOption) (*RemoveClusterGroupDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveClusterGroupDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) SetGroupSetDependencyExpression(ctx context.Context, in *SetGroupSetDependencyExpressionRequest, opts ...dcerpc.CallOption) (*SetGroupSetDependencyExpressionResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGroupSetDependencyExpressionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveGroupSetDependency(ctx context.Context, in *RemoveGroupSetDependencyRequest, opts ...dcerpc.CallOption) (*RemoveGroupSetDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveGroupSetDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) RemoveClusterGroupToGroupSetDependency(ctx context.Context, in *RemoveClusterGroupToGroupSetDependencyRequest, opts ...dcerpc.CallOption) (*RemoveClusterGroupToGroupSetDependencyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveClusterGroupToGroupSetDependencyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateGroupSetEnum(ctx context.Context, in *CreateGroupSetEnumRequest, opts ...dcerpc.CallOption) (*CreateGroupSetEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateGroupSetEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) CreateNetInterfaceEnum(ctx context.Context, in *CreateNetInterfaceEnumRequest, opts ...dcerpc.CallOption) (*CreateNetInterfaceEnumResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateNetInterfaceEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ChangeCSVStateEx(ctx context.Context, in *ChangeCSVStateExRequest, opts ...dcerpc.CallOption) (*ChangeCSVStateExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeCSVStateExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AddGroupToGroupSetEx(ctx context.Context, in *AddGroupToGroupSetExRequest, opts ...dcerpc.CallOption) (*AddGroupToGroupSetExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddGroupToGroupSetExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) ChangeResourceGroupEx(ctx context.Context, in *ChangeResourceGroupExRequest, opts ...dcerpc.CallOption) (*ChangeResourceGroupExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeResourceGroupExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultClusapi3Client) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}
func NewClusapi3Client(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (Clusapi3Client, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(Clusapi3SyntaxV3_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultClusapi3Client{cc: cc}, nil
}

// xxx_OpenClusterOperation structure represents the ApiOpenCluster operation
type xxx_OpenClusterOperation struct {
	Status uint32   `idl:"name:Status" json:"status"`
	Return *Cluster `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenClusterOperation) OpNum() int { return 0 }

func (o *xxx_OpenClusterOperation) OpName() string { return "/clusapi3/v3/ApiOpenCluster" }

func (o *xxx_OpenClusterOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_OpenClusterOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_OpenClusterOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenClusterOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Cluster{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenClusterRequest structure represents the ApiOpenCluster operation request
type OpenClusterRequest struct {
}

func (o *OpenClusterRequest) xxx_ToOp(ctx context.Context) *xxx_OpenClusterOperation {
	if o == nil {
		return &xxx_OpenClusterOperation{}
	}
	return &xxx_OpenClusterOperation{}
}

func (o *OpenClusterRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenClusterOperation) {
	if o == nil {
		return
	}
}
func (o *OpenClusterRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenClusterRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenClusterOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenClusterResponse structure represents the ApiOpenCluster operation response
type OpenClusterResponse struct {
	Status uint32 `idl:"name:Status" json:"status"`
	// Return: The ApiOpenCluster return value.
	Return *Cluster `idl:"name:Return" json:"return"`
}

func (o *OpenClusterResponse) xxx_ToOp(ctx context.Context) *xxx_OpenClusterOperation {
	if o == nil {
		return &xxx_OpenClusterOperation{}
	}
	return &xxx_OpenClusterOperation{
		Status: o.Status,
		Return: o.Return,
	}
}

func (o *OpenClusterResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenClusterOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *OpenClusterResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenClusterResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenClusterOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseClusterOperation structure represents the ApiCloseCluster operation
type xxx_CloseClusterOperation struct {
	Cluster *Cluster `idl:"name:Cluster" json:"cluster"`
	Return  uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseClusterOperation) OpNum() int { return 1 }

func (o *xxx_CloseClusterOperation) OpName() string { return "/clusapi3/v3/ApiCloseCluster" }

func (o *xxx_CloseClusterOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseClusterOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Cluster {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseClusterOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Cluster {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseClusterOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseClusterOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Cluster {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseClusterOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Cluster {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseClusterRequest structure represents the ApiCloseCluster operation request
type CloseClusterRequest struct {
	Cluster *Cluster `idl:"name:Cluster" json:"cluster"`
}

func (o *CloseClusterRequest) xxx_ToOp(ctx context.Context) *xxx_CloseClusterOperation {
	if o == nil {
		return &xxx_CloseClusterOperation{}
	}
	return &xxx_CloseClusterOperation{
		Cluster: o.Cluster,
	}
}

func (o *CloseClusterRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseClusterOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
}
func (o *CloseClusterRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseClusterRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseClusterOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseClusterResponse structure represents the ApiCloseCluster operation response
type CloseClusterResponse struct {
	Cluster *Cluster `idl:"name:Cluster" json:"cluster"`
	// Return: The ApiCloseCluster return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseClusterResponse) xxx_ToOp(ctx context.Context) *xxx_CloseClusterOperation {
	if o == nil {
		return &xxx_CloseClusterOperation{}
	}
	return &xxx_CloseClusterOperation{
		Cluster: o.Cluster,
		Return:  o.Return,
	}
}

func (o *CloseClusterResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseClusterOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.Return = op.Return
}
func (o *CloseClusterResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseClusterResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseClusterOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetClusterNameOperation structure represents the ApiSetClusterName operation
type xxx_SetClusterNameOperation struct {
	NewClusterName string `idl:"name:NewClusterName;string" json:"new_cluster_name"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetClusterNameOperation) OpNum() int { return 2 }

func (o *xxx_SetClusterNameOperation) OpName() string { return "/clusapi3/v3/ApiSetClusterName" }

func (o *xxx_SetClusterNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClusterNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// NewClusterName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NewClusterName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClusterNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// NewClusterName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NewClusterName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClusterNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClusterNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClusterNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetClusterNameRequest structure represents the ApiSetClusterName operation request
type SetClusterNameRequest struct {
	NewClusterName string `idl:"name:NewClusterName;string" json:"new_cluster_name"`
}

func (o *SetClusterNameRequest) xxx_ToOp(ctx context.Context) *xxx_SetClusterNameOperation {
	if o == nil {
		return &xxx_SetClusterNameOperation{}
	}
	return &xxx_SetClusterNameOperation{
		NewClusterName: o.NewClusterName,
	}
}

func (o *SetClusterNameRequest) xxx_FromOp(ctx context.Context, op *xxx_SetClusterNameOperation) {
	if o == nil {
		return
	}
	o.NewClusterName = op.NewClusterName
}
func (o *SetClusterNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetClusterNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetClusterNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetClusterNameResponse structure represents the ApiSetClusterName operation response
type SetClusterNameResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetClusterName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetClusterNameResponse) xxx_ToOp(ctx context.Context) *xxx_SetClusterNameOperation {
	if o == nil {
		return &xxx_SetClusterNameOperation{}
	}
	return &xxx_SetClusterNameOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetClusterNameResponse) xxx_FromOp(ctx context.Context, op *xxx_SetClusterNameOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetClusterNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetClusterNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetClusterNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClusterNameOperation structure represents the ApiGetClusterName operation
type xxx_GetClusterNameOperation struct {
	ClusterName string `idl:"name:ClusterName;string" json:"cluster_name"`
	NodeName    string `idl:"name:NodeName;string" json:"node_name"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClusterNameOperation) OpNum() int { return 3 }

func (o *xxx_GetClusterNameOperation) OpName() string { return "/clusapi3/v3/ApiGetClusterName" }

func (o *xxx_GetClusterNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetClusterNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetClusterNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClusterName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ClusterName != "" {
			_ptr_ClusterName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClusterName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClusterName, _ptr_ClusterName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.NodeName != "" {
			_ptr_NodeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.NodeName, _ptr_NodeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClusterName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ClusterName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClusterName); err != nil {
				return err
			}
			return nil
		})
		_s_ClusterName := func(ptr interface{}) { o.ClusterName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClusterName, _s_ClusterName, _ptr_ClusterName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_NodeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
				return err
			}
			return nil
		})
		_s_NodeName := func(ptr interface{}) { o.NodeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.NodeName, _s_NodeName, _ptr_NodeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClusterNameRequest structure represents the ApiGetClusterName operation request
type GetClusterNameRequest struct {
}

func (o *GetClusterNameRequest) xxx_ToOp(ctx context.Context) *xxx_GetClusterNameOperation {
	if o == nil {
		return &xxx_GetClusterNameOperation{}
	}
	return &xxx_GetClusterNameOperation{}
}

func (o *GetClusterNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetClusterNameOperation) {
	if o == nil {
		return
	}
}
func (o *GetClusterNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetClusterNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClusterNameResponse structure represents the ApiGetClusterName operation response
type GetClusterNameResponse struct {
	ClusterName string `idl:"name:ClusterName;string" json:"cluster_name"`
	NodeName    string `idl:"name:NodeName;string" json:"node_name"`
	// Return: The ApiGetClusterName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClusterNameResponse) xxx_ToOp(ctx context.Context) *xxx_GetClusterNameOperation {
	if o == nil {
		return &xxx_GetClusterNameOperation{}
	}
	return &xxx_GetClusterNameOperation{
		ClusterName: o.ClusterName,
		NodeName:    o.NodeName,
		Return:      o.Return,
	}
}

func (o *GetClusterNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetClusterNameOperation) {
	if o == nil {
		return
	}
	o.ClusterName = op.ClusterName
	o.NodeName = op.NodeName
	o.Return = op.Return
}
func (o *GetClusterNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetClusterNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClusterVersionOperation structure represents the ApiGetClusterVersion operation
type xxx_GetClusterVersionOperation struct {
	MajorVersion uint16 `idl:"name:lpwMajorVersion" json:"major_version"`
	MinorVersion uint16 `idl:"name:lpwMinorVersion" json:"minor_version"`
	BuildNumber  uint16 `idl:"name:lpwBuildNumber" json:"build_number"`
	VendorID     string `idl:"name:lpszVendorId;string" json:"vendor_id"`
	CSDVersion   string `idl:"name:lpszCSDVersion;string" json:"csd_version"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClusterVersionOperation) OpNum() int { return 4 }

func (o *xxx_GetClusterVersionOperation) OpName() string { return "/clusapi3/v3/ApiGetClusterVersion" }

func (o *xxx_GetClusterVersionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetClusterVersionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetClusterVersionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpwMajorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.MajorVersion); err != nil {
			return err
		}
	}
	// lpwMinorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.MinorVersion); err != nil {
			return err
		}
	}
	// lpwBuildNumber {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BuildNumber); err != nil {
			return err
		}
	}
	// lpszVendorId {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.VendorID != "" {
			_ptr_lpszVendorId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorID, _ptr_lpszVendorId); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpszCSDVersion {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.CSDVersion != "" {
			_ptr_lpszCSDVersion := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.CSDVersion); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.CSDVersion, _ptr_lpszCSDVersion); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpwMajorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.MajorVersion); err != nil {
			return err
		}
	}
	// lpwMinorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.MinorVersion); err != nil {
			return err
		}
	}
	// lpwBuildNumber {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BuildNumber); err != nil {
			return err
		}
	}
	// lpszVendorId {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszVendorId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorID); err != nil {
				return err
			}
			return nil
		})
		_s_lpszVendorId := func(ptr interface{}) { o.VendorID = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorID, _s_lpszVendorId, _ptr_lpszVendorId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpszCSDVersion {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszCSDVersion := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.CSDVersion); err != nil {
				return err
			}
			return nil
		})
		_s_lpszCSDVersion := func(ptr interface{}) { o.CSDVersion = *ptr.(*string) }
		if err := w.ReadPointer(&o.CSDVersion, _s_lpszCSDVersion, _ptr_lpszCSDVersion); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClusterVersionRequest structure represents the ApiGetClusterVersion operation request
type GetClusterVersionRequest struct {
}

func (o *GetClusterVersionRequest) xxx_ToOp(ctx context.Context) *xxx_GetClusterVersionOperation {
	if o == nil {
		return &xxx_GetClusterVersionOperation{}
	}
	return &xxx_GetClusterVersionOperation{}
}

func (o *GetClusterVersionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetClusterVersionOperation) {
	if o == nil {
		return
	}
}
func (o *GetClusterVersionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetClusterVersionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterVersionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClusterVersionResponse structure represents the ApiGetClusterVersion operation response
type GetClusterVersionResponse struct {
	MajorVersion uint16 `idl:"name:lpwMajorVersion" json:"major_version"`
	MinorVersion uint16 `idl:"name:lpwMinorVersion" json:"minor_version"`
	BuildNumber  uint16 `idl:"name:lpwBuildNumber" json:"build_number"`
	VendorID     string `idl:"name:lpszVendorId;string" json:"vendor_id"`
	CSDVersion   string `idl:"name:lpszCSDVersion;string" json:"csd_version"`
	// Return: The ApiGetClusterVersion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClusterVersionResponse) xxx_ToOp(ctx context.Context) *xxx_GetClusterVersionOperation {
	if o == nil {
		return &xxx_GetClusterVersionOperation{}
	}
	return &xxx_GetClusterVersionOperation{
		MajorVersion: o.MajorVersion,
		MinorVersion: o.MinorVersion,
		BuildNumber:  o.BuildNumber,
		VendorID:     o.VendorID,
		CSDVersion:   o.CSDVersion,
		Return:       o.Return,
	}
}

func (o *GetClusterVersionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetClusterVersionOperation) {
	if o == nil {
		return
	}
	o.MajorVersion = op.MajorVersion
	o.MinorVersion = op.MinorVersion
	o.BuildNumber = op.BuildNumber
	o.VendorID = op.VendorID
	o.CSDVersion = op.CSDVersion
	o.Return = op.Return
}
func (o *GetClusterVersionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetClusterVersionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterVersionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetQuorumResourceOperation structure represents the ApiGetQuorumResource operation
type xxx_GetQuorumResourceOperation struct {
	ResourceName     string `idl:"name:lpszResourceName;string" json:"resource_name"`
	DeviceName       string `idl:"name:lpszDeviceName;string" json:"device_name"`
	MaxQuorumLogSize uint32 `idl:"name:pdwMaxQuorumLogSize" json:"max_quorum_log_size"`
	RPCStatus        uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetQuorumResourceOperation) OpNum() int { return 5 }

func (o *xxx_GetQuorumResourceOperation) OpName() string { return "/clusapi3/v3/ApiGetQuorumResource" }

func (o *xxx_GetQuorumResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQuorumResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetQuorumResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetQuorumResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQuorumResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpszResourceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ResourceName != "" {
			_ptr_lpszResourceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ResourceName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ResourceName, _ptr_lpszResourceName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpszDeviceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.DeviceName != "" {
			_ptr_lpszDeviceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DeviceName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DeviceName, _ptr_lpszDeviceName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pdwMaxQuorumLogSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxQuorumLogSize); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQuorumResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpszResourceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszResourceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceName); err != nil {
				return err
			}
			return nil
		})
		_s_lpszResourceName := func(ptr interface{}) { o.ResourceName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ResourceName, _s_lpszResourceName, _ptr_lpszResourceName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpszDeviceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszDeviceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DeviceName); err != nil {
				return err
			}
			return nil
		})
		_s_lpszDeviceName := func(ptr interface{}) { o.DeviceName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DeviceName, _s_lpszDeviceName, _ptr_lpszDeviceName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pdwMaxQuorumLogSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxQuorumLogSize); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetQuorumResourceRequest structure represents the ApiGetQuorumResource operation request
type GetQuorumResourceRequest struct {
}

func (o *GetQuorumResourceRequest) xxx_ToOp(ctx context.Context) *xxx_GetQuorumResourceOperation {
	if o == nil {
		return &xxx_GetQuorumResourceOperation{}
	}
	return &xxx_GetQuorumResourceOperation{}
}

func (o *GetQuorumResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_GetQuorumResourceOperation) {
	if o == nil {
		return
	}
}
func (o *GetQuorumResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetQuorumResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetQuorumResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetQuorumResourceResponse structure represents the ApiGetQuorumResource operation response
type GetQuorumResourceResponse struct {
	ResourceName     string `idl:"name:lpszResourceName;string" json:"resource_name"`
	DeviceName       string `idl:"name:lpszDeviceName;string" json:"device_name"`
	MaxQuorumLogSize uint32 `idl:"name:pdwMaxQuorumLogSize" json:"max_quorum_log_size"`
	RPCStatus        uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetQuorumResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetQuorumResourceResponse) xxx_ToOp(ctx context.Context) *xxx_GetQuorumResourceOperation {
	if o == nil {
		return &xxx_GetQuorumResourceOperation{}
	}
	return &xxx_GetQuorumResourceOperation{
		ResourceName:     o.ResourceName,
		DeviceName:       o.DeviceName,
		MaxQuorumLogSize: o.MaxQuorumLogSize,
		RPCStatus:        o.RPCStatus,
		Return:           o.Return,
	}
}

func (o *GetQuorumResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_GetQuorumResourceOperation) {
	if o == nil {
		return
	}
	o.ResourceName = op.ResourceName
	o.DeviceName = op.DeviceName
	o.MaxQuorumLogSize = op.MaxQuorumLogSize
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetQuorumResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetQuorumResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetQuorumResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetQuorumResourceOperation structure represents the ApiSetQuorumResource operation
type xxx_SetQuorumResourceOperation struct {
	Resource         *Resource `idl:"name:hResource" json:"resource"`
	DeviceName       string    `idl:"name:lpszDeviceName;string" json:"device_name"`
	MaxQuorumLogSize uint32    `idl:"name:dwMaxQuorumLogSize" json:"max_quorum_log_size"`
	RPCStatus        uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return           uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetQuorumResourceOperation) OpNum() int { return 6 }

func (o *xxx_SetQuorumResourceOperation) OpName() string { return "/clusapi3/v3/ApiSetQuorumResource" }

func (o *xxx_SetQuorumResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQuorumResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszDeviceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.DeviceName); err != nil {
			return err
		}
	}
	// dwMaxQuorumLogSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxQuorumLogSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQuorumResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszDeviceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.DeviceName); err != nil {
			return err
		}
	}
	// dwMaxQuorumLogSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxQuorumLogSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQuorumResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQuorumResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQuorumResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetQuorumResourceRequest structure represents the ApiSetQuorumResource operation request
type SetQuorumResourceRequest struct {
	Resource         *Resource `idl:"name:hResource" json:"resource"`
	DeviceName       string    `idl:"name:lpszDeviceName;string" json:"device_name"`
	MaxQuorumLogSize uint32    `idl:"name:dwMaxQuorumLogSize" json:"max_quorum_log_size"`
}

func (o *SetQuorumResourceRequest) xxx_ToOp(ctx context.Context) *xxx_SetQuorumResourceOperation {
	if o == nil {
		return &xxx_SetQuorumResourceOperation{}
	}
	return &xxx_SetQuorumResourceOperation{
		Resource:         o.Resource,
		DeviceName:       o.DeviceName,
		MaxQuorumLogSize: o.MaxQuorumLogSize,
	}
}

func (o *SetQuorumResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_SetQuorumResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.DeviceName = op.DeviceName
	o.MaxQuorumLogSize = op.MaxQuorumLogSize
}
func (o *SetQuorumResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetQuorumResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetQuorumResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetQuorumResourceResponse structure represents the ApiSetQuorumResource operation response
type SetQuorumResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetQuorumResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetQuorumResourceResponse) xxx_ToOp(ctx context.Context) *xxx_SetQuorumResourceOperation {
	if o == nil {
		return &xxx_SetQuorumResourceOperation{}
	}
	return &xxx_SetQuorumResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetQuorumResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_SetQuorumResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetQuorumResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetQuorumResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetQuorumResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateEnumOperation structure represents the ApiCreateEnum operation
type xxx_CreateEnumOperation struct {
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateEnumOperation) OpNum() int { return 7 }

func (o *xxx_CreateEnumOperation) OpName() string { return "/clusapi3/v3/ApiCreateEnum" }

func (o *xxx_CreateEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateEnumRequest structure represents the ApiCreateEnum operation request
type CreateEnumRequest struct {
	Type uint32 `idl:"name:dwType" json:"type"`
}

func (o *CreateEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateEnumOperation {
	if o == nil {
		return &xxx_CreateEnumOperation{}
	}
	return &xxx_CreateEnumOperation{
		Type: o.Type,
	}
}

func (o *CreateEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateEnumOperation) {
	if o == nil {
		return
	}
	o.Type = op.Type
}
func (o *CreateEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateEnumResponse structure represents the ApiCreateEnum operation response
type CreateEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateEnumOperation {
	if o == nil {
		return &xxx_CreateEnumOperation{}
	}
	return &xxx_CreateEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenResourceOperation structure represents the ApiOpenResource operation
type xxx_OpenResourceOperation struct {
	ResourceName string    `idl:"name:lpszResourceName;string" json:"resource_name"`
	Status       uint32    `idl:"name:Status" json:"status"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       *Resource `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenResourceOperation) OpNum() int { return 8 }

func (o *xxx_OpenResourceOperation) OpName() string { return "/clusapi3/v3/ApiOpenResource" }

func (o *xxx_OpenResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszResourceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Resource{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenResourceRequest structure represents the ApiOpenResource operation request
type OpenResourceRequest struct {
	ResourceName string `idl:"name:lpszResourceName;string" json:"resource_name"`
}

func (o *OpenResourceRequest) xxx_ToOp(ctx context.Context) *xxx_OpenResourceOperation {
	if o == nil {
		return &xxx_OpenResourceOperation{}
	}
	return &xxx_OpenResourceOperation{
		ResourceName: o.ResourceName,
	}
}

func (o *OpenResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenResourceOperation) {
	if o == nil {
		return
	}
	o.ResourceName = op.ResourceName
}
func (o *OpenResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenResourceResponse structure represents the ApiOpenResource operation response
type OpenResourceResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenResource return value.
	Return *Resource `idl:"name:Return" json:"return"`
}

func (o *OpenResourceResponse) xxx_ToOp(ctx context.Context) *xxx_OpenResourceOperation {
	if o == nil {
		return &xxx_OpenResourceOperation{}
	}
	return &xxx_OpenResourceOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenResourceOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateResourceOperation structure represents the ApiCreateResource operation
type xxx_CreateResourceOperation struct {
	Group        *Group    `idl:"name:hGroup" json:"group"`
	ResourceName string    `idl:"name:lpszResourceName;string" json:"resource_name"`
	ResourceType string    `idl:"name:lpszResourceType;string" json:"resource_type"`
	Flags        uint32    `idl:"name:dwFlags" json:"flags"`
	Status       uint32    `idl:"name:Status" json:"status"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       *Resource `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateResourceOperation) OpNum() int { return 9 }

func (o *xxx_CreateResourceOperation) OpName() string { return "/clusapi3/v3/ApiCreateResource" }

func (o *xxx_CreateResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceName); err != nil {
			return err
		}
	}
	// lpszResourceType {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceType); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceName); err != nil {
			return err
		}
	}
	// lpszResourceType {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceType); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Resource{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateResourceRequest structure represents the ApiCreateResource operation request
type CreateResourceRequest struct {
	Group        *Group `idl:"name:hGroup" json:"group"`
	ResourceName string `idl:"name:lpszResourceName;string" json:"resource_name"`
	ResourceType string `idl:"name:lpszResourceType;string" json:"resource_type"`
	Flags        uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *CreateResourceRequest) xxx_ToOp(ctx context.Context) *xxx_CreateResourceOperation {
	if o == nil {
		return &xxx_CreateResourceOperation{}
	}
	return &xxx_CreateResourceOperation{
		Group:        o.Group,
		ResourceName: o.ResourceName,
		ResourceType: o.ResourceType,
		Flags:        o.Flags,
	}
}

func (o *CreateResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.ResourceName = op.ResourceName
	o.ResourceType = op.ResourceType
	o.Flags = op.Flags
}
func (o *CreateResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateResourceResponse structure represents the ApiCreateResource operation response
type CreateResourceResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateResource return value.
	Return *Resource `idl:"name:Return" json:"return"`
}

func (o *CreateResourceResponse) xxx_ToOp(ctx context.Context) *xxx_CreateResourceOperation {
	if o == nil {
		return &xxx_CreateResourceOperation{}
	}
	return &xxx_CreateResourceOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteResourceOperation structure represents the ApiDeleteResource operation
type xxx_DeleteResourceOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteResourceOperation) OpNum() int { return 10 }

func (o *xxx_DeleteResourceOperation) OpName() string { return "/clusapi3/v3/ApiDeleteResource" }

func (o *xxx_DeleteResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteResourceRequest structure represents the ApiDeleteResource operation request
type DeleteResourceRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *DeleteResourceRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteResourceOperation {
	if o == nil {
		return &xxx_DeleteResourceOperation{}
	}
	return &xxx_DeleteResourceOperation{
		Resource: o.Resource,
	}
}

func (o *DeleteResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *DeleteResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteResourceResponse structure represents the ApiDeleteResource operation response
type DeleteResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteResourceResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteResourceOperation {
	if o == nil {
		return &xxx_DeleteResourceOperation{}
	}
	return &xxx_DeleteResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseResourceOperation structure represents the ApiCloseResource operation
type xxx_CloseResourceOperation struct {
	Resource *Resource `idl:"name:Resource" json:"resource"`
	Return   uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseResourceOperation) OpNum() int { return 11 }

func (o *xxx_CloseResourceOperation) OpName() string { return "/clusapi3/v3/ApiCloseResource" }

func (o *xxx_CloseResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Resource {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Resource {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Resource {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Resource {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseResourceRequest structure represents the ApiCloseResource operation request
type CloseResourceRequest struct {
	Resource *Resource `idl:"name:Resource" json:"resource"`
}

func (o *CloseResourceRequest) xxx_ToOp(ctx context.Context) *xxx_CloseResourceOperation {
	if o == nil {
		return &xxx_CloseResourceOperation{}
	}
	return &xxx_CloseResourceOperation{
		Resource: o.Resource,
	}
}

func (o *CloseResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *CloseResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseResourceResponse structure represents the ApiCloseResource operation response
type CloseResourceResponse struct {
	Resource *Resource `idl:"name:Resource" json:"resource"`
	// Return: The ApiCloseResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseResourceResponse) xxx_ToOp(ctx context.Context) *xxx_CloseResourceOperation {
	if o == nil {
		return &xxx_CloseResourceOperation{}
	}
	return &xxx_CloseResourceOperation{
		Resource: o.Resource,
		Return:   o.Return,
	}
}

func (o *CloseResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Return = op.Return
}
func (o *CloseResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetResourceStateOperation structure represents the ApiGetResourceState operation
type xxx_GetResourceStateOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	State     uint32    `idl:"name:State" json:"state"`
	NodeName  string    `idl:"name:NodeName;string" json:"node_name"`
	GroupName string    `idl:"name:GroupName;string" json:"group_name"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetResourceStateOperation) OpNum() int { return 12 }

func (o *xxx_GetResourceStateOperation) OpName() string { return "/clusapi3/v3/ApiGetResourceState" }

func (o *xxx_GetResourceStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetResourceStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.NodeName != "" {
			_ptr_NodeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.NodeName, _ptr_NodeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// GroupName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GroupName != "" {
			_ptr_GroupName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupName, _ptr_GroupName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_NodeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
				return err
			}
			return nil
		})
		_s_NodeName := func(ptr interface{}) { o.NodeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.NodeName, _s_NodeName, _ptr_NodeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// GroupName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_GroupName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
				return err
			}
			return nil
		})
		_s_GroupName := func(ptr interface{}) { o.GroupName = *ptr.(*string) }
		if err := w.ReadPointer(&o.GroupName, _s_GroupName, _ptr_GroupName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetResourceStateRequest structure represents the ApiGetResourceState operation request
type GetResourceStateRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *GetResourceStateRequest) xxx_ToOp(ctx context.Context) *xxx_GetResourceStateOperation {
	if o == nil {
		return &xxx_GetResourceStateOperation{}
	}
	return &xxx_GetResourceStateOperation{
		Resource: o.Resource,
	}
}

func (o *GetResourceStateRequest) xxx_FromOp(ctx context.Context, op *xxx_GetResourceStateOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *GetResourceStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetResourceStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetResourceStateResponse structure represents the ApiGetResourceState operation response
type GetResourceStateResponse struct {
	State     uint32 `idl:"name:State" json:"state"`
	NodeName  string `idl:"name:NodeName;string" json:"node_name"`
	GroupName string `idl:"name:GroupName;string" json:"group_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetResourceState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetResourceStateResponse) xxx_ToOp(ctx context.Context) *xxx_GetResourceStateOperation {
	if o == nil {
		return &xxx_GetResourceStateOperation{}
	}
	return &xxx_GetResourceStateOperation{
		State:     o.State,
		NodeName:  o.NodeName,
		GroupName: o.GroupName,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetResourceStateResponse) xxx_FromOp(ctx context.Context, op *xxx_GetResourceStateOperation) {
	if o == nil {
		return
	}
	o.State = op.State
	o.NodeName = op.NodeName
	o.GroupName = op.GroupName
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetResourceStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetResourceStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetResourceNameOperation structure represents the ApiSetResourceName operation
type xxx_SetResourceNameOperation struct {
	Resource     *Resource `idl:"name:hResource" json:"resource"`
	ResourceName string    `idl:"name:lpszResourceName;string" json:"resource_name"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetResourceNameOperation) OpNum() int { return 13 }

func (o *xxx_SetResourceNameOperation) OpName() string { return "/clusapi3/v3/ApiSetResourceName" }

func (o *xxx_SetResourceNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetResourceNameRequest structure represents the ApiSetResourceName operation request
type SetResourceNameRequest struct {
	Resource     *Resource `idl:"name:hResource" json:"resource"`
	ResourceName string    `idl:"name:lpszResourceName;string" json:"resource_name"`
}

func (o *SetResourceNameRequest) xxx_ToOp(ctx context.Context) *xxx_SetResourceNameOperation {
	if o == nil {
		return &xxx_SetResourceNameOperation{}
	}
	return &xxx_SetResourceNameOperation{
		Resource:     o.Resource,
		ResourceName: o.ResourceName,
	}
}

func (o *SetResourceNameRequest) xxx_FromOp(ctx context.Context, op *xxx_SetResourceNameOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.ResourceName = op.ResourceName
}
func (o *SetResourceNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetResourceNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetResourceNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetResourceNameResponse structure represents the ApiSetResourceName operation response
type SetResourceNameResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetResourceName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetResourceNameResponse) xxx_ToOp(ctx context.Context) *xxx_SetResourceNameOperation {
	if o == nil {
		return &xxx_SetResourceNameOperation{}
	}
	return &xxx_SetResourceNameOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetResourceNameResponse) xxx_FromOp(ctx context.Context, op *xxx_SetResourceNameOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetResourceNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetResourceNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetResourceNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetResourceIDOperation structure represents the ApiGetResourceId operation
type xxx_GetResourceIDOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	GUID      string    `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetResourceIDOperation) OpNum() int { return 14 }

func (o *xxx_GetResourceIDOperation) OpName() string { return "/clusapi3/v3/ApiGetResourceId" }

func (o *xxx_GetResourceIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetResourceIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GUID != "" {
			_ptr_pGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GUID, _ptr_pGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
				return err
			}
			return nil
		})
		_s_pGuid := func(ptr interface{}) { o.GUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.GUID, _s_pGuid, _ptr_pGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetResourceIDRequest structure represents the ApiGetResourceId operation request
type GetResourceIDRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *GetResourceIDRequest) xxx_ToOp(ctx context.Context) *xxx_GetResourceIDOperation {
	if o == nil {
		return &xxx_GetResourceIDOperation{}
	}
	return &xxx_GetResourceIDOperation{
		Resource: o.Resource,
	}
}

func (o *GetResourceIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetResourceIDOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *GetResourceIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetResourceIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetResourceIDResponse structure represents the ApiGetResourceId operation response
type GetResourceIDResponse struct {
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetResourceId return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetResourceIDResponse) xxx_ToOp(ctx context.Context) *xxx_GetResourceIDOperation {
	if o == nil {
		return &xxx_GetResourceIDOperation{}
	}
	return &xxx_GetResourceIDOperation{
		GUID:      o.GUID,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetResourceIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetResourceIDOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetResourceIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetResourceIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetResourceTypeOperation structure represents the ApiGetResourceType operation
type xxx_GetResourceTypeOperation struct {
	Resource     *Resource `idl:"name:hResource" json:"resource"`
	ResourceType string    `idl:"name:lpszResourceType;string" json:"resource_type"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetResourceTypeOperation) OpNum() int { return 15 }

func (o *xxx_GetResourceTypeOperation) OpName() string { return "/clusapi3/v3/ApiGetResourceType" }

func (o *xxx_GetResourceTypeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceTypeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetResourceTypeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceTypeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceTypeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpszResourceType {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ResourceType != "" {
			_ptr_lpszResourceType := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ResourceType); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ResourceType, _ptr_lpszResourceType); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceTypeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpszResourceType {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszResourceType := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceType); err != nil {
				return err
			}
			return nil
		})
		_s_lpszResourceType := func(ptr interface{}) { o.ResourceType = *ptr.(*string) }
		if err := w.ReadPointer(&o.ResourceType, _s_lpszResourceType, _ptr_lpszResourceType); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetResourceTypeRequest structure represents the ApiGetResourceType operation request
type GetResourceTypeRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *GetResourceTypeRequest) xxx_ToOp(ctx context.Context) *xxx_GetResourceTypeOperation {
	if o == nil {
		return &xxx_GetResourceTypeOperation{}
	}
	return &xxx_GetResourceTypeOperation{
		Resource: o.Resource,
	}
}

func (o *GetResourceTypeRequest) xxx_FromOp(ctx context.Context, op *xxx_GetResourceTypeOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *GetResourceTypeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetResourceTypeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceTypeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetResourceTypeResponse structure represents the ApiGetResourceType operation response
type GetResourceTypeResponse struct {
	ResourceType string `idl:"name:lpszResourceType;string" json:"resource_type"`
	RPCStatus    uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetResourceType return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetResourceTypeResponse) xxx_ToOp(ctx context.Context) *xxx_GetResourceTypeOperation {
	if o == nil {
		return &xxx_GetResourceTypeOperation{}
	}
	return &xxx_GetResourceTypeOperation{
		ResourceType: o.ResourceType,
		RPCStatus:    o.RPCStatus,
		Return:       o.Return,
	}
}

func (o *GetResourceTypeResponse) xxx_FromOp(ctx context.Context, op *xxx_GetResourceTypeOperation) {
	if o == nil {
		return
	}
	o.ResourceType = op.ResourceType
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetResourceTypeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetResourceTypeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceTypeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailResourceOperation structure represents the ApiFailResource operation
type xxx_FailResourceOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_FailResourceOperation) OpNum() int { return 16 }

func (o *xxx_FailResourceOperation) OpName() string { return "/clusapi3/v3/ApiFailResource" }

func (o *xxx_FailResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_FailResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailResourceRequest structure represents the ApiFailResource operation request
type FailResourceRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *FailResourceRequest) xxx_ToOp(ctx context.Context) *xxx_FailResourceOperation {
	if o == nil {
		return &xxx_FailResourceOperation{}
	}
	return &xxx_FailResourceOperation{
		Resource: o.Resource,
	}
}

func (o *FailResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_FailResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *FailResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *FailResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailResourceResponse structure represents the ApiFailResource operation response
type FailResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiFailResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailResourceResponse) xxx_ToOp(ctx context.Context) *xxx_FailResourceOperation {
	if o == nil {
		return &xxx_FailResourceOperation{}
	}
	return &xxx_FailResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *FailResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_FailResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *FailResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *FailResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OnlineResourceOperation structure represents the ApiOnlineResource operation
type xxx_OnlineResourceOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_OnlineResourceOperation) OpNum() int { return 17 }

func (o *xxx_OnlineResourceOperation) OpName() string { return "/clusapi3/v3/ApiOnlineResource" }

func (o *xxx_OnlineResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OnlineResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OnlineResourceRequest structure represents the ApiOnlineResource operation request
type OnlineResourceRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *OnlineResourceRequest) xxx_ToOp(ctx context.Context) *xxx_OnlineResourceOperation {
	if o == nil {
		return &xxx_OnlineResourceOperation{}
	}
	return &xxx_OnlineResourceOperation{
		Resource: o.Resource,
	}
}

func (o *OnlineResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_OnlineResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *OnlineResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OnlineResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OnlineResourceResponse structure represents the ApiOnlineResource operation response
type OnlineResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOnlineResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OnlineResourceResponse) xxx_ToOp(ctx context.Context) *xxx_OnlineResourceOperation {
	if o == nil {
		return &xxx_OnlineResourceOperation{}
	}
	return &xxx_OnlineResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OnlineResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_OnlineResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OnlineResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OnlineResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OfflineResourceOperation structure represents the ApiOfflineResource operation
type xxx_OfflineResourceOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_OfflineResourceOperation) OpNum() int { return 18 }

func (o *xxx_OfflineResourceOperation) OpName() string { return "/clusapi3/v3/ApiOfflineResource" }

func (o *xxx_OfflineResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OfflineResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OfflineResourceRequest structure represents the ApiOfflineResource operation request
type OfflineResourceRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *OfflineResourceRequest) xxx_ToOp(ctx context.Context) *xxx_OfflineResourceOperation {
	if o == nil {
		return &xxx_OfflineResourceOperation{}
	}
	return &xxx_OfflineResourceOperation{
		Resource: o.Resource,
	}
}

func (o *OfflineResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_OfflineResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *OfflineResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OfflineResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OfflineResourceResponse structure represents the ApiOfflineResource operation response
type OfflineResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOfflineResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OfflineResourceResponse) xxx_ToOp(ctx context.Context) *xxx_OfflineResourceOperation {
	if o == nil {
		return &xxx_OfflineResourceOperation{}
	}
	return &xxx_OfflineResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OfflineResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_OfflineResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OfflineResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OfflineResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddResourceDependencyOperation structure represents the ApiAddResourceDependency operation
type xxx_AddResourceDependencyOperation struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	DepdendsOn *Resource `idl:"name:hDependsOn" json:"depdends_on"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddResourceDependencyOperation) OpNum() int { return 19 }

func (o *xxx_AddResourceDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiAddResourceDependency"
}

func (o *xxx_AddResourceDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn != nil {
			if err := o.DepdendsOn.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddResourceDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn == nil {
			o.DepdendsOn = &Resource{}
		}
		if err := o.DepdendsOn.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddResourceDependencyRequest structure represents the ApiAddResourceDependency operation request
type AddResourceDependencyRequest struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	DepdendsOn *Resource `idl:"name:hDependsOn" json:"depdends_on"`
}

func (o *AddResourceDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_AddResourceDependencyOperation {
	if o == nil {
		return &xxx_AddResourceDependencyOperation{}
	}
	return &xxx_AddResourceDependencyOperation{
		Resource:   o.Resource,
		DepdendsOn: o.DepdendsOn,
	}
}

func (o *AddResourceDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_AddResourceDependencyOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.DepdendsOn = op.DepdendsOn
}
func (o *AddResourceDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddResourceDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddResourceDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddResourceDependencyResponse structure represents the ApiAddResourceDependency operation response
type AddResourceDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddResourceDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddResourceDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_AddResourceDependencyOperation {
	if o == nil {
		return &xxx_AddResourceDependencyOperation{}
	}
	return &xxx_AddResourceDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddResourceDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_AddResourceDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddResourceDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddResourceDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddResourceDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveResourceDependencyOperation structure represents the ApiRemoveResourceDependency operation
type xxx_RemoveResourceDependencyOperation struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	DepdendsOn *Resource `idl:"name:hDependsOn" json:"depdends_on"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveResourceDependencyOperation) OpNum() int { return 20 }

func (o *xxx_RemoveResourceDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveResourceDependency"
}

func (o *xxx_RemoveResourceDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn != nil {
			if err := o.DepdendsOn.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveResourceDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn == nil {
			o.DepdendsOn = &Resource{}
		}
		if err := o.DepdendsOn.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveResourceDependencyRequest structure represents the ApiRemoveResourceDependency operation request
type RemoveResourceDependencyRequest struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	DepdendsOn *Resource `idl:"name:hDependsOn" json:"depdends_on"`
}

func (o *RemoveResourceDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveResourceDependencyOperation {
	if o == nil {
		return &xxx_RemoveResourceDependencyOperation{}
	}
	return &xxx_RemoveResourceDependencyOperation{
		Resource:   o.Resource,
		DepdendsOn: o.DepdendsOn,
	}
}

func (o *RemoveResourceDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveResourceDependencyOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.DepdendsOn = op.DepdendsOn
}
func (o *RemoveResourceDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveResourceDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveResourceDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveResourceDependencyResponse structure represents the ApiRemoveResourceDependency operation response
type RemoveResourceDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveResourceDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveResourceDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveResourceDependencyOperation {
	if o == nil {
		return &xxx_RemoveResourceDependencyOperation{}
	}
	return &xxx_RemoveResourceDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveResourceDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveResourceDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveResourceDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveResourceDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveResourceDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CanResourceBeDependentOperation structure represents the ApiCanResourceBeDependent operation
type xxx_CanResourceBeDependentOperation struct {
	Resource          *Resource `idl:"name:hResource" json:"resource"`
	ResourceDependent *Resource `idl:"name:hResourceDependent" json:"resource_dependent"`
	RPCStatus         uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return            uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CanResourceBeDependentOperation) OpNum() int { return 21 }

func (o *xxx_CanResourceBeDependentOperation) OpName() string {
	return "/clusapi3/v3/ApiCanResourceBeDependent"
}

func (o *xxx_CanResourceBeDependentOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CanResourceBeDependentOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hResourceDependent {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.ResourceDependent != nil {
			if err := o.ResourceDependent.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CanResourceBeDependentOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hResourceDependent {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.ResourceDependent == nil {
			o.ResourceDependent = &Resource{}
		}
		if err := o.ResourceDependent.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CanResourceBeDependentOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CanResourceBeDependentOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CanResourceBeDependentOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CanResourceBeDependentRequest structure represents the ApiCanResourceBeDependent operation request
type CanResourceBeDependentRequest struct {
	Resource          *Resource `idl:"name:hResource" json:"resource"`
	ResourceDependent *Resource `idl:"name:hResourceDependent" json:"resource_dependent"`
}

func (o *CanResourceBeDependentRequest) xxx_ToOp(ctx context.Context) *xxx_CanResourceBeDependentOperation {
	if o == nil {
		return &xxx_CanResourceBeDependentOperation{}
	}
	return &xxx_CanResourceBeDependentOperation{
		Resource:          o.Resource,
		ResourceDependent: o.ResourceDependent,
	}
}

func (o *CanResourceBeDependentRequest) xxx_FromOp(ctx context.Context, op *xxx_CanResourceBeDependentOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.ResourceDependent = op.ResourceDependent
}
func (o *CanResourceBeDependentRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CanResourceBeDependentRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CanResourceBeDependentOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CanResourceBeDependentResponse structure represents the ApiCanResourceBeDependent operation response
type CanResourceBeDependentResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCanResourceBeDependent return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CanResourceBeDependentResponse) xxx_ToOp(ctx context.Context) *xxx_CanResourceBeDependentOperation {
	if o == nil {
		return &xxx_CanResourceBeDependentOperation{}
	}
	return &xxx_CanResourceBeDependentOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CanResourceBeDependentResponse) xxx_FromOp(ctx context.Context, op *xxx_CanResourceBeDependentOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CanResourceBeDependentResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CanResourceBeDependentResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CanResourceBeDependentOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateRestrictionEnumOperation structure represents the ApiCreateResEnum operation
type xxx_CreateRestrictionEnumOperation struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateRestrictionEnumOperation) OpNum() int { return 22 }

func (o *xxx_CreateRestrictionEnumOperation) OpName() string { return "/clusapi3/v3/ApiCreateResEnum" }

func (o *xxx_CreateRestrictionEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateRestrictionEnumRequest structure represents the ApiCreateResEnum operation request
type CreateRestrictionEnumRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
	Type     uint32    `idl:"name:dwType" json:"type"`
}

func (o *CreateRestrictionEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateRestrictionEnumOperation {
	if o == nil {
		return &xxx_CreateRestrictionEnumOperation{}
	}
	return &xxx_CreateRestrictionEnumOperation{
		Resource: o.Resource,
		Type:     o.Type,
	}
}

func (o *CreateRestrictionEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateRestrictionEnumOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Type = op.Type
}
func (o *CreateRestrictionEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateRestrictionEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateRestrictionEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateRestrictionEnumResponse structure represents the ApiCreateResEnum operation response
type CreateRestrictionEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateResEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateRestrictionEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateRestrictionEnumOperation {
	if o == nil {
		return &xxx_CreateRestrictionEnumOperation{}
	}
	return &xxx_CreateRestrictionEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateRestrictionEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateRestrictionEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateRestrictionEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateRestrictionEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateRestrictionEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddResourceNodeOperation structure represents the ApiAddResourceNode operation
type xxx_AddResourceNodeOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Node      *Node     `idl:"name:hNode" json:"node"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddResourceNodeOperation) OpNum() int { return 23 }

func (o *xxx_AddResourceNodeOperation) OpName() string { return "/clusapi3/v3/ApiAddResourceNode" }

func (o *xxx_AddResourceNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddResourceNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddResourceNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddResourceNodeRequest structure represents the ApiAddResourceNode operation request
type AddResourceNodeRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
	Node     *Node     `idl:"name:hNode" json:"node"`
}

func (o *AddResourceNodeRequest) xxx_ToOp(ctx context.Context) *xxx_AddResourceNodeOperation {
	if o == nil {
		return &xxx_AddResourceNodeOperation{}
	}
	return &xxx_AddResourceNodeOperation{
		Resource: o.Resource,
		Node:     o.Node,
	}
}

func (o *AddResourceNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_AddResourceNodeOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Node = op.Node
}
func (o *AddResourceNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddResourceNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddResourceNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddResourceNodeResponse structure represents the ApiAddResourceNode operation response
type AddResourceNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddResourceNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddResourceNodeResponse) xxx_ToOp(ctx context.Context) *xxx_AddResourceNodeOperation {
	if o == nil {
		return &xxx_AddResourceNodeOperation{}
	}
	return &xxx_AddResourceNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddResourceNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_AddResourceNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddResourceNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddResourceNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddResourceNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveResourceNodeOperation structure represents the ApiRemoveResourceNode operation
type xxx_RemoveResourceNodeOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Node      *Node     `idl:"name:hNode" json:"node"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveResourceNodeOperation) OpNum() int { return 24 }

func (o *xxx_RemoveResourceNodeOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveResourceNode"
}

func (o *xxx_RemoveResourceNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveResourceNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveResourceNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveResourceNodeRequest structure represents the ApiRemoveResourceNode operation request
type RemoveResourceNodeRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
	Node     *Node     `idl:"name:hNode" json:"node"`
}

func (o *RemoveResourceNodeRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveResourceNodeOperation {
	if o == nil {
		return &xxx_RemoveResourceNodeOperation{}
	}
	return &xxx_RemoveResourceNodeOperation{
		Resource: o.Resource,
		Node:     o.Node,
	}
}

func (o *RemoveResourceNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveResourceNodeOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Node = op.Node
}
func (o *RemoveResourceNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveResourceNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveResourceNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveResourceNodeResponse structure represents the ApiRemoveResourceNode operation response
type RemoveResourceNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveResourceNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveResourceNodeResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveResourceNodeOperation {
	if o == nil {
		return &xxx_RemoveResourceNodeOperation{}
	}
	return &xxx_RemoveResourceNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveResourceNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveResourceNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveResourceNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveResourceNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveResourceNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeResourceGroupOperation structure represents the ApiChangeResourceGroup operation
type xxx_ChangeResourceGroupOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Group     *Group    `idl:"name:hGroup" json:"group"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeResourceGroupOperation) OpNum() int { return 25 }

func (o *xxx_ChangeResourceGroupOperation) OpName() string {
	return "/clusapi3/v3/ApiChangeResourceGroup"
}

func (o *xxx_ChangeResourceGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeResourceGroupRequest structure represents the ApiChangeResourceGroup operation request
type ChangeResourceGroupRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
	Group    *Group    `idl:"name:hGroup" json:"group"`
}

func (o *ChangeResourceGroupRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeResourceGroupOperation {
	if o == nil {
		return &xxx_ChangeResourceGroupOperation{}
	}
	return &xxx_ChangeResourceGroupOperation{
		Resource: o.Resource,
		Group:    o.Group,
	}
}

func (o *ChangeResourceGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeResourceGroupOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Group = op.Group
}
func (o *ChangeResourceGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeResourceGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeResourceGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeResourceGroupResponse structure represents the ApiChangeResourceGroup operation response
type ChangeResourceGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiChangeResourceGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeResourceGroupResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeResourceGroupOperation {
	if o == nil {
		return &xxx_ChangeResourceGroupOperation{}
	}
	return &xxx_ChangeResourceGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ChangeResourceGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeResourceGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ChangeResourceGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeResourceGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeResourceGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateResourceTypeOperation structure represents the ApiCreateResourceType operation
type xxx_CreateResourceTypeOperation struct {
	TypeName    string `idl:"name:lpszTypeName;string" json:"type_name"`
	DisplayName string `idl:"name:lpszDisplayName;string" json:"display_name"`
	DLLName     string `idl:"name:lpszDllName;string" json:"dll_name"`
	LooksAlive  uint32 `idl:"name:dwLooksAlive" json:"looks_alive"`
	IsAlive     uint32 `idl:"name:dwIsAlive" json:"is_alive"`
	RPCStatus   uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateResourceTypeOperation) OpNum() int { return 26 }

func (o *xxx_CreateResourceTypeOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateResourceType"
}

func (o *xxx_CreateResourceTypeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceTypeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszTypeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.TypeName); err != nil {
			return err
		}
	}
	// lpszDisplayName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
			return err
		}
	}
	// lpszDllName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.DLLName); err != nil {
			return err
		}
	}
	// dwLooksAlive {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.LooksAlive); err != nil {
			return err
		}
	}
	// dwIsAlive {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.IsAlive); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceTypeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszTypeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.TypeName); err != nil {
			return err
		}
	}
	// lpszDisplayName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
	}
	// lpszDllName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.DLLName); err != nil {
			return err
		}
	}
	// dwLooksAlive {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.LooksAlive); err != nil {
			return err
		}
	}
	// dwIsAlive {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.IsAlive); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceTypeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceTypeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceTypeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateResourceTypeRequest structure represents the ApiCreateResourceType operation request
type CreateResourceTypeRequest struct {
	TypeName    string `idl:"name:lpszTypeName;string" json:"type_name"`
	DisplayName string `idl:"name:lpszDisplayName;string" json:"display_name"`
	DLLName     string `idl:"name:lpszDllName;string" json:"dll_name"`
	LooksAlive  uint32 `idl:"name:dwLooksAlive" json:"looks_alive"`
	IsAlive     uint32 `idl:"name:dwIsAlive" json:"is_alive"`
}

func (o *CreateResourceTypeRequest) xxx_ToOp(ctx context.Context) *xxx_CreateResourceTypeOperation {
	if o == nil {
		return &xxx_CreateResourceTypeOperation{}
	}
	return &xxx_CreateResourceTypeOperation{
		TypeName:    o.TypeName,
		DisplayName: o.DisplayName,
		DLLName:     o.DLLName,
		LooksAlive:  o.LooksAlive,
		IsAlive:     o.IsAlive,
	}
}

func (o *CreateResourceTypeRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceTypeOperation) {
	if o == nil {
		return
	}
	o.TypeName = op.TypeName
	o.DisplayName = op.DisplayName
	o.DLLName = op.DLLName
	o.LooksAlive = op.LooksAlive
	o.IsAlive = op.IsAlive
}
func (o *CreateResourceTypeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateResourceTypeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceTypeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateResourceTypeResponse structure represents the ApiCreateResourceType operation response
type CreateResourceTypeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateResourceType return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateResourceTypeResponse) xxx_ToOp(ctx context.Context) *xxx_CreateResourceTypeOperation {
	if o == nil {
		return &xxx_CreateResourceTypeOperation{}
	}
	return &xxx_CreateResourceTypeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateResourceTypeResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceTypeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateResourceTypeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateResourceTypeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceTypeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteResourceTypeOperation structure represents the ApiDeleteResourceType operation
type xxx_DeleteResourceTypeOperation struct {
	TypeName  string `idl:"name:lpszTypeName;string" json:"type_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteResourceTypeOperation) OpNum() int { return 27 }

func (o *xxx_DeleteResourceTypeOperation) OpName() string {
	return "/clusapi3/v3/ApiDeleteResourceType"
}

func (o *xxx_DeleteResourceTypeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceTypeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszTypeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.TypeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceTypeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszTypeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.TypeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceTypeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceTypeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteResourceTypeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteResourceTypeRequest structure represents the ApiDeleteResourceType operation request
type DeleteResourceTypeRequest struct {
	TypeName string `idl:"name:lpszTypeName;string" json:"type_name"`
}

func (o *DeleteResourceTypeRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteResourceTypeOperation {
	if o == nil {
		return &xxx_DeleteResourceTypeOperation{}
	}
	return &xxx_DeleteResourceTypeOperation{
		TypeName: o.TypeName,
	}
}

func (o *DeleteResourceTypeRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteResourceTypeOperation) {
	if o == nil {
		return
	}
	o.TypeName = op.TypeName
}
func (o *DeleteResourceTypeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteResourceTypeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteResourceTypeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteResourceTypeResponse structure represents the ApiDeleteResourceType operation response
type DeleteResourceTypeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteResourceType return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteResourceTypeResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteResourceTypeOperation {
	if o == nil {
		return &xxx_DeleteResourceTypeOperation{}
	}
	return &xxx_DeleteResourceTypeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteResourceTypeResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteResourceTypeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteResourceTypeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteResourceTypeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteResourceTypeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetRootKeyOperation structure represents the ApiGetRootKey operation
type xxx_GetRootKeyOperation struct {
	DesiredAccess uint32 `idl:"name:samDesired" json:"desired_access"`
	Status        uint32 `idl:"name:Status" json:"status"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Key   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetRootKeyOperation) OpNum() int { return 28 }

func (o *xxx_GetRootKeyOperation) OpName() string { return "/clusapi3/v3/ApiGetRootKey" }

func (o *xxx_GetRootKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRootKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRootKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRootKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRootKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetRootKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Key{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// GetRootKeyRequest structure represents the ApiGetRootKey operation request
type GetRootKeyRequest struct {
	DesiredAccess uint32 `idl:"name:samDesired" json:"desired_access"`
}

func (o *GetRootKeyRequest) xxx_ToOp(ctx context.Context) *xxx_GetRootKeyOperation {
	if o == nil {
		return &xxx_GetRootKeyOperation{}
	}
	return &xxx_GetRootKeyOperation{
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *GetRootKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_GetRootKeyOperation) {
	if o == nil {
		return
	}
	o.DesiredAccess = op.DesiredAccess
}
func (o *GetRootKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetRootKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRootKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetRootKeyResponse structure represents the ApiGetRootKey operation response
type GetRootKeyResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetRootKey return value.
	Return *Key `idl:"name:Return" json:"return"`
}

func (o *GetRootKeyResponse) xxx_ToOp(ctx context.Context) *xxx_GetRootKeyOperation {
	if o == nil {
		return &xxx_GetRootKeyOperation{}
	}
	return &xxx_GetRootKeyOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetRootKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_GetRootKeyOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetRootKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetRootKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRootKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateKeyOperation structure represents the ApiCreateKey operation
type xxx_CreateKeyOperation struct {
	Key                *Key                `idl:"name:hKey" json:"key"`
	SubKey             string              `idl:"name:lpSubKey;string" json:"sub_key"`
	Options            uint32              `idl:"name:dwOptions" json:"options"`
	DesiredAccess      uint32              `idl:"name:samDesired" json:"desired_access"`
	SecurityAttributes *SecurityAttributes `idl:"name:lpSecurityAttributes;pointer:unique" json:"security_attributes"`
	Disposition        uint32              `idl:"name:lpdwDisposition" json:"disposition"`
	Status             uint32              `idl:"name:Status" json:"status"`
	RPCStatus          uint32              `idl:"name:rpc_status" json:"rpc_status"`
	Return             *Key                `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateKeyOperation) OpNum() int { return 29 }

func (o *xxx_CreateKeyOperation) OpName() string { return "/clusapi3/v3/ApiCreateKey" }

func (o *xxx_CreateKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.SubKey); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Options); err != nil {
			return err
		}
	}
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// lpSecurityAttributes {in} (1:{pointer=unique, alias=PRPC_SECURITY_ATTRIBUTES}*(1))(2:{alias=RPC_SECURITY_ATTRIBUTES}(struct))
	{
		if o.SecurityAttributes != nil {
			_ptr_lpSecurityAttributes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SecurityAttributes != nil {
					if err := o.SecurityAttributes.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SecurityAttributes{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityAttributes, _ptr_lpSecurityAttributes); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.SubKey); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Options); err != nil {
			return err
		}
	}
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// lpSecurityAttributes {in} (1:{pointer=unique, alias=PRPC_SECURITY_ATTRIBUTES}*(1))(2:{alias=RPC_SECURITY_ATTRIBUTES}(struct))
	{
		_ptr_lpSecurityAttributes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SecurityAttributes == nil {
				o.SecurityAttributes = &SecurityAttributes{}
			}
			if err := o.SecurityAttributes.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_lpSecurityAttributes := func(ptr interface{}) { o.SecurityAttributes = *ptr.(**SecurityAttributes) }
		if err := w.ReadPointer(&o.SecurityAttributes, _s_lpSecurityAttributes, _ptr_lpSecurityAttributes); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwDisposition {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Disposition); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwDisposition {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Disposition); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Key{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateKeyRequest structure represents the ApiCreateKey operation request
type CreateKeyRequest struct {
	Key                *Key                `idl:"name:hKey" json:"key"`
	SubKey             string              `idl:"name:lpSubKey;string" json:"sub_key"`
	Options            uint32              `idl:"name:dwOptions" json:"options"`
	DesiredAccess      uint32              `idl:"name:samDesired" json:"desired_access"`
	SecurityAttributes *SecurityAttributes `idl:"name:lpSecurityAttributes;pointer:unique" json:"security_attributes"`
}

func (o *CreateKeyRequest) xxx_ToOp(ctx context.Context) *xxx_CreateKeyOperation {
	if o == nil {
		return &xxx_CreateKeyOperation{}
	}
	return &xxx_CreateKeyOperation{
		Key:                o.Key,
		SubKey:             o.SubKey,
		Options:            o.Options,
		DesiredAccess:      o.DesiredAccess,
		SecurityAttributes: o.SecurityAttributes,
	}
}

func (o *CreateKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.SubKey = op.SubKey
	o.Options = op.Options
	o.DesiredAccess = op.DesiredAccess
	o.SecurityAttributes = op.SecurityAttributes
}
func (o *CreateKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateKeyResponse structure represents the ApiCreateKey operation response
type CreateKeyResponse struct {
	Disposition uint32 `idl:"name:lpdwDisposition" json:"disposition"`
	Status      uint32 `idl:"name:Status" json:"status"`
	RPCStatus   uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateKey return value.
	Return *Key `idl:"name:Return" json:"return"`
}

func (o *CreateKeyResponse) xxx_ToOp(ctx context.Context) *xxx_CreateKeyOperation {
	if o == nil {
		return &xxx_CreateKeyOperation{}
	}
	return &xxx_CreateKeyOperation{
		Disposition: o.Disposition,
		Status:      o.Status,
		RPCStatus:   o.RPCStatus,
		Return:      o.Return,
	}
}

func (o *CreateKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateKeyOperation) {
	if o == nil {
		return
	}
	o.Disposition = op.Disposition
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenKeyOperation structure represents the ApiOpenKey operation
type xxx_OpenKeyOperation struct {
	Key           *Key   `idl:"name:hKey" json:"key"`
	SubKey        string `idl:"name:lpSubKey;string" json:"sub_key"`
	DesiredAccess uint32 `idl:"name:samDesired" json:"desired_access"`
	Status        uint32 `idl:"name:Status" json:"status"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Key   `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenKeyOperation) OpNum() int { return 30 }

func (o *xxx_OpenKeyOperation) OpName() string { return "/clusapi3/v3/ApiOpenKey" }

func (o *xxx_OpenKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.SubKey); err != nil {
			return err
		}
	}
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.SubKey); err != nil {
			return err
		}
	}
	// samDesired {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Key{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenKeyRequest structure represents the ApiOpenKey operation request
type OpenKeyRequest struct {
	Key           *Key   `idl:"name:hKey" json:"key"`
	SubKey        string `idl:"name:lpSubKey;string" json:"sub_key"`
	DesiredAccess uint32 `idl:"name:samDesired" json:"desired_access"`
}

func (o *OpenKeyRequest) xxx_ToOp(ctx context.Context) *xxx_OpenKeyOperation {
	if o == nil {
		return &xxx_OpenKeyOperation{}
	}
	return &xxx_OpenKeyOperation{
		Key:           o.Key,
		SubKey:        o.SubKey,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.SubKey = op.SubKey
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenKeyResponse structure represents the ApiOpenKey operation response
type OpenKeyResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenKey return value.
	Return *Key `idl:"name:Return" json:"return"`
}

func (o *OpenKeyResponse) xxx_ToOp(ctx context.Context) *xxx_OpenKeyOperation {
	if o == nil {
		return &xxx_OpenKeyOperation{}
	}
	return &xxx_OpenKeyOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenKeyOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumKeyOperation structure represents the ApiEnumKey operation
type xxx_EnumKeyOperation struct {
	Key           *Key           `idl:"name:hKey" json:"key"`
	Index         uint32         `idl:"name:dwIndex" json:"index"`
	KeyName       string         `idl:"name:KeyName;string" json:"key_name"`
	LastWriteTime *dtyp.Filetime `idl:"name:lpftLastWriteTime" json:"last_write_time"`
	RPCStatus     uint32         `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumKeyOperation) OpNum() int { return 31 }

func (o *xxx_EnumKeyOperation) OpName() string { return "/clusapi3/v3/ApiEnumKey" }

func (o *xxx_EnumKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwIndex {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Index); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwIndex {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Index); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// KeyName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.KeyName != "" {
			_ptr_KeyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.KeyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.KeyName, _ptr_KeyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpftLastWriteTime {out} (1:{pointer=ref}*(1))(2:{alias=FILETIME}(struct))
	{
		if o.LastWriteTime != nil {
			if err := o.LastWriteTime.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// KeyName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_KeyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.KeyName); err != nil {
				return err
			}
			return nil
		})
		_s_KeyName := func(ptr interface{}) { o.KeyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.KeyName, _s_KeyName, _ptr_KeyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpftLastWriteTime {out} (1:{pointer=ref}*(1))(2:{alias=FILETIME}(struct))
	{
		if o.LastWriteTime == nil {
			o.LastWriteTime = &dtyp.Filetime{}
		}
		if err := o.LastWriteTime.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumKeyRequest structure represents the ApiEnumKey operation request
type EnumKeyRequest struct {
	Key   *Key   `idl:"name:hKey" json:"key"`
	Index uint32 `idl:"name:dwIndex" json:"index"`
}

func (o *EnumKeyRequest) xxx_ToOp(ctx context.Context) *xxx_EnumKeyOperation {
	if o == nil {
		return &xxx_EnumKeyOperation{}
	}
	return &xxx_EnumKeyOperation{
		Key:   o.Key,
		Index: o.Index,
	}
}

func (o *EnumKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.Index = op.Index
}
func (o *EnumKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumKeyResponse structure represents the ApiEnumKey operation response
type EnumKeyResponse struct {
	KeyName       string         `idl:"name:KeyName;string" json:"key_name"`
	LastWriteTime *dtyp.Filetime `idl:"name:lpftLastWriteTime" json:"last_write_time"`
	RPCStatus     uint32         `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiEnumKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumKeyResponse) xxx_ToOp(ctx context.Context) *xxx_EnumKeyOperation {
	if o == nil {
		return &xxx_EnumKeyOperation{}
	}
	return &xxx_EnumKeyOperation{
		KeyName:       o.KeyName,
		LastWriteTime: o.LastWriteTime,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *EnumKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumKeyOperation) {
	if o == nil {
		return
	}
	o.KeyName = op.KeyName
	o.LastWriteTime = op.LastWriteTime
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *EnumKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetValueOperation structure represents the ApiSetValue operation
type xxx_SetValueOperation struct {
	Key        *Key   `idl:"name:hKey" json:"key"`
	ValueName  string `idl:"name:lpValueName;string" json:"value_name"`
	Type       uint32 `idl:"name:dwType" json:"type"`
	Data       []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	RPCStatus  uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetValueOperation) OpNum() int { return 32 }

func (o *xxx_SetValueOperation) OpName() string { return "/clusapi3/v3/ApiSetValue" }

func (o *xxx_SetValueOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetValueOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ValueName); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// lpData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		dimSize1 := uint64(o.DataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetValueOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ValueName); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// lpData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetValueOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetValueOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetValueOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetValueRequest structure represents the ApiSetValue operation request
type SetValueRequest struct {
	Key        *Key   `idl:"name:hKey" json:"key"`
	ValueName  string `idl:"name:lpValueName;string" json:"value_name"`
	Type       uint32 `idl:"name:dwType" json:"type"`
	Data       []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
}

func (o *SetValueRequest) xxx_ToOp(ctx context.Context) *xxx_SetValueOperation {
	if o == nil {
		return &xxx_SetValueOperation{}
	}
	return &xxx_SetValueOperation{
		Key:        o.Key,
		ValueName:  o.ValueName,
		Type:       o.Type,
		Data:       o.Data,
		DataLength: o.DataLength,
	}
}

func (o *SetValueRequest) xxx_FromOp(ctx context.Context, op *xxx_SetValueOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.ValueName = op.ValueName
	o.Type = op.Type
	o.Data = op.Data
	o.DataLength = op.DataLength
}
func (o *SetValueRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetValueRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetValueOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetValueResponse structure represents the ApiSetValue operation response
type SetValueResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetValueResponse) xxx_ToOp(ctx context.Context) *xxx_SetValueOperation {
	if o == nil {
		return &xxx_SetValueOperation{}
	}
	return &xxx_SetValueOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetValueResponse) xxx_FromOp(ctx context.Context, op *xxx_SetValueOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetValueResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetValueResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetValueOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteValueOperation structure represents the ApiDeleteValue operation
type xxx_DeleteValueOperation struct {
	Key       *Key   `idl:"name:hKey" json:"key"`
	ValueName string `idl:"name:lpValueName;string" json:"value_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteValueOperation) OpNum() int { return 33 }

func (o *xxx_DeleteValueOperation) OpName() string { return "/clusapi3/v3/ApiDeleteValue" }

func (o *xxx_DeleteValueOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteValueOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ValueName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteValueOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ValueName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteValueOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteValueOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteValueOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteValueRequest structure represents the ApiDeleteValue operation request
type DeleteValueRequest struct {
	Key       *Key   `idl:"name:hKey" json:"key"`
	ValueName string `idl:"name:lpValueName;string" json:"value_name"`
}

func (o *DeleteValueRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteValueOperation {
	if o == nil {
		return &xxx_DeleteValueOperation{}
	}
	return &xxx_DeleteValueOperation{
		Key:       o.Key,
		ValueName: o.ValueName,
	}
}

func (o *DeleteValueRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteValueOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.ValueName = op.ValueName
}
func (o *DeleteValueRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteValueRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteValueOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteValueResponse structure represents the ApiDeleteValue operation response
type DeleteValueResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteValueResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteValueOperation {
	if o == nil {
		return &xxx_DeleteValueOperation{}
	}
	return &xxx_DeleteValueOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteValueResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteValueOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteValueResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteValueResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteValueOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryValueOperation structure represents the ApiQueryValue operation
type xxx_QueryValueOperation struct {
	Key            *Key   `idl:"name:hKey" json:"key"`
	ValueName      string `idl:"name:lpValueName;string" json:"value_name"`
	ValueType      uint32 `idl:"name:lpValueType" json:"value_type"`
	Data           []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
	DataLength     uint32 `idl:"name:cbData" json:"data_length"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryValueOperation) OpNum() int { return 34 }

func (o *xxx_QueryValueOperation) OpName() string { return "/clusapi3/v3/ApiQueryValue" }

func (o *xxx_QueryValueOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryValueOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ValueName); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryValueOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpValueName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ValueName); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryValueOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryValueOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpValueType {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ValueType); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		dimSize1 := uint64(o.DataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpcbRequired {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryValueOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpValueType {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ValueType); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// lpcbRequired {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryValueRequest structure represents the ApiQueryValue operation request
type QueryValueRequest struct {
	Key        *Key   `idl:"name:hKey" json:"key"`
	ValueName  string `idl:"name:lpValueName;string" json:"value_name"`
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
}

func (o *QueryValueRequest) xxx_ToOp(ctx context.Context) *xxx_QueryValueOperation {
	if o == nil {
		return &xxx_QueryValueOperation{}
	}
	return &xxx_QueryValueOperation{
		Key:        o.Key,
		ValueName:  o.ValueName,
		DataLength: o.DataLength,
	}
}

func (o *QueryValueRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryValueOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.ValueName = op.ValueName
	o.DataLength = op.DataLength
}
func (o *QueryValueRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryValueRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryValueOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryValueResponse structure represents the ApiQueryValue operation response
type QueryValueResponse struct {
	ValueType      uint32 `idl:"name:lpValueType" json:"value_type"`
	Data           []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiQueryValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryValueResponse) xxx_ToOp(ctx context.Context) *xxx_QueryValueOperation {
	if o == nil {
		return &xxx_QueryValueOperation{}
	}
	return &xxx_QueryValueOperation{
		ValueType:      o.ValueType,
		Data:           o.Data,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *QueryValueResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryValueOperation) {
	if o == nil {
		return
	}
	o.ValueType = op.ValueType
	o.Data = op.Data
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *QueryValueResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryValueResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryValueOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteKeyOperation structure represents the ApiDeleteKey operation
type xxx_DeleteKeyOperation struct {
	Key       *Key   `idl:"name:hKey" json:"key"`
	SubKey    string `idl:"name:lpSubKey;string" json:"sub_key"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteKeyOperation) OpNum() int { return 35 }

func (o *xxx_DeleteKeyOperation) OpName() string { return "/clusapi3/v3/ApiDeleteKey" }

func (o *xxx_DeleteKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.SubKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpSubKey {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.SubKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteKeyRequest structure represents the ApiDeleteKey operation request
type DeleteKeyRequest struct {
	Key    *Key   `idl:"name:hKey" json:"key"`
	SubKey string `idl:"name:lpSubKey;string" json:"sub_key"`
}

func (o *DeleteKeyRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteKeyOperation {
	if o == nil {
		return &xxx_DeleteKeyOperation{}
	}
	return &xxx_DeleteKeyOperation{
		Key:    o.Key,
		SubKey: o.SubKey,
	}
}

func (o *DeleteKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.SubKey = op.SubKey
}
func (o *DeleteKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteKeyResponse structure represents the ApiDeleteKey operation response
type DeleteKeyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteKeyResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteKeyOperation {
	if o == nil {
		return &xxx_DeleteKeyOperation{}
	}
	return &xxx_DeleteKeyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteKeyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumValueOperation structure represents the ApiEnumValue operation
type xxx_EnumValueOperation struct {
	Key        *Key   `idl:"name:hKey" json:"key"`
	Index      uint32 `idl:"name:dwIndex" json:"index"`
	ValueName  string `idl:"name:lpValueName;string" json:"value_name"`
	Type       uint32 `idl:"name:lpType" json:"type"`
	Data       []byte `idl:"name:lpData;size_is:(lpcbData)" json:"data"`
	DataLength uint32 `idl:"name:lpcbData" json:"data_length"`
	TotalSize  uint32 `idl:"name:TotalSize" json:"total_size"`
	RPCStatus  uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumValueOperation) OpNum() int { return 36 }

func (o *xxx_EnumValueOperation) OpName() string { return "/clusapi3/v3/ApiEnumValue" }

func (o *xxx_EnumValueOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumValueOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwIndex {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Index); err != nil {
			return err
		}
	}
	// lpcbData {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumValueOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwIndex {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Index); err != nil {
			return err
		}
	}
	// lpcbData {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumValueOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumValueOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpValueName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ValueName != "" {
			_ptr_lpValueName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ValueName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ValueName, _ptr_lpValueName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpType {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=lpcbData](uchar))
	{
		dimSize1 := uint64(o.DataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpcbData {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// TotalSize {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalSize); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumValueOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpValueName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpValueName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ValueName); err != nil {
				return err
			}
			return nil
		})
		_s_lpValueName := func(ptr interface{}) { o.ValueName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ValueName, _s_lpValueName, _ptr_lpValueName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpType {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=lpcbData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// lpcbData {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// TotalSize {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalSize); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumValueRequest structure represents the ApiEnumValue operation request
type EnumValueRequest struct {
	Key        *Key   `idl:"name:hKey" json:"key"`
	Index      uint32 `idl:"name:dwIndex" json:"index"`
	DataLength uint32 `idl:"name:lpcbData" json:"data_length"`
}

func (o *EnumValueRequest) xxx_ToOp(ctx context.Context) *xxx_EnumValueOperation {
	if o == nil {
		return &xxx_EnumValueOperation{}
	}
	return &xxx_EnumValueOperation{
		Key:        o.Key,
		Index:      o.Index,
		DataLength: o.DataLength,
	}
}

func (o *EnumValueRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumValueOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.Index = op.Index
	o.DataLength = op.DataLength
}
func (o *EnumValueRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumValueRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumValueOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumValueResponse structure represents the ApiEnumValue operation response
type EnumValueResponse struct {
	ValueName  string `idl:"name:lpValueName;string" json:"value_name"`
	Type       uint32 `idl:"name:lpType" json:"type"`
	Data       []byte `idl:"name:lpData;size_is:(lpcbData)" json:"data"`
	DataLength uint32 `idl:"name:lpcbData" json:"data_length"`
	TotalSize  uint32 `idl:"name:TotalSize" json:"total_size"`
	RPCStatus  uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiEnumValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumValueResponse) xxx_ToOp(ctx context.Context) *xxx_EnumValueOperation {
	if o == nil {
		return &xxx_EnumValueOperation{}
	}
	return &xxx_EnumValueOperation{
		ValueName:  o.ValueName,
		Type:       o.Type,
		Data:       o.Data,
		DataLength: o.DataLength,
		TotalSize:  o.TotalSize,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *EnumValueResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumValueOperation) {
	if o == nil {
		return
	}
	o.ValueName = op.ValueName
	o.Type = op.Type
	o.Data = op.Data
	o.DataLength = op.DataLength
	o.TotalSize = op.TotalSize
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *EnumValueResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumValueResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumValueOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseKeyOperation structure represents the ApiCloseKey operation
type xxx_CloseKeyOperation struct {
	Key    *Key   `idl:"name:pKey" json:"key"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseKeyOperation) OpNum() int { return 37 }

func (o *xxx_CloseKeyOperation) OpName() string { return "/clusapi3/v3/ApiCloseKey" }

func (o *xxx_CloseKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pKey {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pKey {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pKey {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pKey {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseKeyRequest structure represents the ApiCloseKey operation request
type CloseKeyRequest struct {
	Key *Key `idl:"name:pKey" json:"key"`
}

func (o *CloseKeyRequest) xxx_ToOp(ctx context.Context) *xxx_CloseKeyOperation {
	if o == nil {
		return &xxx_CloseKeyOperation{}
	}
	return &xxx_CloseKeyOperation{
		Key: o.Key,
	}
}

func (o *CloseKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
}
func (o *CloseKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseKeyResponse structure represents the ApiCloseKey operation response
type CloseKeyResponse struct {
	Key *Key `idl:"name:pKey" json:"key"`
	// Return: The ApiCloseKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseKeyResponse) xxx_ToOp(ctx context.Context) *xxx_CloseKeyOperation {
	if o == nil {
		return &xxx_CloseKeyOperation{}
	}
	return &xxx_CloseKeyOperation{
		Key:    o.Key,
		Return: o.Return,
	}
}

func (o *CloseKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.Return = op.Return
}
func (o *CloseKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryInfoKeyOperation structure represents the ApiQueryInfoKey operation
type xxx_QueryInfoKeyOperation struct {
	Key                      *Key           `idl:"name:hKey" json:"key"`
	SubKeysCount             uint32         `idl:"name:lpcSubKeys" json:"sub_keys_count"`
	MaxSubKeyLength          uint32         `idl:"name:lpcbMaxSubKeyLen" json:"max_sub_key_length"`
	ValuesCount              uint32         `idl:"name:lpcValues" json:"values_count"`
	MaxValueNameLength       uint32         `idl:"name:lpcbMaxValueNameLen" json:"max_value_name_length"`
	MaxValueLength           uint32         `idl:"name:lpcbMaxValueLen" json:"max_value_length"`
	SecurityDescriptorLength uint32         `idl:"name:lpcbSecurityDescriptor" json:"security_descriptor_length"`
	LastWriteTime            *dtyp.Filetime `idl:"name:lpftLastWriteTime" json:"last_write_time"`
	RPCStatus                uint32         `idl:"name:rpc_status" json:"rpc_status"`
	Return                   uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryInfoKeyOperation) OpNum() int { return 38 }

func (o *xxx_QueryInfoKeyOperation) OpName() string { return "/clusapi3/v3/ApiQueryInfoKey" }

func (o *xxx_QueryInfoKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryInfoKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_QueryInfoKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryInfoKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryInfoKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpcSubKeys {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubKeysCount); err != nil {
			return err
		}
	}
	// lpcbMaxSubKeyLen {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxSubKeyLength); err != nil {
			return err
		}
	}
	// lpcValues {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ValuesCount); err != nil {
			return err
		}
	}
	// lpcbMaxValueNameLen {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxValueNameLength); err != nil {
			return err
		}
	}
	// lpcbMaxValueLen {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxValueLength); err != nil {
			return err
		}
	}
	// lpcbSecurityDescriptor {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityDescriptorLength); err != nil {
			return err
		}
	}
	// lpftLastWriteTime {out} (1:{alias=PFILETIME}*(1))(2:{alias=FILETIME}(struct))
	{
		if o.LastWriteTime != nil {
			if err := o.LastWriteTime.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryInfoKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpcSubKeys {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubKeysCount); err != nil {
			return err
		}
	}
	// lpcbMaxSubKeyLen {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxSubKeyLength); err != nil {
			return err
		}
	}
	// lpcValues {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ValuesCount); err != nil {
			return err
		}
	}
	// lpcbMaxValueNameLen {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxValueNameLength); err != nil {
			return err
		}
	}
	// lpcbMaxValueLen {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxValueLength); err != nil {
			return err
		}
	}
	// lpcbSecurityDescriptor {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityDescriptorLength); err != nil {
			return err
		}
	}
	// lpftLastWriteTime {out} (1:{alias=PFILETIME,pointer=ref}*(1))(2:{alias=FILETIME}(struct))
	{
		if o.LastWriteTime == nil {
			o.LastWriteTime = &dtyp.Filetime{}
		}
		if err := o.LastWriteTime.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryInfoKeyRequest structure represents the ApiQueryInfoKey operation request
type QueryInfoKeyRequest struct {
	Key *Key `idl:"name:hKey" json:"key"`
}

func (o *QueryInfoKeyRequest) xxx_ToOp(ctx context.Context) *xxx_QueryInfoKeyOperation {
	if o == nil {
		return &xxx_QueryInfoKeyOperation{}
	}
	return &xxx_QueryInfoKeyOperation{
		Key: o.Key,
	}
}

func (o *QueryInfoKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryInfoKeyOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
}
func (o *QueryInfoKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryInfoKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryInfoKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryInfoKeyResponse structure represents the ApiQueryInfoKey operation response
type QueryInfoKeyResponse struct {
	SubKeysCount             uint32         `idl:"name:lpcSubKeys" json:"sub_keys_count"`
	MaxSubKeyLength          uint32         `idl:"name:lpcbMaxSubKeyLen" json:"max_sub_key_length"`
	ValuesCount              uint32         `idl:"name:lpcValues" json:"values_count"`
	MaxValueNameLength       uint32         `idl:"name:lpcbMaxValueNameLen" json:"max_value_name_length"`
	MaxValueLength           uint32         `idl:"name:lpcbMaxValueLen" json:"max_value_length"`
	SecurityDescriptorLength uint32         `idl:"name:lpcbSecurityDescriptor" json:"security_descriptor_length"`
	LastWriteTime            *dtyp.Filetime `idl:"name:lpftLastWriteTime" json:"last_write_time"`
	RPCStatus                uint32         `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiQueryInfoKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryInfoKeyResponse) xxx_ToOp(ctx context.Context) *xxx_QueryInfoKeyOperation {
	if o == nil {
		return &xxx_QueryInfoKeyOperation{}
	}
	return &xxx_QueryInfoKeyOperation{
		SubKeysCount:             o.SubKeysCount,
		MaxSubKeyLength:          o.MaxSubKeyLength,
		ValuesCount:              o.ValuesCount,
		MaxValueNameLength:       o.MaxValueNameLength,
		MaxValueLength:           o.MaxValueLength,
		SecurityDescriptorLength: o.SecurityDescriptorLength,
		LastWriteTime:            o.LastWriteTime,
		RPCStatus:                o.RPCStatus,
		Return:                   o.Return,
	}
}

func (o *QueryInfoKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryInfoKeyOperation) {
	if o == nil {
		return
	}
	o.SubKeysCount = op.SubKeysCount
	o.MaxSubKeyLength = op.MaxSubKeyLength
	o.ValuesCount = op.ValuesCount
	o.MaxValueNameLength = op.MaxValueNameLength
	o.MaxValueLength = op.MaxValueLength
	o.SecurityDescriptorLength = op.SecurityDescriptorLength
	o.LastWriteTime = op.LastWriteTime
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *QueryInfoKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryInfoKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryInfoKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetKeySecurityOperation structure represents the ApiSetKeySecurity operation
type xxx_SetKeySecurityOperation struct {
	Key                 *Key                `idl:"name:hKey" json:"key"`
	SecurityInformation uint32              `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  *SecurityDescriptor `idl:"name:pRpcSecurityDescriptor" json:"security_descriptor"`
	RPCStatus           uint32              `idl:"name:rpc_status" json:"rpc_status"`
	Return              uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_SetKeySecurityOperation) OpNum() int { return 39 }

func (o *xxx_SetKeySecurityOperation) OpName() string { return "/clusapi3/v3/ApiSetKeySecurity" }

func (o *xxx_SetKeySecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetKeySecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SecurityInformation {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// pRpcSecurityDescriptor {in} (1:{alias=PRPC_SECURITY_DESCRIPTOR}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor != nil {
			if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetKeySecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SecurityInformation {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// pRpcSecurityDescriptor {in} (1:{alias=PRPC_SECURITY_DESCRIPTOR,pointer=ref}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor == nil {
			o.SecurityDescriptor = &SecurityDescriptor{}
		}
		if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetKeySecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetKeySecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetKeySecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetKeySecurityRequest structure represents the ApiSetKeySecurity operation request
type SetKeySecurityRequest struct {
	Key                 *Key                `idl:"name:hKey" json:"key"`
	SecurityInformation uint32              `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  *SecurityDescriptor `idl:"name:pRpcSecurityDescriptor" json:"security_descriptor"`
}

func (o *SetKeySecurityRequest) xxx_ToOp(ctx context.Context) *xxx_SetKeySecurityOperation {
	if o == nil {
		return &xxx_SetKeySecurityOperation{}
	}
	return &xxx_SetKeySecurityOperation{
		Key:                 o.Key,
		SecurityInformation: o.SecurityInformation,
		SecurityDescriptor:  o.SecurityDescriptor,
	}
}

func (o *SetKeySecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_SetKeySecurityOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
}
func (o *SetKeySecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetKeySecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetKeySecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetKeySecurityResponse structure represents the ApiSetKeySecurity operation response
type SetKeySecurityResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetKeySecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetKeySecurityResponse) xxx_ToOp(ctx context.Context) *xxx_SetKeySecurityOperation {
	if o == nil {
		return &xxx_SetKeySecurityOperation{}
	}
	return &xxx_SetKeySecurityOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetKeySecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_SetKeySecurityOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetKeySecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetKeySecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetKeySecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetKeySecurityOperation structure represents the ApiGetKeySecurity operation
type xxx_GetKeySecurityOperation struct {
	Key                 *Key                `idl:"name:hKey" json:"key"`
	SecurityInformation uint32              `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  *SecurityDescriptor `idl:"name:pRpcSecurityDescriptor" json:"security_descriptor"`
	RPCStatus           uint32              `idl:"name:rpc_status" json:"rpc_status"`
	Return              uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetKeySecurityOperation) OpNum() int { return 40 }

func (o *xxx_GetKeySecurityOperation) OpName() string { return "/clusapi3/v3/ApiGetKeySecurity" }

func (o *xxx_GetKeySecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetKeySecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SecurityInformation {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// pRpcSecurityDescriptor {in, out} (1:{alias=PRPC_SECURITY_DESCRIPTOR}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor != nil {
			if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetKeySecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SecurityInformation {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// pRpcSecurityDescriptor {in, out} (1:{alias=PRPC_SECURITY_DESCRIPTOR,pointer=ref}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor == nil {
			o.SecurityDescriptor = &SecurityDescriptor{}
		}
		if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetKeySecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetKeySecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pRpcSecurityDescriptor {in, out} (1:{alias=PRPC_SECURITY_DESCRIPTOR}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor != nil {
			if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetKeySecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pRpcSecurityDescriptor {in, out} (1:{alias=PRPC_SECURITY_DESCRIPTOR,pointer=ref}*(1))(2:{alias=RPC_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor == nil {
			o.SecurityDescriptor = &SecurityDescriptor{}
		}
		if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetKeySecurityRequest structure represents the ApiGetKeySecurity operation request
type GetKeySecurityRequest struct {
	Key                 *Key                `idl:"name:hKey" json:"key"`
	SecurityInformation uint32              `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  *SecurityDescriptor `idl:"name:pRpcSecurityDescriptor" json:"security_descriptor"`
}

func (o *GetKeySecurityRequest) xxx_ToOp(ctx context.Context) *xxx_GetKeySecurityOperation {
	if o == nil {
		return &xxx_GetKeySecurityOperation{}
	}
	return &xxx_GetKeySecurityOperation{
		Key:                 o.Key,
		SecurityInformation: o.SecurityInformation,
		SecurityDescriptor:  o.SecurityDescriptor,
	}
}

func (o *GetKeySecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_GetKeySecurityOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
}
func (o *GetKeySecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetKeySecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetKeySecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetKeySecurityResponse structure represents the ApiGetKeySecurity operation response
type GetKeySecurityResponse struct {
	SecurityDescriptor *SecurityDescriptor `idl:"name:pRpcSecurityDescriptor" json:"security_descriptor"`
	RPCStatus          uint32              `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetKeySecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetKeySecurityResponse) xxx_ToOp(ctx context.Context) *xxx_GetKeySecurityOperation {
	if o == nil {
		return &xxx_GetKeySecurityOperation{}
	}
	return &xxx_GetKeySecurityOperation{
		SecurityDescriptor: o.SecurityDescriptor,
		RPCStatus:          o.RPCStatus,
		Return:             o.Return,
	}
}

func (o *GetKeySecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_GetKeySecurityOperation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetKeySecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetKeySecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetKeySecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenGroupOperation structure represents the ApiOpenGroup operation
type xxx_OpenGroupOperation struct {
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Group `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenGroupOperation) OpNum() int { return 41 }

func (o *xxx_OpenGroupOperation) OpName() string { return "/clusapi3/v3/ApiOpenGroup" }

func (o *xxx_OpenGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Group{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenGroupRequest structure represents the ApiOpenGroup operation request
type OpenGroupRequest struct {
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
}

func (o *OpenGroupRequest) xxx_ToOp(ctx context.Context) *xxx_OpenGroupOperation {
	if o == nil {
		return &xxx_OpenGroupOperation{}
	}
	return &xxx_OpenGroupOperation{
		GroupName: o.GroupName,
	}
}

func (o *OpenGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
}
func (o *OpenGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenGroupResponse structure represents the ApiOpenGroup operation response
type OpenGroupResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenGroup return value.
	Return *Group `idl:"name:Return" json:"return"`
}

func (o *OpenGroupResponse) xxx_ToOp(ctx context.Context) *xxx_OpenGroupOperation {
	if o == nil {
		return &xxx_OpenGroupOperation{}
	}
	return &xxx_OpenGroupOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupOperation structure represents the ApiCreateGroup operation
type xxx_CreateGroupOperation struct {
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Group `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupOperation) OpNum() int { return 42 }

func (o *xxx_CreateGroupOperation) OpName() string { return "/clusapi3/v3/ApiCreateGroup" }

func (o *xxx_CreateGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Group{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupRequest structure represents the ApiCreateGroup operation request
type CreateGroupRequest struct {
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
}

func (o *CreateGroupRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupOperation {
	if o == nil {
		return &xxx_CreateGroupOperation{}
	}
	return &xxx_CreateGroupOperation{
		GroupName: o.GroupName,
	}
}

func (o *CreateGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
}
func (o *CreateGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupResponse structure represents the ApiCreateGroup operation response
type CreateGroupResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroup return value.
	Return *Group `idl:"name:Return" json:"return"`
}

func (o *CreateGroupResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupOperation {
	if o == nil {
		return &xxx_CreateGroupOperation{}
	}
	return &xxx_CreateGroupOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteGroupOperation structure represents the ApiDeleteGroup operation
type xxx_DeleteGroupOperation struct {
	Group     *Group `idl:"name:Group" json:"group"`
	Force     bool   `idl:"name:force" json:"force"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteGroupOperation) OpNum() int { return 43 }

func (o *xxx_DeleteGroupOperation) OpName() string { return "/clusapi3/v3/ApiDeleteGroup" }

func (o *xxx_DeleteGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// force {in} (1:{alias=BOOL}(int32))
	{
		if !o.Force {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// force {in} (1:{alias=BOOL}(int32))
	{
		var _bForce int32
		if err := w.ReadData(&_bForce); err != nil {
			return err
		}
		o.Force = _bForce != 0
	}
	return nil
}

func (o *xxx_DeleteGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteGroupRequest structure represents the ApiDeleteGroup operation request
type DeleteGroupRequest struct {
	Group *Group `idl:"name:Group" json:"group"`
	Force bool   `idl:"name:force" json:"force"`
}

func (o *DeleteGroupRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteGroupOperation {
	if o == nil {
		return &xxx_DeleteGroupOperation{}
	}
	return &xxx_DeleteGroupOperation{
		Group: o.Group,
		Force: o.Force,
	}
}

func (o *DeleteGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Force = op.Force
}
func (o *DeleteGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteGroupResponse structure represents the ApiDeleteGroup operation response
type DeleteGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteGroupResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteGroupOperation {
	if o == nil {
		return &xxx_DeleteGroupOperation{}
	}
	return &xxx_DeleteGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseGroupOperation structure represents the ApiCloseGroup operation
type xxx_CloseGroupOperation struct {
	Group  *Group `idl:"name:Group" json:"group"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseGroupOperation) OpNum() int { return 44 }

func (o *xxx_CloseGroupOperation) OpName() string { return "/clusapi3/v3/ApiCloseGroup" }

func (o *xxx_CloseGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Group {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Group {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Group {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Group {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseGroupRequest structure represents the ApiCloseGroup operation request
type CloseGroupRequest struct {
	Group *Group `idl:"name:Group" json:"group"`
}

func (o *CloseGroupRequest) xxx_ToOp(ctx context.Context) *xxx_CloseGroupOperation {
	if o == nil {
		return &xxx_CloseGroupOperation{}
	}
	return &xxx_CloseGroupOperation{
		Group: o.Group,
	}
}

func (o *CloseGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *CloseGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseGroupResponse structure represents the ApiCloseGroup operation response
type CloseGroupResponse struct {
	Group *Group `idl:"name:Group" json:"group"`
	// Return: The ApiCloseGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseGroupResponse) xxx_ToOp(ctx context.Context) *xxx_CloseGroupOperation {
	if o == nil {
		return &xxx_CloseGroupOperation{}
	}
	return &xxx_CloseGroupOperation{
		Group:  o.Group,
		Return: o.Return,
	}
}

func (o *CloseGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Return = op.Return
}
func (o *CloseGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetGroupStateOperation structure represents the ApiGetGroupState operation
type xxx_GetGroupStateOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	State     uint32 `idl:"name:State" json:"state"`
	NodeName  string `idl:"name:NodeName;string" json:"node_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetGroupStateOperation) OpNum() int { return 45 }

func (o *xxx_GetGroupStateOperation) OpName() string { return "/clusapi3/v3/ApiGetGroupState" }

func (o *xxx_GetGroupStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetGroupStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.NodeName != "" {
			_ptr_NodeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.NodeName, _ptr_NodeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// NodeName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_NodeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
				return err
			}
			return nil
		})
		_s_NodeName := func(ptr interface{}) { o.NodeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.NodeName, _s_NodeName, _ptr_NodeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetGroupStateRequest structure represents the ApiGetGroupState operation request
type GetGroupStateRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
}

func (o *GetGroupStateRequest) xxx_ToOp(ctx context.Context) *xxx_GetGroupStateOperation {
	if o == nil {
		return &xxx_GetGroupStateOperation{}
	}
	return &xxx_GetGroupStateOperation{
		Group: o.Group,
	}
}

func (o *GetGroupStateRequest) xxx_FromOp(ctx context.Context, op *xxx_GetGroupStateOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *GetGroupStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetGroupStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGroupStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetGroupStateResponse structure represents the ApiGetGroupState operation response
type GetGroupStateResponse struct {
	State     uint32 `idl:"name:State" json:"state"`
	NodeName  string `idl:"name:NodeName;string" json:"node_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetGroupState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetGroupStateResponse) xxx_ToOp(ctx context.Context) *xxx_GetGroupStateOperation {
	if o == nil {
		return &xxx_GetGroupStateOperation{}
	}
	return &xxx_GetGroupStateOperation{
		State:     o.State,
		NodeName:  o.NodeName,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetGroupStateResponse) xxx_FromOp(ctx context.Context, op *xxx_GetGroupStateOperation) {
	if o == nil {
		return
	}
	o.State = op.State
	o.NodeName = op.NodeName
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetGroupStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetGroupStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGroupStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGroupNameOperation structure represents the ApiSetGroupName operation
type xxx_SetGroupNameOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGroupNameOperation) OpNum() int { return 46 }

func (o *xxx_SetGroupNameOperation) OpName() string { return "/clusapi3/v3/ApiSetGroupName" }

func (o *xxx_SetGroupNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGroupNameRequest structure represents the ApiSetGroupName operation request
type SetGroupNameRequest struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
}

func (o *SetGroupNameRequest) xxx_ToOp(ctx context.Context) *xxx_SetGroupNameOperation {
	if o == nil {
		return &xxx_SetGroupNameOperation{}
	}
	return &xxx_SetGroupNameOperation{
		Group:     o.Group,
		GroupName: o.GroupName,
	}
}

func (o *SetGroupNameRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGroupNameOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.GroupName = op.GroupName
}
func (o *SetGroupNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetGroupNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGroupNameResponse structure represents the ApiSetGroupName operation response
type SetGroupNameResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetGroupName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGroupNameResponse) xxx_ToOp(ctx context.Context) *xxx_SetGroupNameOperation {
	if o == nil {
		return &xxx_SetGroupNameOperation{}
	}
	return &xxx_SetGroupNameOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetGroupNameResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGroupNameOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetGroupNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetGroupNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetGroupIDOperation structure represents the ApiGetGroupId operation
type xxx_GetGroupIDOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetGroupIDOperation) OpNum() int { return 47 }

func (o *xxx_GetGroupIDOperation) OpName() string { return "/clusapi3/v3/ApiGetGroupId" }

func (o *xxx_GetGroupIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetGroupIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GUID != "" {
			_ptr_pGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GUID, _ptr_pGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGroupIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
				return err
			}
			return nil
		})
		_s_pGuid := func(ptr interface{}) { o.GUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.GUID, _s_pGuid, _ptr_pGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetGroupIDRequest structure represents the ApiGetGroupId operation request
type GetGroupIDRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
}

func (o *GetGroupIDRequest) xxx_ToOp(ctx context.Context) *xxx_GetGroupIDOperation {
	if o == nil {
		return &xxx_GetGroupIDOperation{}
	}
	return &xxx_GetGroupIDOperation{
		Group: o.Group,
	}
}

func (o *GetGroupIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetGroupIDOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *GetGroupIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetGroupIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGroupIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetGroupIDResponse structure represents the ApiGetGroupId operation response
type GetGroupIDResponse struct {
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetGroupId return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetGroupIDResponse) xxx_ToOp(ctx context.Context) *xxx_GetGroupIDOperation {
	if o == nil {
		return &xxx_GetGroupIDOperation{}
	}
	return &xxx_GetGroupIDOperation{
		GUID:      o.GUID,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetGroupIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetGroupIDOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetGroupIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetGroupIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGroupIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNodeIDOperation structure represents the ApiGetNodeId operation
type xxx_GetNodeIDOperation struct {
	Node      *Node  `idl:"name:hNode" json:"node"`
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNodeIDOperation) OpNum() int { return 48 }

func (o *xxx_GetNodeIDOperation) OpName() string { return "/clusapi3/v3/ApiGetNodeId" }

func (o *xxx_GetNodeIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNodeIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GUID != "" {
			_ptr_pGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GUID, _ptr_pGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
				return err
			}
			return nil
		})
		_s_pGuid := func(ptr interface{}) { o.GUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.GUID, _s_pGuid, _ptr_pGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNodeIDRequest structure represents the ApiGetNodeId operation request
type GetNodeIDRequest struct {
	Node *Node `idl:"name:hNode" json:"node"`
}

func (o *GetNodeIDRequest) xxx_ToOp(ctx context.Context) *xxx_GetNodeIDOperation {
	if o == nil {
		return &xxx_GetNodeIDOperation{}
	}
	return &xxx_GetNodeIDOperation{
		Node: o.Node,
	}
}

func (o *GetNodeIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNodeIDOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *GetNodeIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNodeIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNodeIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNodeIDResponse structure represents the ApiGetNodeId operation response
type GetNodeIDResponse struct {
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNodeId return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNodeIDResponse) xxx_ToOp(ctx context.Context) *xxx_GetNodeIDOperation {
	if o == nil {
		return &xxx_GetNodeIDOperation{}
	}
	return &xxx_GetNodeIDOperation{
		GUID:      o.GUID,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNodeIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNodeIDOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNodeIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNodeIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNodeIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OnlineGroupOperation structure represents the ApiOnlineGroup operation
type xxx_OnlineGroupOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_OnlineGroupOperation) OpNum() int { return 49 }

func (o *xxx_OnlineGroupOperation) OpName() string { return "/clusapi3/v3/ApiOnlineGroup" }

func (o *xxx_OnlineGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OnlineGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OnlineGroupRequest structure represents the ApiOnlineGroup operation request
type OnlineGroupRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
}

func (o *OnlineGroupRequest) xxx_ToOp(ctx context.Context) *xxx_OnlineGroupOperation {
	if o == nil {
		return &xxx_OnlineGroupOperation{}
	}
	return &xxx_OnlineGroupOperation{
		Group: o.Group,
	}
}

func (o *OnlineGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_OnlineGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *OnlineGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OnlineGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OnlineGroupResponse structure represents the ApiOnlineGroup operation response
type OnlineGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOnlineGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OnlineGroupResponse) xxx_ToOp(ctx context.Context) *xxx_OnlineGroupOperation {
	if o == nil {
		return &xxx_OnlineGroupOperation{}
	}
	return &xxx_OnlineGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OnlineGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_OnlineGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OnlineGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OnlineGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OfflineGroupOperation structure represents the ApiOfflineGroup operation
type xxx_OfflineGroupOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_OfflineGroupOperation) OpNum() int { return 50 }

func (o *xxx_OfflineGroupOperation) OpName() string { return "/clusapi3/v3/ApiOfflineGroup" }

func (o *xxx_OfflineGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OfflineGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OfflineGroupRequest structure represents the ApiOfflineGroup operation request
type OfflineGroupRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
}

func (o *OfflineGroupRequest) xxx_ToOp(ctx context.Context) *xxx_OfflineGroupOperation {
	if o == nil {
		return &xxx_OfflineGroupOperation{}
	}
	return &xxx_OfflineGroupOperation{
		Group: o.Group,
	}
}

func (o *OfflineGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_OfflineGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *OfflineGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OfflineGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OfflineGroupResponse structure represents the ApiOfflineGroup operation response
type OfflineGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOfflineGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OfflineGroupResponse) xxx_ToOp(ctx context.Context) *xxx_OfflineGroupOperation {
	if o == nil {
		return &xxx_OfflineGroupOperation{}
	}
	return &xxx_OfflineGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OfflineGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_OfflineGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OfflineGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OfflineGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_MoveGroupOperation structure represents the ApiMoveGroup operation
type xxx_MoveGroupOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_MoveGroupOperation) OpNum() int { return 51 }

func (o *xxx_MoveGroupOperation) OpName() string { return "/clusapi3/v3/ApiMoveGroup" }

func (o *xxx_MoveGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_MoveGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// MoveGroupRequest structure represents the ApiMoveGroup operation request
type MoveGroupRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
}

func (o *MoveGroupRequest) xxx_ToOp(ctx context.Context) *xxx_MoveGroupOperation {
	if o == nil {
		return &xxx_MoveGroupOperation{}
	}
	return &xxx_MoveGroupOperation{
		Group: o.Group,
	}
}

func (o *MoveGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *MoveGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *MoveGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// MoveGroupResponse structure represents the ApiMoveGroup operation response
type MoveGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiMoveGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *MoveGroupResponse) xxx_ToOp(ctx context.Context) *xxx_MoveGroupOperation {
	if o == nil {
		return &xxx_MoveGroupOperation{}
	}
	return &xxx_MoveGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *MoveGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *MoveGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *MoveGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_MoveGroupToNodeOperation structure represents the ApiMoveGroupToNode operation
type xxx_MoveGroupToNodeOperation struct {
	Group     *Group `idl:"name:hGroup" json:"group"`
	Node      *Node  `idl:"name:hNode" json:"node"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_MoveGroupToNodeOperation) OpNum() int { return 52 }

func (o *xxx_MoveGroupToNodeOperation) OpName() string { return "/clusapi3/v3/ApiMoveGroupToNode" }

func (o *xxx_MoveGroupToNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// MoveGroupToNodeRequest structure represents the ApiMoveGroupToNode operation request
type MoveGroupToNodeRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
	Node  *Node  `idl:"name:hNode" json:"node"`
}

func (o *MoveGroupToNodeRequest) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToNodeOperation {
	if o == nil {
		return &xxx_MoveGroupToNodeOperation{}
	}
	return &xxx_MoveGroupToNodeOperation{
		Group: o.Group,
		Node:  o.Node,
	}
}

func (o *MoveGroupToNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToNodeOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Node = op.Node
}
func (o *MoveGroupToNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *MoveGroupToNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// MoveGroupToNodeResponse structure represents the ApiMoveGroupToNode operation response
type MoveGroupToNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiMoveGroupToNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *MoveGroupToNodeResponse) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToNodeOperation {
	if o == nil {
		return &xxx_MoveGroupToNodeOperation{}
	}
	return &xxx_MoveGroupToNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *MoveGroupToNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *MoveGroupToNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *MoveGroupToNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupResourceEnumOperation structure represents the ApiCreateGroupResourceEnum operation
type xxx_CreateGroupResourceEnumOperation struct {
	Group      *Group    `idl:"name:hGroup" json:"group"`
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupResourceEnumOperation) OpNum() int { return 53 }

func (o *xxx_CreateGroupResourceEnumOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateGroupResourceEnum"
}

func (o *xxx_CreateGroupResourceEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupResourceEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupResourceEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupResourceEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupResourceEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupResourceEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupResourceEnumRequest structure represents the ApiCreateGroupResourceEnum operation request
type CreateGroupResourceEnumRequest struct {
	Group *Group `idl:"name:hGroup" json:"group"`
	Type  uint32 `idl:"name:dwType" json:"type"`
}

func (o *CreateGroupResourceEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupResourceEnumOperation {
	if o == nil {
		return &xxx_CreateGroupResourceEnumOperation{}
	}
	return &xxx_CreateGroupResourceEnumOperation{
		Group: o.Group,
		Type:  o.Type,
	}
}

func (o *CreateGroupResourceEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupResourceEnumOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Type = op.Type
}
func (o *CreateGroupResourceEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupResourceEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupResourceEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupResourceEnumResponse structure represents the ApiCreateGroupResourceEnum operation response
type CreateGroupResourceEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroupResourceEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateGroupResourceEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupResourceEnumOperation {
	if o == nil {
		return &xxx_CreateGroupResourceEnumOperation{}
	}
	return &xxx_CreateGroupResourceEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateGroupResourceEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupResourceEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupResourceEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupResourceEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupResourceEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGroupNodeListOperation structure represents the ApiSetGroupNodeList operation
type xxx_SetGroupNodeListOperation struct {
	Group      *Group   `idl:"name:hGroup" json:"group"`
	NodeList   []string `idl:"name:multiSzNodeList;size_is:(cchListSize);pointer:unique" json:"node_list"`
	ListLength uint32   `idl:"name:cchListSize" json:"list_length"`
	RPCStatus  uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGroupNodeListOperation) OpNum() int { return 54 }

func (o *xxx_SetGroupNodeListOperation) OpName() string { return "/clusapi3/v3/ApiSetGroupNodeList" }

func (o *xxx_SetGroupNodeListOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.NodeList != nil && o.ListLength == 0 {
		o.ListLength = uint32(ndr.MultiSzLen(o.NodeList))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNodeListOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// multiSzNodeList {in} (1:{multi_size, pointer=unique}*(1)[dim:0,size_is=cchListSize,string](wchar))
	{
		if o.NodeList != nil || o.ListLength > 0 {
			_ptr_multiSzNodeList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.ListLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				var _NodeList_buf []uint16
				for i1 := range o.NodeList {
					_NodeList_buf = append(_NodeList_buf, utf16.Encode([]rune(o.NodeList[i1]))...)
					_NodeList_buf = append(_NodeList_buf, uint16(0))
				}
				_NodeList_buf = append(_NodeList_buf, uint16(0))
				for i1 := range _NodeList_buf {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(_NodeList_buf[i1]); err != nil {
						return err
					}
				}
				for i1 := len(_NodeList_buf); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint16(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.NodeList, _ptr_multiSzNodeList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cchListSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ListLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNodeListOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// multiSzNodeList {in} (1:{multi_size, pointer=unique}*(1)[dim:0,size_is=cchListSize,string](wchar))
	{
		_ptr_multiSzNodeList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			var _NodeList_buf []uint16
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array _NodeList_buf", sizeInfo[0])
			}
			_NodeList_buf = make([]uint16, sizeInfo[0])
			for i1 := range _NodeList_buf {
				i1 := i1
				if err := w.ReadData(&_NodeList_buf[i1]); err != nil {
					return err
				}
			}
			_tmp_NodeList_buf := string(utf16.Decode(_NodeList_buf))
			if _tmp_NodeList_buf = strings.TrimRight(_tmp_NodeList_buf, ndr.ZeroString); _tmp_NodeList_buf != "" {
				o.NodeList = strings.Split(_tmp_NodeList_buf, ndr.ZeroString)
			}
			return nil
		})
		_s_multiSzNodeList := func(ptr interface{}) { o.NodeList = *ptr.(*[]string) }
		if err := w.ReadPointer(&o.NodeList, _s_multiSzNodeList, _ptr_multiSzNodeList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cchListSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ListLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNodeListOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNodeListOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupNodeListOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGroupNodeListRequest structure represents the ApiSetGroupNodeList operation request
type SetGroupNodeListRequest struct {
	Group      *Group   `idl:"name:hGroup" json:"group"`
	NodeList   []string `idl:"name:multiSzNodeList;size_is:(cchListSize);pointer:unique" json:"node_list"`
	ListLength uint32   `idl:"name:cchListSize" json:"list_length"`
}

func (o *SetGroupNodeListRequest) xxx_ToOp(ctx context.Context) *xxx_SetGroupNodeListOperation {
	if o == nil {
		return &xxx_SetGroupNodeListOperation{}
	}
	return &xxx_SetGroupNodeListOperation{
		Group:      o.Group,
		NodeList:   o.NodeList,
		ListLength: o.ListLength,
	}
}

func (o *SetGroupNodeListRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGroupNodeListOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.NodeList = op.NodeList
	o.ListLength = op.ListLength
}
func (o *SetGroupNodeListRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetGroupNodeListRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupNodeListOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGroupNodeListResponse structure represents the ApiSetGroupNodeList operation response
type SetGroupNodeListResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetGroupNodeList return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGroupNodeListResponse) xxx_ToOp(ctx context.Context) *xxx_SetGroupNodeListOperation {
	if o == nil {
		return &xxx_SetGroupNodeListOperation{}
	}
	return &xxx_SetGroupNodeListOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetGroupNodeListResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGroupNodeListOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetGroupNodeListResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetGroupNodeListResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupNodeListOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNotifyOperation structure represents the ApiCreateNotify operation
type xxx_CreateNotifyOperation struct {
	Status    uint32  `idl:"name:Status" json:"status"`
	RPCStatus uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Notify `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNotifyOperation) OpNum() int { return 55 }

func (o *xxx_CreateNotifyOperation) OpName() string { return "/clusapi3/v3/ApiCreateNotify" }

func (o *xxx_CreateNotifyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNotifyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_CreateNotifyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_CreateNotifyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNotifyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateNotifyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Notify{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateNotifyRequest structure represents the ApiCreateNotify operation request
type CreateNotifyRequest struct {
}

func (o *CreateNotifyRequest) xxx_ToOp(ctx context.Context) *xxx_CreateNotifyOperation {
	if o == nil {
		return &xxx_CreateNotifyOperation{}
	}
	return &xxx_CreateNotifyOperation{}
}

func (o *CreateNotifyRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateNotifyOperation) {
	if o == nil {
		return
	}
}
func (o *CreateNotifyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNotifyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNotifyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNotifyResponse structure represents the ApiCreateNotify operation response
type CreateNotifyResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNotify return value.
	Return *Notify `idl:"name:Return" json:"return"`
}

func (o *CreateNotifyResponse) xxx_ToOp(ctx context.Context) *xxx_CreateNotifyOperation {
	if o == nil {
		return &xxx_CreateNotifyOperation{}
	}
	return &xxx_CreateNotifyOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateNotifyResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateNotifyOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNotifyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNotifyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNotifyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseNotifyOperation structure represents the ApiCloseNotify operation
type xxx_CloseNotifyOperation struct {
	Notify *Notify `idl:"name:Notify" json:"notify"`
	Return uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseNotifyOperation) OpNum() int { return 56 }

func (o *xxx_CloseNotifyOperation) OpName() string { return "/clusapi3/v3/ApiCloseNotify" }

func (o *xxx_CloseNotifyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Notify {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Notify {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Notify {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Notify {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseNotifyRequest structure represents the ApiCloseNotify operation request
type CloseNotifyRequest struct {
	Notify *Notify `idl:"name:Notify" json:"notify"`
}

func (o *CloseNotifyRequest) xxx_ToOp(ctx context.Context) *xxx_CloseNotifyOperation {
	if o == nil {
		return &xxx_CloseNotifyOperation{}
	}
	return &xxx_CloseNotifyOperation{
		Notify: o.Notify,
	}
}

func (o *CloseNotifyRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseNotifyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *CloseNotifyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseNotifyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNotifyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseNotifyResponse structure represents the ApiCloseNotify operation response
type CloseNotifyResponse struct {
	Notify *Notify `idl:"name:Notify" json:"notify"`
	// Return: The ApiCloseNotify return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseNotifyResponse) xxx_ToOp(ctx context.Context) *xxx_CloseNotifyOperation {
	if o == nil {
		return &xxx_CloseNotifyOperation{}
	}
	return &xxx_CloseNotifyOperation{
		Notify: o.Notify,
		Return: o.Return,
	}
}

func (o *CloseNotifyResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseNotifyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Return = op.Return
}
func (o *CloseNotifyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseNotifyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNotifyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyClusterOperation structure represents the ApiAddNotifyCluster operation
type xxx_AddNotifyClusterOperation struct {
	Notify    *Notify  `idl:"name:hNotify" json:"notify"`
	Cluster   *Cluster `idl:"name:hCluster" json:"cluster"`
	Filter    uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
	RPCStatus uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyClusterOperation) OpNum() int { return 57 }

func (o *xxx_AddNotifyClusterOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyCluster" }

func (o *xxx_AddNotifyClusterOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyClusterOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyClusterOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyClusterOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyClusterOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyClusterOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyClusterRequest structure represents the ApiAddNotifyCluster operation request
type AddNotifyClusterRequest struct {
	Notify    *Notify  `idl:"name:hNotify" json:"notify"`
	Cluster   *Cluster `idl:"name:hCluster" json:"cluster"`
	Filter    uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyClusterRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyClusterOperation {
	if o == nil {
		return &xxx_AddNotifyClusterOperation{}
	}
	return &xxx_AddNotifyClusterOperation{
		Notify:    o.Notify,
		Cluster:   o.Cluster,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
	}
}

func (o *AddNotifyClusterRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyClusterOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Cluster = op.Cluster
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyClusterRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyClusterRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyClusterOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyClusterResponse structure represents the ApiAddNotifyCluster operation response
type AddNotifyClusterResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyCluster return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyClusterResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyClusterOperation {
	if o == nil {
		return &xxx_AddNotifyClusterOperation{}
	}
	return &xxx_AddNotifyClusterOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddNotifyClusterResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyClusterOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyClusterResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyClusterResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyClusterOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyNodeOperation structure represents the ApiAddNotifyNode operation
type xxx_AddNotifyNodeOperation struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Node          *Node   `idl:"name:hNode" json:"node"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyNodeOperation) OpNum() int { return 58 }

func (o *xxx_AddNotifyNodeOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyNode" }

func (o *xxx_AddNotifyNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyNodeRequest structure represents the ApiAddNotifyNode operation request
type AddNotifyNodeRequest struct {
	Notify    *Notify `idl:"name:hNotify" json:"notify"`
	Node      *Node   `idl:"name:hNode" json:"node"`
	Filter    uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyNodeRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNodeOperation {
	if o == nil {
		return &xxx_AddNotifyNodeOperation{}
	}
	return &xxx_AddNotifyNodeOperation{
		Notify:    o.Notify,
		Node:      o.Node,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
	}
}

func (o *AddNotifyNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNodeOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Node = op.Node
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyNodeResponse structure represents the ApiAddNotifyNode operation response
type AddNotifyNodeResponse struct {
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyNodeResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNodeOperation {
	if o == nil {
		return &xxx_AddNotifyNodeOperation{}
	}
	return &xxx_AddNotifyNodeOperation{
		StateSequence: o.StateSequence,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *AddNotifyNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNodeOperation) {
	if o == nil {
		return
	}
	o.StateSequence = op.StateSequence
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyGroupOperation structure represents the ApiAddNotifyGroup operation
type xxx_AddNotifyGroupOperation struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Group         *Group  `idl:"name:hGroup" json:"group"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyGroupOperation) OpNum() int { return 59 }

func (o *xxx_AddNotifyGroupOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyGroup" }

func (o *xxx_AddNotifyGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyGroupRequest structure represents the ApiAddNotifyGroup operation request
type AddNotifyGroupRequest struct {
	Notify    *Notify `idl:"name:hNotify" json:"notify"`
	Group     *Group  `idl:"name:hGroup" json:"group"`
	Filter    uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyGroupRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyGroupOperation {
	if o == nil {
		return &xxx_AddNotifyGroupOperation{}
	}
	return &xxx_AddNotifyGroupOperation{
		Notify:    o.Notify,
		Group:     o.Group,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
	}
}

func (o *AddNotifyGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyGroupOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Group = op.Group
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyGroupResponse structure represents the ApiAddNotifyGroup operation response
type AddNotifyGroupResponse struct {
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyGroupResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyGroupOperation {
	if o == nil {
		return &xxx_AddNotifyGroupOperation{}
	}
	return &xxx_AddNotifyGroupOperation{
		StateSequence: o.StateSequence,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *AddNotifyGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyGroupOperation) {
	if o == nil {
		return
	}
	o.StateSequence = op.StateSequence
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyResourceOperation structure represents the ApiAddNotifyResource operation
type xxx_AddNotifyResourceOperation struct {
	Notify        *Notify   `idl:"name:hNotify" json:"notify"`
	Resource      *Resource `idl:"name:hResource" json:"resource"`
	Filter        uint32    `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32    `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32    `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyResourceOperation) OpNum() int { return 60 }

func (o *xxx_AddNotifyResourceOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyResource" }

func (o *xxx_AddNotifyResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyResourceRequest structure represents the ApiAddNotifyResource operation request
type AddNotifyResourceRequest struct {
	Notify    *Notify   `idl:"name:hNotify" json:"notify"`
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Filter    uint32    `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32    `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyResourceRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyResourceOperation {
	if o == nil {
		return &xxx_AddNotifyResourceOperation{}
	}
	return &xxx_AddNotifyResourceOperation{
		Notify:    o.Notify,
		Resource:  o.Resource,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
	}
}

func (o *AddNotifyResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyResourceOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Resource = op.Resource
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyResourceResponse structure represents the ApiAddNotifyResource operation response
type AddNotifyResourceResponse struct {
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyResourceResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyResourceOperation {
	if o == nil {
		return &xxx_AddNotifyResourceOperation{}
	}
	return &xxx_AddNotifyResourceOperation{
		StateSequence: o.StateSequence,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *AddNotifyResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyResourceOperation) {
	if o == nil {
		return
	}
	o.StateSequence = op.StateSequence
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyKeyOperation structure represents the ApiAddNotifyKey operation
type xxx_AddNotifyKeyOperation struct {
	Notify       *Notify `idl:"name:hNotify" json:"notify"`
	Key          *Key    `idl:"name:hKey" json:"key"`
	NotifyKey    uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	Filter       uint32  `idl:"name:Filter" json:"filter"`
	WatchSubTree bool    `idl:"name:WatchSubTree" json:"watch_sub_tree"`
	RPCStatus    uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyKeyOperation) OpNum() int { return 61 }

func (o *xxx_AddNotifyKeyOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyKey" }

func (o *xxx_AddNotifyKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// Filter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// WatchSubTree {in} (1:{alias=BOOL}(int32))
	{
		if !o.WatchSubTree {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddNotifyKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// Filter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// WatchSubTree {in} (1:{alias=BOOL}(int32))
	{
		var _bWatchSubTree int32
		if err := w.ReadData(&_bWatchSubTree); err != nil {
			return err
		}
		o.WatchSubTree = _bWatchSubTree != 0
	}
	return nil
}

func (o *xxx_AddNotifyKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyKeyRequest structure represents the ApiAddNotifyKey operation request
type AddNotifyKeyRequest struct {
	Notify       *Notify `idl:"name:hNotify" json:"notify"`
	Key          *Key    `idl:"name:hKey" json:"key"`
	NotifyKey    uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	Filter       uint32  `idl:"name:Filter" json:"filter"`
	WatchSubTree bool    `idl:"name:WatchSubTree" json:"watch_sub_tree"`
}

func (o *AddNotifyKeyRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyKeyOperation {
	if o == nil {
		return &xxx_AddNotifyKeyOperation{}
	}
	return &xxx_AddNotifyKeyOperation{
		Notify:       o.Notify,
		Key:          o.Key,
		NotifyKey:    o.NotifyKey,
		Filter:       o.Filter,
		WatchSubTree: o.WatchSubTree,
	}
}

func (o *AddNotifyKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyKeyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Key = op.Key
	o.NotifyKey = op.NotifyKey
	o.Filter = op.Filter
	o.WatchSubTree = op.WatchSubTree
}
func (o *AddNotifyKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyKeyResponse structure represents the ApiAddNotifyKey operation response
type AddNotifyKeyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyKeyResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyKeyOperation {
	if o == nil {
		return &xxx_AddNotifyKeyOperation{}
	}
	return &xxx_AddNotifyKeyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddNotifyKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyKeyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReAddNotifyNodeOperation structure represents the ApiReAddNotifyNode operation
type xxx_ReAddNotifyNodeOperation struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Node          *Node   `idl:"name:hNode" json:"node"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:StateSequence" json:"state_sequence"`
	RPCStatus     uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_ReAddNotifyNodeOperation) OpNum() int { return 62 }

func (o *xxx_ReAddNotifyNodeOperation) OpName() string { return "/clusapi3/v3/ApiReAddNotifyNode" }

func (o *xxx_ReAddNotifyNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReAddNotifyNodeRequest structure represents the ApiReAddNotifyNode operation request
type ReAddNotifyNodeRequest struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Node          *Node   `idl:"name:hNode" json:"node"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:StateSequence" json:"state_sequence"`
}

func (o *ReAddNotifyNodeRequest) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNodeOperation {
	if o == nil {
		return &xxx_ReAddNotifyNodeOperation{}
	}
	return &xxx_ReAddNotifyNodeOperation{
		Notify:        o.Notify,
		Node:          o.Node,
		Filter:        o.Filter,
		NotifyKey:     o.NotifyKey,
		StateSequence: o.StateSequence,
	}
}

func (o *ReAddNotifyNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNodeOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Node = op.Node
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.StateSequence = op.StateSequence
}
func (o *ReAddNotifyNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ReAddNotifyNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReAddNotifyNodeResponse structure represents the ApiReAddNotifyNode operation response
type ReAddNotifyNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiReAddNotifyNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReAddNotifyNodeResponse) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNodeOperation {
	if o == nil {
		return &xxx_ReAddNotifyNodeOperation{}
	}
	return &xxx_ReAddNotifyNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ReAddNotifyNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ReAddNotifyNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ReAddNotifyNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReAddNotifyGroupOperation structure represents the ApiReAddNotifyGroup operation
type xxx_ReAddNotifyGroupOperation struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Group         *Group  `idl:"name:hGroup" json:"group"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:StateSequence" json:"state_sequence"`
	RPCStatus     uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_ReAddNotifyGroupOperation) OpNum() int { return 63 }

func (o *xxx_ReAddNotifyGroupOperation) OpName() string { return "/clusapi3/v3/ApiReAddNotifyGroup" }

func (o *xxx_ReAddNotifyGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReAddNotifyGroupRequest structure represents the ApiReAddNotifyGroup operation request
type ReAddNotifyGroupRequest struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	Group         *Group  `idl:"name:hGroup" json:"group"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32  `idl:"name:StateSequence" json:"state_sequence"`
}

func (o *ReAddNotifyGroupRequest) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyGroupOperation {
	if o == nil {
		return &xxx_ReAddNotifyGroupOperation{}
	}
	return &xxx_ReAddNotifyGroupOperation{
		Notify:        o.Notify,
		Group:         o.Group,
		Filter:        o.Filter,
		NotifyKey:     o.NotifyKey,
		StateSequence: o.StateSequence,
	}
}

func (o *ReAddNotifyGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyGroupOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Group = op.Group
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.StateSequence = op.StateSequence
}
func (o *ReAddNotifyGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ReAddNotifyGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReAddNotifyGroupResponse structure represents the ApiReAddNotifyGroup operation response
type ReAddNotifyGroupResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiReAddNotifyGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReAddNotifyGroupResponse) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyGroupOperation {
	if o == nil {
		return &xxx_ReAddNotifyGroupOperation{}
	}
	return &xxx_ReAddNotifyGroupOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ReAddNotifyGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyGroupOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ReAddNotifyGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ReAddNotifyGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReAddNotifyResourceOperation structure represents the ApiReAddNotifyResource operation
type xxx_ReAddNotifyResourceOperation struct {
	Notify        *Notify   `idl:"name:hNotify" json:"notify"`
	Resource      *Resource `idl:"name:hResource" json:"resource"`
	Filter        uint32    `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32    `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32    `idl:"name:StateSequence" json:"state_sequence"`
	RPCStatus     uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ReAddNotifyResourceOperation) OpNum() int { return 64 }

func (o *xxx_ReAddNotifyResourceOperation) OpName() string {
	return "/clusapi3/v3/ApiReAddNotifyResource"
}

func (o *xxx_ReAddNotifyResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReAddNotifyResourceRequest structure represents the ApiReAddNotifyResource operation request
type ReAddNotifyResourceRequest struct {
	Notify        *Notify   `idl:"name:hNotify" json:"notify"`
	Resource      *Resource `idl:"name:hResource" json:"resource"`
	Filter        uint32    `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32    `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32    `idl:"name:StateSequence" json:"state_sequence"`
}

func (o *ReAddNotifyResourceRequest) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyResourceOperation {
	if o == nil {
		return &xxx_ReAddNotifyResourceOperation{}
	}
	return &xxx_ReAddNotifyResourceOperation{
		Notify:        o.Notify,
		Resource:      o.Resource,
		Filter:        o.Filter,
		NotifyKey:     o.NotifyKey,
		StateSequence: o.StateSequence,
	}
}

func (o *ReAddNotifyResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyResourceOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Resource = op.Resource
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.StateSequence = op.StateSequence
}
func (o *ReAddNotifyResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ReAddNotifyResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReAddNotifyResourceResponse structure represents the ApiReAddNotifyResource operation response
type ReAddNotifyResourceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiReAddNotifyResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReAddNotifyResourceResponse) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyResourceOperation {
	if o == nil {
		return &xxx_ReAddNotifyResourceOperation{}
	}
	return &xxx_ReAddNotifyResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ReAddNotifyResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ReAddNotifyResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ReAddNotifyResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNotifyOperation structure represents the ApiGetNotify operation
type xxx_GetNotifyOperation struct {
	Notify        *Notify `idl:"name:hNotify" json:"notify"`
	NotifyKey     uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	Filter        uint32  `idl:"name:dwFilter" json:"filter"`
	StateSequence uint32  `idl:"name:dwStateSequence" json:"state_sequence"`
	Name          string  `idl:"name:Name;string" json:"name"`
	RPCStatus     uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNotifyOperation) OpNum() int { return 65 }

func (o *xxx_GetNotifyOperation) OpName() string { return "/clusapi3/v3/ApiGetNotify" }

func (o *xxx_GetNotifyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNotifyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwNotifyKey {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// dwFilter {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// Name {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Name != "" {
			_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwNotifyKey {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// dwFilter {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// Name {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
				return err
			}
			return nil
		})
		_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
		if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNotifyRequest structure represents the ApiGetNotify operation request
type GetNotifyRequest struct {
	Notify *Notify `idl:"name:hNotify" json:"notify"`
}

func (o *GetNotifyRequest) xxx_ToOp(ctx context.Context) *xxx_GetNotifyOperation {
	if o == nil {
		return &xxx_GetNotifyOperation{}
	}
	return &xxx_GetNotifyOperation{
		Notify: o.Notify,
	}
}

func (o *GetNotifyRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *GetNotifyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNotifyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNotifyResponse structure represents the ApiGetNotify operation response
type GetNotifyResponse struct {
	NotifyKey     uint32 `idl:"name:dwNotifyKey" json:"notify_key"`
	Filter        uint32 `idl:"name:dwFilter" json:"filter"`
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	Name          string `idl:"name:Name;string" json:"name"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNotify return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNotifyResponse) xxx_ToOp(ctx context.Context) *xxx_GetNotifyOperation {
	if o == nil {
		return &xxx_GetNotifyOperation{}
	}
	return &xxx_GetNotifyOperation{
		NotifyKey:     o.NotifyKey,
		Filter:        o.Filter,
		StateSequence: o.StateSequence,
		Name:          o.Name,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *GetNotifyResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyOperation) {
	if o == nil {
		return
	}
	o.NotifyKey = op.NotifyKey
	o.Filter = op.Filter
	o.StateSequence = op.StateSequence
	o.Name = op.Name
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNotifyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNotifyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNodeOperation structure represents the ApiOpenNode operation
type xxx_OpenNodeOperation struct {
	NodeName  string `idl:"name:lpszNodeName;string" json:"node_name"`
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Node  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNodeOperation) OpNum() int { return 66 }

func (o *xxx_OpenNodeOperation) OpName() string { return "/clusapi3/v3/ApiOpenNode" }

func (o *xxx_OpenNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNodeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNodeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Node{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNodeRequest structure represents the ApiOpenNode operation request
type OpenNodeRequest struct {
	NodeName string `idl:"name:lpszNodeName;string" json:"node_name"`
}

func (o *OpenNodeRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNodeOperation {
	if o == nil {
		return &xxx_OpenNodeOperation{}
	}
	return &xxx_OpenNodeOperation{
		NodeName: o.NodeName,
	}
}

func (o *OpenNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNodeOperation) {
	if o == nil {
		return
	}
	o.NodeName = op.NodeName
}
func (o *OpenNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNodeResponse structure represents the ApiOpenNode operation response
type OpenNodeResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNode return value.
	Return *Node `idl:"name:Return" json:"return"`
}

func (o *OpenNodeResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNodeOperation {
	if o == nil {
		return &xxx_OpenNodeOperation{}
	}
	return &xxx_OpenNodeOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNodeOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseNodeOperation structure represents the ApiCloseNode operation
type xxx_CloseNodeOperation struct {
	Node   *Node  `idl:"name:Node" json:"node"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseNodeOperation) OpNum() int { return 67 }

func (o *xxx_CloseNodeOperation) OpName() string { return "/clusapi3/v3/ApiCloseNode" }

func (o *xxx_CloseNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Node {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Node {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Node {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Node {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseNodeRequest structure represents the ApiCloseNode operation request
type CloseNodeRequest struct {
	Node *Node `idl:"name:Node" json:"node"`
}

func (o *CloseNodeRequest) xxx_ToOp(ctx context.Context) *xxx_CloseNodeOperation {
	if o == nil {
		return &xxx_CloseNodeOperation{}
	}
	return &xxx_CloseNodeOperation{
		Node: o.Node,
	}
}

func (o *CloseNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseNodeOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *CloseNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseNodeResponse structure represents the ApiCloseNode operation response
type CloseNodeResponse struct {
	Node *Node `idl:"name:Node" json:"node"`
	// Return: The ApiCloseNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseNodeResponse) xxx_ToOp(ctx context.Context) *xxx_CloseNodeOperation {
	if o == nil {
		return &xxx_CloseNodeOperation{}
	}
	return &xxx_CloseNodeOperation{
		Node:   o.Node,
		Return: o.Return,
	}
}

func (o *CloseNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseNodeOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.Return = op.Return
}
func (o *CloseNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNodeStateOperation structure represents the ApiGetNodeState operation
type xxx_GetNodeStateOperation struct {
	Node      *Node  `idl:"name:hNode" json:"node"`
	State     uint32 `idl:"name:State" json:"state"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNodeStateOperation) OpNum() int { return 68 }

func (o *xxx_GetNodeStateOperation) OpName() string { return "/clusapi3/v3/ApiGetNodeState" }

func (o *xxx_GetNodeStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNodeStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNodeStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNodeStateRequest structure represents the ApiGetNodeState operation request
type GetNodeStateRequest struct {
	Node *Node `idl:"name:hNode" json:"node"`
}

func (o *GetNodeStateRequest) xxx_ToOp(ctx context.Context) *xxx_GetNodeStateOperation {
	if o == nil {
		return &xxx_GetNodeStateOperation{}
	}
	return &xxx_GetNodeStateOperation{
		Node: o.Node,
	}
}

func (o *GetNodeStateRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNodeStateOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *GetNodeStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNodeStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNodeStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNodeStateResponse structure represents the ApiGetNodeState operation response
type GetNodeStateResponse struct {
	State     uint32 `idl:"name:State" json:"state"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNodeState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNodeStateResponse) xxx_ToOp(ctx context.Context) *xxx_GetNodeStateOperation {
	if o == nil {
		return &xxx_GetNodeStateOperation{}
	}
	return &xxx_GetNodeStateOperation{
		State:     o.State,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNodeStateResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNodeStateOperation) {
	if o == nil {
		return
	}
	o.State = op.State
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNodeStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNodeStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNodeStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PauseNodeOperation structure represents the ApiPauseNode operation
type xxx_PauseNodeOperation struct {
	Node      *Node  `idl:"name:hNode" json:"node"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_PauseNodeOperation) OpNum() int { return 69 }

func (o *xxx_PauseNodeOperation) OpName() string { return "/clusapi3/v3/ApiPauseNode" }

func (o *xxx_PauseNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_PauseNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PauseNodeRequest structure represents the ApiPauseNode operation request
type PauseNodeRequest struct {
	Node *Node `idl:"name:hNode" json:"node"`
}

func (o *PauseNodeRequest) xxx_ToOp(ctx context.Context) *xxx_PauseNodeOperation {
	if o == nil {
		return &xxx_PauseNodeOperation{}
	}
	return &xxx_PauseNodeOperation{
		Node: o.Node,
	}
}

func (o *PauseNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *PauseNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *PauseNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PauseNodeResponse structure represents the ApiPauseNode operation response
type PauseNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiPauseNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *PauseNodeResponse) xxx_ToOp(ctx context.Context) *xxx_PauseNodeOperation {
	if o == nil {
		return &xxx_PauseNodeOperation{}
	}
	return &xxx_PauseNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *PauseNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *PauseNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *PauseNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ResumeNodeOperation structure represents the ApiResumeNode operation
type xxx_ResumeNodeOperation struct {
	Node      *Node  `idl:"name:hNode" json:"node"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ResumeNodeOperation) OpNum() int { return 70 }

func (o *xxx_ResumeNodeOperation) OpName() string { return "/clusapi3/v3/ApiResumeNode" }

func (o *xxx_ResumeNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ResumeNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ResumeNodeRequest structure represents the ApiResumeNode operation request
type ResumeNodeRequest struct {
	Node *Node `idl:"name:hNode" json:"node"`
}

func (o *ResumeNodeRequest) xxx_ToOp(ctx context.Context) *xxx_ResumeNodeOperation {
	if o == nil {
		return &xxx_ResumeNodeOperation{}
	}
	return &xxx_ResumeNodeOperation{
		Node: o.Node,
	}
}

func (o *ResumeNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_ResumeNodeOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *ResumeNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ResumeNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResumeNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ResumeNodeResponse structure represents the ApiResumeNode operation response
type ResumeNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiResumeNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ResumeNodeResponse) xxx_ToOp(ctx context.Context) *xxx_ResumeNodeOperation {
	if o == nil {
		return &xxx_ResumeNodeOperation{}
	}
	return &xxx_ResumeNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ResumeNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_ResumeNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ResumeNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ResumeNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResumeNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EvictNodeOperation structure represents the ApiEvictNode operation
type xxx_EvictNodeOperation struct {
	Node      *Node  `idl:"name:hNode" json:"node"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EvictNodeOperation) OpNum() int { return 71 }

func (o *xxx_EvictNodeOperation) OpName() string { return "/clusapi3/v3/ApiEvictNode" }

func (o *xxx_EvictNodeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EvictNodeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EvictNodeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EvictNodeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EvictNodeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EvictNodeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EvictNodeRequest structure represents the ApiEvictNode operation request
type EvictNodeRequest struct {
	Node *Node `idl:"name:hNode" json:"node"`
}

func (o *EvictNodeRequest) xxx_ToOp(ctx context.Context) *xxx_EvictNodeOperation {
	if o == nil {
		return &xxx_EvictNodeOperation{}
	}
	return &xxx_EvictNodeOperation{
		Node: o.Node,
	}
}

func (o *EvictNodeRequest) xxx_FromOp(ctx context.Context, op *xxx_EvictNodeOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
}
func (o *EvictNodeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EvictNodeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EvictNodeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EvictNodeResponse structure represents the ApiEvictNode operation response
type EvictNodeResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiEvictNode return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EvictNodeResponse) xxx_ToOp(ctx context.Context) *xxx_EvictNodeOperation {
	if o == nil {
		return &xxx_EvictNodeOperation{}
	}
	return &xxx_EvictNodeOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *EvictNodeResponse) xxx_FromOp(ctx context.Context, op *xxx_EvictNodeOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *EvictNodeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EvictNodeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EvictNodeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeResourceControlOperation structure represents the ApiNodeResourceControl operation
type xxx_NodeResourceControlOperation struct {
	Resource       *Resource `idl:"name:hResource" json:"resource"`
	Node           *Node     `idl:"name:hNode" json:"node"`
	ControlCode    uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte    `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32    `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32    `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeResourceControlOperation) OpNum() int { return 72 }

func (o *xxx_NodeResourceControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeResourceControl"
}

func (o *xxx_NodeResourceControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeResourceControlRequest structure represents the ApiNodeResourceControl operation request
type NodeResourceControlRequest struct {
	Resource      *Resource `idl:"name:hResource" json:"resource"`
	Node          *Node     `idl:"name:hNode" json:"node"`
	ControlCode   uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeResourceControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeResourceControlOperation {
	if o == nil {
		return &xxx_NodeResourceControlOperation{}
	}
	return &xxx_NodeResourceControlOperation{
		Resource:      o.Resource,
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeResourceControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeResourceControlOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeResourceControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeResourceControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeResourceControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeResourceControlResponse structure represents the ApiNodeResourceControl operation response
type NodeResourceControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeResourceControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeResourceControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeResourceControlOperation {
	if o == nil {
		return &xxx_NodeResourceControlOperation{}
	}
	return &xxx_NodeResourceControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeResourceControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeResourceControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeResourceControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeResourceControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeResourceControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ResourceControlOperation structure represents the ApiResourceControl operation
type xxx_ResourceControlOperation struct {
	Resource       *Resource `idl:"name:hResource" json:"resource"`
	ControlCode    uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte    `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32    `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32    `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ResourceControlOperation) OpNum() int { return 73 }

func (o *xxx_ResourceControlOperation) OpName() string { return "/clusapi3/v3/ApiResourceControl" }

func (o *xxx_ResourceControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ResourceControlRequest structure represents the ApiResourceControl operation request
type ResourceControlRequest struct {
	Resource      *Resource `idl:"name:hResource" json:"resource"`
	ControlCode   uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *ResourceControlRequest) xxx_ToOp(ctx context.Context) *xxx_ResourceControlOperation {
	if o == nil {
		return &xxx_ResourceControlOperation{}
	}
	return &xxx_ResourceControlOperation{
		Resource:      o.Resource,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *ResourceControlRequest) xxx_FromOp(ctx context.Context, op *xxx_ResourceControlOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *ResourceControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ResourceControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResourceControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ResourceControlResponse structure represents the ApiResourceControl operation response
type ResourceControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiResourceControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ResourceControlResponse) xxx_ToOp(ctx context.Context) *xxx_ResourceControlOperation {
	if o == nil {
		return &xxx_ResourceControlOperation{}
	}
	return &xxx_ResourceControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *ResourceControlResponse) xxx_FromOp(ctx context.Context, op *xxx_ResourceControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ResourceControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ResourceControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResourceControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeResourceTypeControlOperation structure represents the ApiNodeResourceTypeControl operation
type xxx_NodeResourceTypeControlOperation struct {
	Cluster          *Cluster `idl:"name:hCluster" json:"cluster"`
	ResourceTypeName string   `idl:"name:lpszResourceTypeName;string" json:"resource_type_name"`
	Node             *Node    `idl:"name:hNode" json:"node"`
	ControlCode      uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer         []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize     uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer        []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize    uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned    uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength   uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus        uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return           uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeResourceTypeControlOperation) OpNum() int { return 74 }

func (o *xxx_NodeResourceTypeControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeResourceTypeControl"
}

func (o *xxx_NodeResourceTypeControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceTypeControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszResourceTypeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceTypeName); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceTypeControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszResourceTypeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceTypeName); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceTypeControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceTypeControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeResourceTypeControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeResourceTypeControlRequest structure represents the ApiNodeResourceTypeControl operation request
type NodeResourceTypeControlRequest struct {
	Cluster          *Cluster `idl:"name:hCluster" json:"cluster"`
	ResourceTypeName string   `idl:"name:lpszResourceTypeName;string" json:"resource_type_name"`
	Node             *Node    `idl:"name:hNode" json:"node"`
	ControlCode      uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer         []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize     uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize    uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeResourceTypeControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeResourceTypeControlOperation {
	if o == nil {
		return &xxx_NodeResourceTypeControlOperation{}
	}
	return &xxx_NodeResourceTypeControlOperation{
		Cluster:          o.Cluster,
		ResourceTypeName: o.ResourceTypeName,
		Node:             o.Node,
		ControlCode:      o.ControlCode,
		InBuffer:         o.InBuffer,
		InBufferSize:     o.InBufferSize,
		OutBufferSize:    o.OutBufferSize,
	}
}

func (o *NodeResourceTypeControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeResourceTypeControlOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.ResourceTypeName = op.ResourceTypeName
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeResourceTypeControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeResourceTypeControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeResourceTypeControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeResourceTypeControlResponse structure represents the ApiNodeResourceTypeControl operation response
type NodeResourceTypeControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeResourceTypeControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeResourceTypeControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeResourceTypeControlOperation {
	if o == nil {
		return &xxx_NodeResourceTypeControlOperation{}
	}
	return &xxx_NodeResourceTypeControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeResourceTypeControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeResourceTypeControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeResourceTypeControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeResourceTypeControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeResourceTypeControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ResourceTypeControlOperation structure represents the ApiResourceTypeControl operation
type xxx_ResourceTypeControlOperation struct {
	Cluster          *Cluster `idl:"name:hCluster" json:"cluster"`
	ResourceTypeName string   `idl:"name:lpszResourceTypeName;string" json:"resource_type_name"`
	ControlCode      uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer         []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize     uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer        []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize    uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned    uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength   uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus        uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return           uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_ResourceTypeControlOperation) OpNum() int { return 75 }

func (o *xxx_ResourceTypeControlOperation) OpName() string {
	return "/clusapi3/v3/ApiResourceTypeControl"
}

func (o *xxx_ResourceTypeControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceTypeControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszResourceTypeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceTypeName); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceTypeControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszResourceTypeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceTypeName); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceTypeControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceTypeControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResourceTypeControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ResourceTypeControlRequest structure represents the ApiResourceTypeControl operation request
type ResourceTypeControlRequest struct {
	Cluster          *Cluster `idl:"name:hCluster" json:"cluster"`
	ResourceTypeName string   `idl:"name:lpszResourceTypeName;string" json:"resource_type_name"`
	ControlCode      uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer         []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize     uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize    uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *ResourceTypeControlRequest) xxx_ToOp(ctx context.Context) *xxx_ResourceTypeControlOperation {
	if o == nil {
		return &xxx_ResourceTypeControlOperation{}
	}
	return &xxx_ResourceTypeControlOperation{
		Cluster:          o.Cluster,
		ResourceTypeName: o.ResourceTypeName,
		ControlCode:      o.ControlCode,
		InBuffer:         o.InBuffer,
		InBufferSize:     o.InBufferSize,
		OutBufferSize:    o.OutBufferSize,
	}
}

func (o *ResourceTypeControlRequest) xxx_FromOp(ctx context.Context, op *xxx_ResourceTypeControlOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.ResourceTypeName = op.ResourceTypeName
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *ResourceTypeControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ResourceTypeControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResourceTypeControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ResourceTypeControlResponse structure represents the ApiResourceTypeControl operation response
type ResourceTypeControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiResourceTypeControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ResourceTypeControlResponse) xxx_ToOp(ctx context.Context) *xxx_ResourceTypeControlOperation {
	if o == nil {
		return &xxx_ResourceTypeControlOperation{}
	}
	return &xxx_ResourceTypeControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *ResourceTypeControlResponse) xxx_FromOp(ctx context.Context, op *xxx_ResourceTypeControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ResourceTypeControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ResourceTypeControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResourceTypeControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeGroupControlOperation structure represents the ApiNodeGroupControl operation
type xxx_NodeGroupControlOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	Node           *Node  `idl:"name:hNode" json:"node"`
	ControlCode    uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeGroupControlOperation) OpNum() int { return 76 }

func (o *xxx_NodeGroupControlOperation) OpName() string { return "/clusapi3/v3/ApiNodeGroupControl" }

func (o *xxx_NodeGroupControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeGroupControlRequest structure represents the ApiNodeGroupControl operation request
type NodeGroupControlRequest struct {
	Group         *Group `idl:"name:hGroup" json:"group"`
	Node          *Node  `idl:"name:hNode" json:"node"`
	ControlCode   uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeGroupControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeGroupControlOperation {
	if o == nil {
		return &xxx_NodeGroupControlOperation{}
	}
	return &xxx_NodeGroupControlOperation{
		Group:         o.Group,
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeGroupControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeGroupControlOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeGroupControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeGroupControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeGroupControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeGroupControlResponse structure represents the ApiNodeGroupControl operation response
type NodeGroupControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeGroupControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeGroupControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeGroupControlOperation {
	if o == nil {
		return &xxx_NodeGroupControlOperation{}
	}
	return &xxx_NodeGroupControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeGroupControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeGroupControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeGroupControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeGroupControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeGroupControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GroupControlOperation structure represents the ApiGroupControl operation
type xxx_GroupControlOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	ControlCode    uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GroupControlOperation) OpNum() int { return 77 }

func (o *xxx_GroupControlOperation) OpName() string { return "/clusapi3/v3/ApiGroupControl" }

func (o *xxx_GroupControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GroupControlRequest structure represents the ApiGroupControl operation request
type GroupControlRequest struct {
	Group         *Group `idl:"name:hGroup" json:"group"`
	ControlCode   uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *GroupControlRequest) xxx_ToOp(ctx context.Context) *xxx_GroupControlOperation {
	if o == nil {
		return &xxx_GroupControlOperation{}
	}
	return &xxx_GroupControlOperation{
		Group:         o.Group,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *GroupControlRequest) xxx_FromOp(ctx context.Context, op *xxx_GroupControlOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *GroupControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GroupControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GroupControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GroupControlResponse structure represents the ApiGroupControl operation response
type GroupControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGroupControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GroupControlResponse) xxx_ToOp(ctx context.Context) *xxx_GroupControlOperation {
	if o == nil {
		return &xxx_GroupControlOperation{}
	}
	return &xxx_GroupControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *GroupControlResponse) xxx_FromOp(ctx context.Context, op *xxx_GroupControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GroupControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GroupControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GroupControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeNodeControlOperation structure represents the ApiNodeNodeControl operation
type xxx_NodeNodeControlOperation struct {
	Node           *Node  `idl:"name:hNode" json:"node"`
	HostNode       *Node  `idl:"name:hHostNode" json:"host_node"`
	ControlCode    uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeNodeControlOperation) OpNum() int { return 78 }

func (o *xxx_NodeNodeControlOperation) OpName() string { return "/clusapi3/v3/ApiNodeNodeControl" }

func (o *xxx_NodeNodeControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNodeControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hHostNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.HostNode != nil {
			if err := o.HostNode.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNodeControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hHostNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.HostNode == nil {
			o.HostNode = &Node{}
		}
		if err := o.HostNode.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNodeControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNodeControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNodeControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeNodeControlRequest structure represents the ApiNodeNodeControl operation request
type NodeNodeControlRequest struct {
	Node          *Node  `idl:"name:hNode" json:"node"`
	HostNode      *Node  `idl:"name:hHostNode" json:"host_node"`
	ControlCode   uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeNodeControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeNodeControlOperation {
	if o == nil {
		return &xxx_NodeNodeControlOperation{}
	}
	return &xxx_NodeNodeControlOperation{
		Node:          o.Node,
		HostNode:      o.HostNode,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeNodeControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeNodeControlOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.HostNode = op.HostNode
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeNodeControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeNodeControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNodeControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeNodeControlResponse structure represents the ApiNodeNodeControl operation response
type NodeNodeControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeNodeControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeNodeControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeNodeControlOperation {
	if o == nil {
		return &xxx_NodeNodeControlOperation{}
	}
	return &xxx_NodeNodeControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeNodeControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeNodeControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeNodeControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeNodeControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNodeControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeControlOperation structure represents the ApiNodeControl operation
type xxx_NodeControlOperation struct {
	Node           *Node  `idl:"name:hNode" json:"node"`
	ControlCode    uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeControlOperation) OpNum() int { return 79 }

func (o *xxx_NodeControlOperation) OpName() string { return "/clusapi3/v3/ApiNodeControl" }

func (o *xxx_NodeControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeControlRequest structure represents the ApiNodeControl operation request
type NodeControlRequest struct {
	Node          *Node  `idl:"name:hNode" json:"node"`
	ControlCode   uint32 `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32 `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32 `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeControlOperation {
	if o == nil {
		return &xxx_NodeControlOperation{}
	}
	return &xxx_NodeControlOperation{
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeControlOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeControlResponse structure represents the ApiNodeControl operation response
type NodeControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeControlOperation {
	if o == nil {
		return &xxx_NodeControlOperation{}
	}
	return &xxx_NodeControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNetworkOperation structure represents the ApiOpenNetwork operation
type xxx_OpenNetworkOperation struct {
	NetworkName string   `idl:"name:lpszNetworkName;string" json:"network_name"`
	Status      uint32   `idl:"name:Status" json:"status"`
	RPCStatus   uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return      *Network `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNetworkOperation) OpNum() int { return 81 }

func (o *xxx_OpenNetworkOperation) OpName() string { return "/clusapi3/v3/ApiOpenNetwork" }

func (o *xxx_OpenNetworkOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNetworkOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Network{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNetworkRequest structure represents the ApiOpenNetwork operation request
type OpenNetworkRequest struct {
	NetworkName string `idl:"name:lpszNetworkName;string" json:"network_name"`
}

func (o *OpenNetworkRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNetworkOperation {
	if o == nil {
		return &xxx_OpenNetworkOperation{}
	}
	return &xxx_OpenNetworkOperation{
		NetworkName: o.NetworkName,
	}
}

func (o *OpenNetworkRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNetworkOperation) {
	if o == nil {
		return
	}
	o.NetworkName = op.NetworkName
}
func (o *OpenNetworkRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNetworkRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetworkOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNetworkResponse structure represents the ApiOpenNetwork operation response
type OpenNetworkResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNetwork return value.
	Return *Network `idl:"name:Return" json:"return"`
}

func (o *OpenNetworkResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNetworkOperation {
	if o == nil {
		return &xxx_OpenNetworkOperation{}
	}
	return &xxx_OpenNetworkOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenNetworkResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNetworkOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNetworkResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNetworkResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetworkOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseNetworkOperation structure represents the ApiCloseNetwork operation
type xxx_CloseNetworkOperation struct {
	Network *Network `idl:"name:Network" json:"network"`
	Return  uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseNetworkOperation) OpNum() int { return 82 }

func (o *xxx_CloseNetworkOperation) OpName() string { return "/clusapi3/v3/ApiCloseNetwork" }

func (o *xxx_CloseNetworkOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetworkOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Network {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseNetworkOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Network {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetworkOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetworkOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Network {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetworkOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Network {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseNetworkRequest structure represents the ApiCloseNetwork operation request
type CloseNetworkRequest struct {
	Network *Network `idl:"name:Network" json:"network"`
}

func (o *CloseNetworkRequest) xxx_ToOp(ctx context.Context) *xxx_CloseNetworkOperation {
	if o == nil {
		return &xxx_CloseNetworkOperation{}
	}
	return &xxx_CloseNetworkOperation{
		Network: o.Network,
	}
}

func (o *CloseNetworkRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseNetworkOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
}
func (o *CloseNetworkRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseNetworkRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNetworkOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseNetworkResponse structure represents the ApiCloseNetwork operation response
type CloseNetworkResponse struct {
	Network *Network `idl:"name:Network" json:"network"`
	// Return: The ApiCloseNetwork return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseNetworkResponse) xxx_ToOp(ctx context.Context) *xxx_CloseNetworkOperation {
	if o == nil {
		return &xxx_CloseNetworkOperation{}
	}
	return &xxx_CloseNetworkOperation{
		Network: o.Network,
		Return:  o.Return,
	}
}

func (o *CloseNetworkResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseNetworkOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
	o.Return = op.Return
}
func (o *CloseNetworkResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseNetworkResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNetworkOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetworkStateOperation structure represents the ApiGetNetworkState operation
type xxx_GetNetworkStateOperation struct {
	Network   *Network `idl:"name:hNetwork" json:"network"`
	State     uint32   `idl:"name:State" json:"state"`
	RPCStatus uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetworkStateOperation) OpNum() int { return 83 }

func (o *xxx_GetNetworkStateOperation) OpName() string { return "/clusapi3/v3/ApiGetNetworkState" }

func (o *xxx_GetNetworkStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNetworkStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetworkStateRequest structure represents the ApiGetNetworkState operation request
type GetNetworkStateRequest struct {
	Network *Network `idl:"name:hNetwork" json:"network"`
}

func (o *GetNetworkStateRequest) xxx_ToOp(ctx context.Context) *xxx_GetNetworkStateOperation {
	if o == nil {
		return &xxx_GetNetworkStateOperation{}
	}
	return &xxx_GetNetworkStateOperation{
		Network: o.Network,
	}
}

func (o *GetNetworkStateRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetworkStateOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
}
func (o *GetNetworkStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNetworkStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetworkStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetworkStateResponse structure represents the ApiGetNetworkState operation response
type GetNetworkStateResponse struct {
	State     uint32 `idl:"name:State" json:"state"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNetworkState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetworkStateResponse) xxx_ToOp(ctx context.Context) *xxx_GetNetworkStateOperation {
	if o == nil {
		return &xxx_GetNetworkStateOperation{}
	}
	return &xxx_GetNetworkStateOperation{
		State:     o.State,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNetworkStateResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetworkStateOperation) {
	if o == nil {
		return
	}
	o.State = op.State
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNetworkStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNetworkStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetworkStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetNetworkNameOperation structure represents the ApiSetNetworkName operation
type xxx_SetNetworkNameOperation struct {
	Network     *Network `idl:"name:hNetwork" json:"network"`
	NetworkName string   `idl:"name:lpszNetworkName;string" json:"network_name"`
	RPCStatus   uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return      uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_SetNetworkNameOperation) OpNum() int { return 84 }

func (o *xxx_SetNetworkNameOperation) OpName() string { return "/clusapi3/v3/ApiSetNetworkName" }

func (o *xxx_SetNetworkNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetNetworkNameRequest structure represents the ApiSetNetworkName operation request
type SetNetworkNameRequest struct {
	Network     *Network `idl:"name:hNetwork" json:"network"`
	NetworkName string   `idl:"name:lpszNetworkName;string" json:"network_name"`
}

func (o *SetNetworkNameRequest) xxx_ToOp(ctx context.Context) *xxx_SetNetworkNameOperation {
	if o == nil {
		return &xxx_SetNetworkNameOperation{}
	}
	return &xxx_SetNetworkNameOperation{
		Network:     o.Network,
		NetworkName: o.NetworkName,
	}
}

func (o *SetNetworkNameRequest) xxx_FromOp(ctx context.Context, op *xxx_SetNetworkNameOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
	o.NetworkName = op.NetworkName
}
func (o *SetNetworkNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetNetworkNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetNetworkNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetNetworkNameResponse structure represents the ApiSetNetworkName operation response
type SetNetworkNameResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetNetworkName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetNetworkNameResponse) xxx_ToOp(ctx context.Context) *xxx_SetNetworkNameOperation {
	if o == nil {
		return &xxx_SetNetworkNameOperation{}
	}
	return &xxx_SetNetworkNameOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetNetworkNameResponse) xxx_FromOp(ctx context.Context, op *xxx_SetNetworkNameOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetNetworkNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetNetworkNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetNetworkNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNetworkEnumOperation structure represents the ApiCreateNetworkEnum operation
type xxx_CreateNetworkEnumOperation struct {
	Network    *Network  `idl:"name:hNetwork" json:"network"`
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNetworkEnumOperation) OpNum() int { return 85 }

func (o *xxx_CreateNetworkEnumOperation) OpName() string { return "/clusapi3/v3/ApiCreateNetworkEnum" }

func (o *xxx_CreateNetworkEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetworkEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetworkEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetworkEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetworkEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetworkEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateNetworkEnumRequest structure represents the ApiCreateNetworkEnum operation request
type CreateNetworkEnumRequest struct {
	Network *Network `idl:"name:hNetwork" json:"network"`
	Type    uint32   `idl:"name:dwType" json:"type"`
}

func (o *CreateNetworkEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateNetworkEnumOperation {
	if o == nil {
		return &xxx_CreateNetworkEnumOperation{}
	}
	return &xxx_CreateNetworkEnumOperation{
		Network: o.Network,
		Type:    o.Type,
	}
}

func (o *CreateNetworkEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateNetworkEnumOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
	o.Type = op.Type
}
func (o *CreateNetworkEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNetworkEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNetworkEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNetworkEnumResponse structure represents the ApiCreateNetworkEnum operation response
type CreateNetworkEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNetworkEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateNetworkEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateNetworkEnumOperation {
	if o == nil {
		return &xxx_CreateNetworkEnumOperation{}
	}
	return &xxx_CreateNetworkEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateNetworkEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateNetworkEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNetworkEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNetworkEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNetworkEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetworkIDOperation structure represents the ApiGetNetworkId operation
type xxx_GetNetworkIDOperation struct {
	Network   *Network `idl:"name:hNetwork" json:"network"`
	GUID      string   `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetworkIDOperation) OpNum() int { return 86 }

func (o *xxx_GetNetworkIDOperation) OpName() string { return "/clusapi3/v3/ApiGetNetworkId" }

func (o *xxx_GetNetworkIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNetworkIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GUID != "" {
			_ptr_pGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GUID, _ptr_pGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetworkIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
				return err
			}
			return nil
		})
		_s_pGuid := func(ptr interface{}) { o.GUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.GUID, _s_pGuid, _ptr_pGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetworkIDRequest structure represents the ApiGetNetworkId operation request
type GetNetworkIDRequest struct {
	Network *Network `idl:"name:hNetwork" json:"network"`
}

func (o *GetNetworkIDRequest) xxx_ToOp(ctx context.Context) *xxx_GetNetworkIDOperation {
	if o == nil {
		return &xxx_GetNetworkIDOperation{}
	}
	return &xxx_GetNetworkIDOperation{
		Network: o.Network,
	}
}

func (o *GetNetworkIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetworkIDOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
}
func (o *GetNetworkIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNetworkIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetworkIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetworkIDResponse structure represents the ApiGetNetworkId operation response
type GetNetworkIDResponse struct {
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNetworkId return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetworkIDResponse) xxx_ToOp(ctx context.Context) *xxx_GetNetworkIDOperation {
	if o == nil {
		return &xxx_GetNetworkIDOperation{}
	}
	return &xxx_GetNetworkIDOperation{
		GUID:      o.GUID,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNetworkIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetworkIDOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNetworkIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNetworkIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetworkIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetNetworkPriorityOrderOperation structure represents the ApiSetNetworkPriorityOrder operation
type xxx_SetNetworkPriorityOrderOperation struct {
	NetworkCount  uint32   `idl:"name:NetworkCount" json:"network_count"`
	NetworkIDList []string `idl:"name:NetworkIdList;size_is:(NetworkCount);string" json:"network_id_list"`
	RPCStatus     uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_SetNetworkPriorityOrderOperation) OpNum() int { return 87 }

func (o *xxx_SetNetworkPriorityOrderOperation) OpName() string {
	return "/clusapi3/v3/ApiSetNetworkPriorityOrder"
}

func (o *xxx_SetNetworkPriorityOrderOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.NetworkIDList != nil && o.NetworkCount == 0 {
		o.NetworkCount = uint32(len(o.NetworkIDList))
	}
	if o.NetworkCount > uint32(1000) {
		return fmt.Errorf("NetworkCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkPriorityOrderOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// NetworkCount {in} (1:{range=(0,1000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NetworkCount); err != nil {
			return err
		}
	}
	// NetworkIdList {in} (1:{string}[dim:0,size_is=NetworkCount])(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		dimSize1 := uint64(o.NetworkCount)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.NetworkIDList {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if o.NetworkIDList[i1] != "" {
				_ptr_NetworkIdList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
					if err := ndr.WriteUTF16NString(ctx, w, o.NetworkIDList[i1]); err != nil {
						return err
					}
					return nil
				})
				if err := w.WritePointer(&o.NetworkIDList[i1], _ptr_NetworkIdList); err != nil {
					return err
				}
			} else {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
		}
		for i1 := len(o.NetworkIDList); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkPriorityOrderOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// NetworkCount {in} (1:{range=(0,1000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NetworkCount); err != nil {
			return err
		}
	}
	// NetworkIdList {in} (1:{string}[dim:0,size_is=NetworkCount])(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.NetworkIDList", sizeInfo[0])
		}
		o.NetworkIDList = make([]string, sizeInfo[0])
		for i1 := range o.NetworkIDList {
			i1 := i1
			_ptr_NetworkIdList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkIDList[i1]); err != nil {
					return err
				}
				return nil
			})
			_s_NetworkIdList := func(ptr interface{}) { o.NetworkIDList[i1] = *ptr.(*string) }
			if err := w.ReadPointer(&o.NetworkIDList[i1], _s_NetworkIdList, _ptr_NetworkIdList); err != nil {
				return err
			}
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkPriorityOrderOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkPriorityOrderOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetNetworkPriorityOrderOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetNetworkPriorityOrderRequest structure represents the ApiSetNetworkPriorityOrder operation request
type SetNetworkPriorityOrderRequest struct {
	NetworkCount  uint32   `idl:"name:NetworkCount" json:"network_count"`
	NetworkIDList []string `idl:"name:NetworkIdList;size_is:(NetworkCount);string" json:"network_id_list"`
}

func (o *SetNetworkPriorityOrderRequest) xxx_ToOp(ctx context.Context) *xxx_SetNetworkPriorityOrderOperation {
	if o == nil {
		return &xxx_SetNetworkPriorityOrderOperation{}
	}
	return &xxx_SetNetworkPriorityOrderOperation{
		NetworkCount:  o.NetworkCount,
		NetworkIDList: o.NetworkIDList,
	}
}

func (o *SetNetworkPriorityOrderRequest) xxx_FromOp(ctx context.Context, op *xxx_SetNetworkPriorityOrderOperation) {
	if o == nil {
		return
	}
	o.NetworkCount = op.NetworkCount
	o.NetworkIDList = op.NetworkIDList
}
func (o *SetNetworkPriorityOrderRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetNetworkPriorityOrderRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetNetworkPriorityOrderOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetNetworkPriorityOrderResponse structure represents the ApiSetNetworkPriorityOrder operation response
type SetNetworkPriorityOrderResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetNetworkPriorityOrder return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetNetworkPriorityOrderResponse) xxx_ToOp(ctx context.Context) *xxx_SetNetworkPriorityOrderOperation {
	if o == nil {
		return &xxx_SetNetworkPriorityOrderOperation{}
	}
	return &xxx_SetNetworkPriorityOrderOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetNetworkPriorityOrderResponse) xxx_FromOp(ctx context.Context, op *xxx_SetNetworkPriorityOrderOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetNetworkPriorityOrderResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetNetworkPriorityOrderResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetNetworkPriorityOrderOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeNetworkControlOperation structure represents the ApiNodeNetworkControl operation
type xxx_NodeNetworkControlOperation struct {
	Network        *Network `idl:"name:hNetwork" json:"network"`
	Node           *Node    `idl:"name:hNode" json:"node"`
	ControlCode    uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeNetworkControlOperation) OpNum() int { return 88 }

func (o *xxx_NodeNetworkControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeNetworkControl"
}

func (o *xxx_NodeNetworkControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetworkControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetworkControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetworkControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetworkControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetworkControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeNetworkControlRequest structure represents the ApiNodeNetworkControl operation request
type NodeNetworkControlRequest struct {
	Network       *Network `idl:"name:hNetwork" json:"network"`
	Node          *Node    `idl:"name:hNode" json:"node"`
	ControlCode   uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeNetworkControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeNetworkControlOperation {
	if o == nil {
		return &xxx_NodeNetworkControlOperation{}
	}
	return &xxx_NodeNetworkControlOperation{
		Network:       o.Network,
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeNetworkControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeNetworkControlOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeNetworkControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeNetworkControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNetworkControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeNetworkControlResponse structure represents the ApiNodeNetworkControl operation response
type NodeNetworkControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeNetworkControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeNetworkControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeNetworkControlOperation {
	if o == nil {
		return &xxx_NodeNetworkControlOperation{}
	}
	return &xxx_NodeNetworkControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeNetworkControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeNetworkControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeNetworkControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeNetworkControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNetworkControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NetworkControlOperation structure represents the ApiNetworkControl operation
type xxx_NetworkControlOperation struct {
	Network        *Network `idl:"name:hNetwork" json:"network"`
	ControlCode    uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_NetworkControlOperation) OpNum() int { return 89 }

func (o *xxx_NetworkControlOperation) OpName() string { return "/clusapi3/v3/ApiNetworkControl" }

func (o *xxx_NetworkControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetworkControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetworkControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetworkControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetworkControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetworkControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NetworkControlRequest structure represents the ApiNetworkControl operation request
type NetworkControlRequest struct {
	Network       *Network `idl:"name:hNetwork" json:"network"`
	ControlCode   uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NetworkControlRequest) xxx_ToOp(ctx context.Context) *xxx_NetworkControlOperation {
	if o == nil {
		return &xxx_NetworkControlOperation{}
	}
	return &xxx_NetworkControlOperation{
		Network:       o.Network,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NetworkControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NetworkControlOperation) {
	if o == nil {
		return
	}
	o.Network = op.Network
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NetworkControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NetworkControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NetworkControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NetworkControlResponse structure represents the ApiNetworkControl operation response
type NetworkControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNetworkControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NetworkControlResponse) xxx_ToOp(ctx context.Context) *xxx_NetworkControlOperation {
	if o == nil {
		return &xxx_NetworkControlOperation{}
	}
	return &xxx_NetworkControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NetworkControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NetworkControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NetworkControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NetworkControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NetworkControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyNetworkOperation structure represents the ApiAddNotifyNetwork operation
type xxx_AddNotifyNetworkOperation struct {
	Notify        *Notify  `idl:"name:hNotify" json:"notify"`
	Network       *Network `idl:"name:hNetwork" json:"network"`
	Filter        uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32   `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyNetworkOperation) OpNum() int { return 90 }

func (o *xxx_AddNotifyNetworkOperation) OpName() string { return "/clusapi3/v3/ApiAddNotifyNetwork" }

func (o *xxx_AddNotifyNetworkOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetworkOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetworkOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetworkOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetworkOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetworkOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyNetworkRequest structure represents the ApiAddNotifyNetwork operation request
type AddNotifyNetworkRequest struct {
	Notify    *Notify  `idl:"name:hNotify" json:"notify"`
	Network   *Network `idl:"name:hNetwork" json:"network"`
	Filter    uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyNetworkRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNetworkOperation {
	if o == nil {
		return &xxx_AddNotifyNetworkOperation{}
	}
	return &xxx_AddNotifyNetworkOperation{
		Notify:    o.Notify,
		Network:   o.Network,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
	}
}

func (o *AddNotifyNetworkRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNetworkOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Network = op.Network
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyNetworkRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyNetworkRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNetworkOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyNetworkResponse structure represents the ApiAddNotifyNetwork operation response
type AddNotifyNetworkResponse struct {
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyNetwork return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyNetworkResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNetworkOperation {
	if o == nil {
		return &xxx_AddNotifyNetworkOperation{}
	}
	return &xxx_AddNotifyNetworkOperation{
		StateSequence: o.StateSequence,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *AddNotifyNetworkResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNetworkOperation) {
	if o == nil {
		return
	}
	o.StateSequence = op.StateSequence
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyNetworkResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyNetworkResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNetworkOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReAddNotifyNetworkOperation structure represents the ApiReAddNotifyNetwork operation
type xxx_ReAddNotifyNetworkOperation struct {
	Notify        *Notify  `idl:"name:hNotify" json:"notify"`
	Network       *Network `idl:"name:hNetwork" json:"network"`
	Filter        uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32   `idl:"name:StateSequence" json:"state_sequence"`
	RPCStatus     uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_ReAddNotifyNetworkOperation) OpNum() int { return 91 }

func (o *xxx_ReAddNotifyNetworkOperation) OpName() string {
	return "/clusapi3/v3/ApiReAddNotifyNetwork"
}

func (o *xxx_ReAddNotifyNetworkOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetworkOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network != nil {
			if err := o.Network.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetworkOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNetwork {in} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Network == nil {
			o.Network = &Network{}
		}
		if err := o.Network.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetworkOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetworkOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetworkOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReAddNotifyNetworkRequest structure represents the ApiReAddNotifyNetwork operation request
type ReAddNotifyNetworkRequest struct {
	Notify        *Notify  `idl:"name:hNotify" json:"notify"`
	Network       *Network `idl:"name:hNetwork" json:"network"`
	Filter        uint32   `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32   `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32   `idl:"name:StateSequence" json:"state_sequence"`
}

func (o *ReAddNotifyNetworkRequest) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNetworkOperation {
	if o == nil {
		return &xxx_ReAddNotifyNetworkOperation{}
	}
	return &xxx_ReAddNotifyNetworkOperation{
		Notify:        o.Notify,
		Network:       o.Network,
		Filter:        o.Filter,
		NotifyKey:     o.NotifyKey,
		StateSequence: o.StateSequence,
	}
}

func (o *ReAddNotifyNetworkRequest) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNetworkOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Network = op.Network
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.StateSequence = op.StateSequence
}
func (o *ReAddNotifyNetworkRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ReAddNotifyNetworkRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNetworkOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReAddNotifyNetworkResponse structure represents the ApiReAddNotifyNetwork operation response
type ReAddNotifyNetworkResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiReAddNotifyNetwork return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReAddNotifyNetworkResponse) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNetworkOperation {
	if o == nil {
		return &xxx_ReAddNotifyNetworkOperation{}
	}
	return &xxx_ReAddNotifyNetworkOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ReAddNotifyNetworkResponse) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNetworkOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ReAddNotifyNetworkResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ReAddNotifyNetworkResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNetworkOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNetInterfaceOperation structure represents the ApiOpenNetInterface operation
type xxx_OpenNetInterfaceOperation struct {
	NetInterfaceName string        `idl:"name:lpszNetInterfaceName;string" json:"net_interface_name"`
	Status           uint32        `idl:"name:Status" json:"status"`
	RPCStatus        uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return           *NetInterface `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNetInterfaceOperation) OpNum() int { return 92 }

func (o *xxx_OpenNetInterfaceOperation) OpName() string { return "/clusapi3/v3/ApiOpenNetInterface" }

func (o *xxx_OpenNetInterfaceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNetInterfaceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetInterfaceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNetInterfaceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetInterfaceName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &NetInterface{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNetInterfaceRequest structure represents the ApiOpenNetInterface operation request
type OpenNetInterfaceRequest struct {
	NetInterfaceName string `idl:"name:lpszNetInterfaceName;string" json:"net_interface_name"`
}

func (o *OpenNetInterfaceRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNetInterfaceOperation {
	if o == nil {
		return &xxx_OpenNetInterfaceOperation{}
	}
	return &xxx_OpenNetInterfaceOperation{
		NetInterfaceName: o.NetInterfaceName,
	}
}

func (o *OpenNetInterfaceRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.NetInterfaceName = op.NetInterfaceName
}
func (o *OpenNetInterfaceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNetInterfaceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetInterfaceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNetInterfaceResponse structure represents the ApiOpenNetInterface operation response
type OpenNetInterfaceResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNetInterface return value.
	Return *NetInterface `idl:"name:Return" json:"return"`
}

func (o *OpenNetInterfaceResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNetInterfaceOperation {
	if o == nil {
		return &xxx_OpenNetInterfaceOperation{}
	}
	return &xxx_OpenNetInterfaceOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenNetInterfaceResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNetInterfaceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNetInterfaceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetInterfaceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseNetInterfaceOperation structure represents the ApiCloseNetInterface operation
type xxx_CloseNetInterfaceOperation struct {
	NetInterface *NetInterface `idl:"name:NetInterface" json:"net_interface"`
	Return       uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseNetInterfaceOperation) OpNum() int { return 93 }

func (o *xxx_CloseNetInterfaceOperation) OpName() string { return "/clusapi3/v3/ApiCloseNetInterface" }

func (o *xxx_CloseNetInterfaceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetInterfaceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// NetInterface {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseNetInterfaceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// NetInterface {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetInterfaceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetInterfaceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// NetInterface {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNetInterfaceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// NetInterface {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseNetInterfaceRequest structure represents the ApiCloseNetInterface operation request
type CloseNetInterfaceRequest struct {
	NetInterface *NetInterface `idl:"name:NetInterface" json:"net_interface"`
}

func (o *CloseNetInterfaceRequest) xxx_ToOp(ctx context.Context) *xxx_CloseNetInterfaceOperation {
	if o == nil {
		return &xxx_CloseNetInterfaceOperation{}
	}
	return &xxx_CloseNetInterfaceOperation{
		NetInterface: o.NetInterface,
	}
}

func (o *CloseNetInterfaceRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
}
func (o *CloseNetInterfaceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseNetInterfaceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNetInterfaceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseNetInterfaceResponse structure represents the ApiCloseNetInterface operation response
type CloseNetInterfaceResponse struct {
	NetInterface *NetInterface `idl:"name:NetInterface" json:"net_interface"`
	// Return: The ApiCloseNetInterface return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseNetInterfaceResponse) xxx_ToOp(ctx context.Context) *xxx_CloseNetInterfaceOperation {
	if o == nil {
		return &xxx_CloseNetInterfaceOperation{}
	}
	return &xxx_CloseNetInterfaceOperation{
		NetInterface: o.NetInterface,
		Return:       o.Return,
	}
}

func (o *CloseNetInterfaceResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
	o.Return = op.Return
}
func (o *CloseNetInterfaceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseNetInterfaceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNetInterfaceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetInterfaceStateOperation structure represents the ApiGetNetInterfaceState operation
type xxx_GetNetInterfaceStateOperation struct {
	NetInterface *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	State        uint32        `idl:"name:State" json:"state"`
	RPCStatus    uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetInterfaceStateOperation) OpNum() int { return 94 }

func (o *xxx_GetNetInterfaceStateOperation) OpName() string {
	return "/clusapi3/v3/ApiGetNetInterfaceState"
}

func (o *xxx_GetNetInterfaceStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// State {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetInterfaceStateRequest structure represents the ApiGetNetInterfaceState operation request
type GetNetInterfaceStateRequest struct {
	NetInterface *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
}

func (o *GetNetInterfaceStateRequest) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceStateOperation {
	if o == nil {
		return &xxx_GetNetInterfaceStateOperation{}
	}
	return &xxx_GetNetInterfaceStateOperation{
		NetInterface: o.NetInterface,
	}
}

func (o *GetNetInterfaceStateRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceStateOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
}
func (o *GetNetInterfaceStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNetInterfaceStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetInterfaceStateResponse structure represents the ApiGetNetInterfaceState operation response
type GetNetInterfaceStateResponse struct {
	State     uint32 `idl:"name:State" json:"state"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNetInterfaceState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetInterfaceStateResponse) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceStateOperation {
	if o == nil {
		return &xxx_GetNetInterfaceStateOperation{}
	}
	return &xxx_GetNetInterfaceStateOperation{
		State:     o.State,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNetInterfaceStateResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceStateOperation) {
	if o == nil {
		return
	}
	o.State = op.State
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNetInterfaceStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNetInterfaceStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetInterfaceOperation structure represents the ApiGetNetInterface operation
type xxx_GetNetInterfaceOperation struct {
	NodeName      string `idl:"name:lpszNodeName;string" json:"node_name"`
	NetworkName   string `idl:"name:lpszNetworkName;string" json:"network_name"`
	InterfaceName string `idl:"name:lppszInterfaceName;string" json:"interface_name"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetInterfaceOperation) OpNum() int { return 95 }

func (o *xxx_GetNetInterfaceOperation) OpName() string { return "/clusapi3/v3/ApiGetNetInterface" }

func (o *xxx_GetNetInterfaceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNodeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
			return err
		}
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNodeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
			return err
		}
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lppszInterfaceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.InterfaceName != "" {
			_ptr_lppszInterfaceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.InterfaceName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.InterfaceName, _ptr_lppszInterfaceName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lppszInterfaceName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lppszInterfaceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.InterfaceName); err != nil {
				return err
			}
			return nil
		})
		_s_lppszInterfaceName := func(ptr interface{}) { o.InterfaceName = *ptr.(*string) }
		if err := w.ReadPointer(&o.InterfaceName, _s_lppszInterfaceName, _ptr_lppszInterfaceName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetInterfaceRequest structure represents the ApiGetNetInterface operation request
type GetNetInterfaceRequest struct {
	NodeName    string `idl:"name:lpszNodeName;string" json:"node_name"`
	NetworkName string `idl:"name:lpszNetworkName;string" json:"network_name"`
}

func (o *GetNetInterfaceRequest) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceOperation {
	if o == nil {
		return &xxx_GetNetInterfaceOperation{}
	}
	return &xxx_GetNetInterfaceOperation{
		NodeName:    o.NodeName,
		NetworkName: o.NetworkName,
	}
}

func (o *GetNetInterfaceRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.NodeName = op.NodeName
	o.NetworkName = op.NetworkName
}
func (o *GetNetInterfaceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNetInterfaceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetInterfaceResponse structure represents the ApiGetNetInterface operation response
type GetNetInterfaceResponse struct {
	InterfaceName string `idl:"name:lppszInterfaceName;string" json:"interface_name"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNetInterface return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetInterfaceResponse) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceOperation {
	if o == nil {
		return &xxx_GetNetInterfaceOperation{}
	}
	return &xxx_GetNetInterfaceOperation{
		InterfaceName: o.InterfaceName,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *GetNetInterfaceResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.InterfaceName = op.InterfaceName
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNetInterfaceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNetInterfaceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetInterfaceIDOperation structure represents the ApiGetNetInterfaceId operation
type xxx_GetNetInterfaceIDOperation struct {
	NetInterface *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	GUID         string        `idl:"name:pGuid;string" json:"guid"`
	RPCStatus    uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetInterfaceIDOperation) OpNum() int { return 96 }

func (o *xxx_GetNetInterfaceIDOperation) OpName() string { return "/clusapi3/v3/ApiGetNetInterfaceId" }

func (o *xxx_GetNetInterfaceIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GUID != "" {
			_ptr_pGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GUID, _ptr_pGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetInterfaceIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pGuid {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
				return err
			}
			return nil
		})
		_s_pGuid := func(ptr interface{}) { o.GUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.GUID, _s_pGuid, _ptr_pGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetInterfaceIDRequest structure represents the ApiGetNetInterfaceId operation request
type GetNetInterfaceIDRequest struct {
	NetInterface *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
}

func (o *GetNetInterfaceIDRequest) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceIDOperation {
	if o == nil {
		return &xxx_GetNetInterfaceIDOperation{}
	}
	return &xxx_GetNetInterfaceIDOperation{
		NetInterface: o.NetInterface,
	}
}

func (o *GetNetInterfaceIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceIDOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
}
func (o *GetNetInterfaceIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNetInterfaceIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetInterfaceIDResponse structure represents the ApiGetNetInterfaceId operation response
type GetNetInterfaceIDResponse struct {
	GUID      string `idl:"name:pGuid;string" json:"guid"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetNetInterfaceId return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetInterfaceIDResponse) xxx_ToOp(ctx context.Context) *xxx_GetNetInterfaceIDOperation {
	if o == nil {
		return &xxx_GetNetInterfaceIDOperation{}
	}
	return &xxx_GetNetInterfaceIDOperation{
		GUID:      o.GUID,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetNetInterfaceIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetInterfaceIDOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetNetInterfaceIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNetInterfaceIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetInterfaceIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeNetInterfaceControlOperation structure represents the ApiNodeNetInterfaceControl operation
type xxx_NodeNetInterfaceControlOperation struct {
	NetInterface   *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Node           *Node         `idl:"name:hNode" json:"node"`
	ControlCode    uint32        `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte        `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32        `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte        `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32        `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32        `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32        `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeNetInterfaceControlOperation) OpNum() int { return 97 }

func (o *xxx_NodeNetInterfaceControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeNetInterfaceControl"
}

func (o *xxx_NodeNetInterfaceControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetInterfaceControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetInterfaceControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetInterfaceControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetInterfaceControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeNetInterfaceControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeNetInterfaceControlRequest structure represents the ApiNodeNetInterfaceControl operation request
type NodeNetInterfaceControlRequest struct {
	NetInterface  *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Node          *Node         `idl:"name:hNode" json:"node"`
	ControlCode   uint32        `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte        `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32        `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32        `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeNetInterfaceControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeNetInterfaceControlOperation {
	if o == nil {
		return &xxx_NodeNetInterfaceControlOperation{}
	}
	return &xxx_NodeNetInterfaceControlOperation{
		NetInterface:  o.NetInterface,
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeNetInterfaceControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeNetInterfaceControlOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeNetInterfaceControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeNetInterfaceControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNetInterfaceControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeNetInterfaceControlResponse structure represents the ApiNodeNetInterfaceControl operation response
type NodeNetInterfaceControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeNetInterfaceControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeNetInterfaceControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeNetInterfaceControlOperation {
	if o == nil {
		return &xxx_NodeNetInterfaceControlOperation{}
	}
	return &xxx_NodeNetInterfaceControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeNetInterfaceControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeNetInterfaceControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeNetInterfaceControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeNetInterfaceControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeNetInterfaceControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NetInterfaceControlOperation structure represents the ApiNetInterfaceControl operation
type xxx_NetInterfaceControlOperation struct {
	NetInterface   *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	ControlCode    uint32        `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte        `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32        `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte        `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32        `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32        `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32        `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_NetInterfaceControlOperation) OpNum() int { return 98 }

func (o *xxx_NetInterfaceControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNetInterfaceControl"
}

func (o *xxx_NetInterfaceControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetInterfaceControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetInterfaceControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetInterfaceControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetInterfaceControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NetInterfaceControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NetInterfaceControlRequest structure represents the ApiNetInterfaceControl operation request
type NetInterfaceControlRequest struct {
	NetInterface  *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	ControlCode   uint32        `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte        `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32        `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32        `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NetInterfaceControlRequest) xxx_ToOp(ctx context.Context) *xxx_NetInterfaceControlOperation {
	if o == nil {
		return &xxx_NetInterfaceControlOperation{}
	}
	return &xxx_NetInterfaceControlOperation{
		NetInterface:  o.NetInterface,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NetInterfaceControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NetInterfaceControlOperation) {
	if o == nil {
		return
	}
	o.NetInterface = op.NetInterface
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NetInterfaceControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NetInterfaceControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NetInterfaceControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NetInterfaceControlResponse structure represents the ApiNetInterfaceControl operation response
type NetInterfaceControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNetInterfaceControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NetInterfaceControlResponse) xxx_ToOp(ctx context.Context) *xxx_NetInterfaceControlOperation {
	if o == nil {
		return &xxx_NetInterfaceControlOperation{}
	}
	return &xxx_NetInterfaceControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NetInterfaceControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NetInterfaceControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NetInterfaceControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NetInterfaceControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NetInterfaceControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyNetInterfaceOperation structure represents the ApiAddNotifyNetInterface operation
type xxx_AddNotifyNetInterfaceOperation struct {
	Notify        *Notify       `idl:"name:hNotify" json:"notify"`
	NetInterface  *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Filter        uint32        `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32        `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32        `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyNetInterfaceOperation) OpNum() int { return 99 }

func (o *xxx_AddNotifyNetInterfaceOperation) OpName() string {
	return "/clusapi3/v3/ApiAddNotifyNetInterface"
}

func (o *xxx_AddNotifyNetInterfaceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetInterfaceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetInterfaceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetInterfaceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetInterfaceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyNetInterfaceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// dwStateSequence {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyNetInterfaceRequest structure represents the ApiAddNotifyNetInterface operation request
type AddNotifyNetInterfaceRequest struct {
	Notify       *Notify       `idl:"name:hNotify" json:"notify"`
	NetInterface *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Filter       uint32        `idl:"name:dwFilter" json:"filter"`
	NotifyKey    uint32        `idl:"name:dwNotifyKey" json:"notify_key"`
}

func (o *AddNotifyNetInterfaceRequest) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNetInterfaceOperation {
	if o == nil {
		return &xxx_AddNotifyNetInterfaceOperation{}
	}
	return &xxx_AddNotifyNetInterfaceOperation{
		Notify:       o.Notify,
		NetInterface: o.NetInterface,
		Filter:       o.Filter,
		NotifyKey:    o.NotifyKey,
	}
}

func (o *AddNotifyNetInterfaceRequest) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.NetInterface = op.NetInterface
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
}
func (o *AddNotifyNetInterfaceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyNetInterfaceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNetInterfaceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyNetInterfaceResponse structure represents the ApiAddNotifyNetInterface operation response
type AddNotifyNetInterfaceResponse struct {
	StateSequence uint32 `idl:"name:dwStateSequence" json:"state_sequence"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyNetInterface return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyNetInterfaceResponse) xxx_ToOp(ctx context.Context) *xxx_AddNotifyNetInterfaceOperation {
	if o == nil {
		return &xxx_AddNotifyNetInterfaceOperation{}
	}
	return &xxx_AddNotifyNetInterfaceOperation{
		StateSequence: o.StateSequence,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *AddNotifyNetInterfaceResponse) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.StateSequence = op.StateSequence
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyNetInterfaceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyNetInterfaceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyNetInterfaceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReAddNotifyNetInterfaceOperation structure represents the ApiReAddNotifyNetInterface operation
type xxx_ReAddNotifyNetInterfaceOperation struct {
	Notify        *Notify       `idl:"name:hNotify" json:"notify"`
	NetInterface  *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Filter        uint32        `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32        `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32        `idl:"name:StateSequence" json:"state_sequence"`
	RPCStatus     uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) OpNum() int { return 100 }

func (o *xxx_ReAddNotifyNetInterfaceOperation) OpName() string {
	return "/clusapi3/v3/ApiReAddNotifyNetInterface"
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface != nil {
			if err := o.NetInterface.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNetInterface {in} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NetInterface == nil {
			o.NetInterface = &NetInterface{}
		}
		if err := o.NetInterface.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// StateSequence {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StateSequence); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReAddNotifyNetInterfaceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReAddNotifyNetInterfaceRequest structure represents the ApiReAddNotifyNetInterface operation request
type ReAddNotifyNetInterfaceRequest struct {
	Notify        *Notify       `idl:"name:hNotify" json:"notify"`
	NetInterface  *NetInterface `idl:"name:hNetInterface" json:"net_interface"`
	Filter        uint32        `idl:"name:dwFilter" json:"filter"`
	NotifyKey     uint32        `idl:"name:dwNotifyKey" json:"notify_key"`
	StateSequence uint32        `idl:"name:StateSequence" json:"state_sequence"`
}

func (o *ReAddNotifyNetInterfaceRequest) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNetInterfaceOperation {
	if o == nil {
		return &xxx_ReAddNotifyNetInterfaceOperation{}
	}
	return &xxx_ReAddNotifyNetInterfaceOperation{
		Notify:        o.Notify,
		NetInterface:  o.NetInterface,
		Filter:        o.Filter,
		NotifyKey:     o.NotifyKey,
		StateSequence: o.StateSequence,
	}
}

func (o *ReAddNotifyNetInterfaceRequest) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.NetInterface = op.NetInterface
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.StateSequence = op.StateSequence
}
func (o *ReAddNotifyNetInterfaceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ReAddNotifyNetInterfaceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNetInterfaceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReAddNotifyNetInterfaceResponse structure represents the ApiReAddNotifyNetInterface operation response
type ReAddNotifyNetInterfaceResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiReAddNotifyNetInterface return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReAddNotifyNetInterfaceResponse) xxx_ToOp(ctx context.Context) *xxx_ReAddNotifyNetInterfaceOperation {
	if o == nil {
		return &xxx_ReAddNotifyNetInterfaceOperation{}
	}
	return &xxx_ReAddNotifyNetInterfaceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ReAddNotifyNetInterfaceResponse) xxx_FromOp(ctx context.Context, op *xxx_ReAddNotifyNetInterfaceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ReAddNotifyNetInterfaceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ReAddNotifyNetInterfaceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReAddNotifyNetInterfaceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNodeEnumOperation structure represents the ApiCreateNodeEnum operation
type xxx_CreateNodeEnumOperation struct {
	Node       *Node     `idl:"name:hNode" json:"node"`
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNodeEnumOperation) OpNum() int { return 101 }

func (o *xxx_CreateNodeEnumOperation) OpName() string { return "/clusapi3/v3/ApiCreateNodeEnum" }

func (o *xxx_CreateNodeEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateNodeEnumRequest structure represents the ApiCreateNodeEnum operation request
type CreateNodeEnumRequest struct {
	Node *Node  `idl:"name:hNode" json:"node"`
	Type uint32 `idl:"name:dwType" json:"type"`
}

func (o *CreateNodeEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateNodeEnumOperation {
	if o == nil {
		return &xxx_CreateNodeEnumOperation{}
	}
	return &xxx_CreateNodeEnumOperation{
		Node: o.Node,
		Type: o.Type,
	}
}

func (o *CreateNodeEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateNodeEnumOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.Type = op.Type
}
func (o *CreateNodeEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNodeEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNodeEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNodeEnumResponse structure represents the ApiCreateNodeEnum operation response
type CreateNodeEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNodeEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateNodeEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateNodeEnumOperation {
	if o == nil {
		return &xxx_CreateNodeEnumOperation{}
	}
	return &xxx_CreateNodeEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateNodeEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateNodeEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNodeEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNodeEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNodeEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClusterVersion2Operation structure represents the ApiGetClusterVersion2 operation
type xxx_GetClusterVersion2Operation struct {
	MajorVersion            uint16                         `idl:"name:lpwMajorVersion" json:"major_version"`
	MinorVersion            uint16                         `idl:"name:lpwMinorVersion" json:"minor_version"`
	BuildNumber             uint16                         `idl:"name:lpwBuildNumber" json:"build_number"`
	VendorID                string                         `idl:"name:lpszVendorId;string" json:"vendor_id"`
	CSDVersion              string                         `idl:"name:lpszCSDVersion;string" json:"csd_version"`
	ClusterOperationVerInfo *ClusterOperationalVersionInfo `idl:"name:ppClusterOpVerInfo" json:"cluster_operation_ver_info"`
	RPCStatus               uint32                         `idl:"name:rpc_status" json:"rpc_status"`
	Return                  uint32                         `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClusterVersion2Operation) OpNum() int { return 102 }

func (o *xxx_GetClusterVersion2Operation) OpName() string {
	return "/clusapi3/v3/ApiGetClusterVersion2"
}

func (o *xxx_GetClusterVersion2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersion2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetClusterVersion2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetClusterVersion2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersion2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpwMajorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.MajorVersion); err != nil {
			return err
		}
	}
	// lpwMinorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.MinorVersion); err != nil {
			return err
		}
	}
	// lpwBuildNumber {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BuildNumber); err != nil {
			return err
		}
	}
	// lpszVendorId {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.VendorID != "" {
			_ptr_lpszVendorId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorID, _ptr_lpszVendorId); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpszCSDVersion {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.CSDVersion != "" {
			_ptr_lpszCSDVersion := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.CSDVersion); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.CSDVersion, _ptr_lpszCSDVersion); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ppClusterOpVerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PCLUSTER_OPERATIONAL_VERSION_INFO}*(1))(3:{alias=CLUSTER_OPERATIONAL_VERSION_INFO}(struct))
	{
		if o.ClusterOperationVerInfo != nil {
			_ptr_ppClusterOpVerInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClusterOperationVerInfo != nil {
					if err := o.ClusterOperationVerInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ClusterOperationalVersionInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClusterOperationVerInfo, _ptr_ppClusterOpVerInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClusterVersion2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpwMajorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.MajorVersion); err != nil {
			return err
		}
	}
	// lpwMinorVersion {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.MinorVersion); err != nil {
			return err
		}
	}
	// lpwBuildNumber {out} (1:{pointer=ref}*(1))(2:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BuildNumber); err != nil {
			return err
		}
	}
	// lpszVendorId {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszVendorId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorID); err != nil {
				return err
			}
			return nil
		})
		_s_lpszVendorId := func(ptr interface{}) { o.VendorID = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorID, _s_lpszVendorId, _ptr_lpszVendorId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpszCSDVersion {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszCSDVersion := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.CSDVersion); err != nil {
				return err
			}
			return nil
		})
		_s_lpszCSDVersion := func(ptr interface{}) { o.CSDVersion = *ptr.(*string) }
		if err := w.ReadPointer(&o.CSDVersion, _s_lpszCSDVersion, _ptr_lpszCSDVersion); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ppClusterOpVerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PCLUSTER_OPERATIONAL_VERSION_INFO,pointer=ref}*(1))(3:{alias=CLUSTER_OPERATIONAL_VERSION_INFO}(struct))
	{
		_ptr_ppClusterOpVerInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClusterOperationVerInfo == nil {
				o.ClusterOperationVerInfo = &ClusterOperationalVersionInfo{}
			}
			if err := o.ClusterOperationVerInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppClusterOpVerInfo := func(ptr interface{}) { o.ClusterOperationVerInfo = *ptr.(**ClusterOperationalVersionInfo) }
		if err := w.ReadPointer(&o.ClusterOperationVerInfo, _s_ppClusterOpVerInfo, _ptr_ppClusterOpVerInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClusterVersion2Request structure represents the ApiGetClusterVersion2 operation request
type GetClusterVersion2Request struct {
}

func (o *GetClusterVersion2Request) xxx_ToOp(ctx context.Context) *xxx_GetClusterVersion2Operation {
	if o == nil {
		return &xxx_GetClusterVersion2Operation{}
	}
	return &xxx_GetClusterVersion2Operation{}
}

func (o *GetClusterVersion2Request) xxx_FromOp(ctx context.Context, op *xxx_GetClusterVersion2Operation) {
	if o == nil {
		return
	}
}
func (o *GetClusterVersion2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetClusterVersion2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterVersion2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClusterVersion2Response structure represents the ApiGetClusterVersion2 operation response
type GetClusterVersion2Response struct {
	MajorVersion            uint16                         `idl:"name:lpwMajorVersion" json:"major_version"`
	MinorVersion            uint16                         `idl:"name:lpwMinorVersion" json:"minor_version"`
	BuildNumber             uint16                         `idl:"name:lpwBuildNumber" json:"build_number"`
	VendorID                string                         `idl:"name:lpszVendorId;string" json:"vendor_id"`
	CSDVersion              string                         `idl:"name:lpszCSDVersion;string" json:"csd_version"`
	ClusterOperationVerInfo *ClusterOperationalVersionInfo `idl:"name:ppClusterOpVerInfo" json:"cluster_operation_ver_info"`
	RPCStatus               uint32                         `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetClusterVersion2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClusterVersion2Response) xxx_ToOp(ctx context.Context) *xxx_GetClusterVersion2Operation {
	if o == nil {
		return &xxx_GetClusterVersion2Operation{}
	}
	return &xxx_GetClusterVersion2Operation{
		MajorVersion:            o.MajorVersion,
		MinorVersion:            o.MinorVersion,
		BuildNumber:             o.BuildNumber,
		VendorID:                o.VendorID,
		CSDVersion:              o.CSDVersion,
		ClusterOperationVerInfo: o.ClusterOperationVerInfo,
		RPCStatus:               o.RPCStatus,
		Return:                  o.Return,
	}
}

func (o *GetClusterVersion2Response) xxx_FromOp(ctx context.Context, op *xxx_GetClusterVersion2Operation) {
	if o == nil {
		return
	}
	o.MajorVersion = op.MajorVersion
	o.MinorVersion = op.MinorVersion
	o.BuildNumber = op.BuildNumber
	o.VendorID = op.VendorID
	o.CSDVersion = op.CSDVersion
	o.ClusterOperationVerInfo = op.ClusterOperationVerInfo
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetClusterVersion2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetClusterVersion2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClusterVersion2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateRestrictionTypeEnumOperation structure represents the ApiCreateResTypeEnum operation
type xxx_CreateRestrictionTypeEnumOperation struct {
	TypeName   string    `idl:"name:lpszTypeName;string" json:"type_name"`
	Type       uint32    `idl:"name:dwType" json:"type"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateRestrictionTypeEnumOperation) OpNum() int { return 103 }

func (o *xxx_CreateRestrictionTypeEnumOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateResTypeEnum"
}

func (o *xxx_CreateRestrictionTypeEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionTypeEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszTypeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.TypeName); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionTypeEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszTypeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.TypeName); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionTypeEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionTypeEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateRestrictionTypeEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateRestrictionTypeEnumRequest structure represents the ApiCreateResTypeEnum operation request
type CreateRestrictionTypeEnumRequest struct {
	TypeName string `idl:"name:lpszTypeName;string" json:"type_name"`
	Type     uint32 `idl:"name:dwType" json:"type"`
}

func (o *CreateRestrictionTypeEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateRestrictionTypeEnumOperation {
	if o == nil {
		return &xxx_CreateRestrictionTypeEnumOperation{}
	}
	return &xxx_CreateRestrictionTypeEnumOperation{
		TypeName: o.TypeName,
		Type:     o.Type,
	}
}

func (o *CreateRestrictionTypeEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateRestrictionTypeEnumOperation) {
	if o == nil {
		return
	}
	o.TypeName = op.TypeName
	o.Type = op.Type
}
func (o *CreateRestrictionTypeEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateRestrictionTypeEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateRestrictionTypeEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateRestrictionTypeEnumResponse structure represents the ApiCreateResTypeEnum operation response
type CreateRestrictionTypeEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateResTypeEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateRestrictionTypeEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateRestrictionTypeEnumOperation {
	if o == nil {
		return &xxx_CreateRestrictionTypeEnumOperation{}
	}
	return &xxx_CreateRestrictionTypeEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateRestrictionTypeEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateRestrictionTypeEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateRestrictionTypeEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateRestrictionTypeEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateRestrictionTypeEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_BackupClusterDatabaseOperation structure represents the ApiBackupClusterDatabase operation
type xxx_BackupClusterDatabaseOperation struct {
	PathName  string `idl:"name:lpszPathName;string" json:"path_name"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_BackupClusterDatabaseOperation) OpNum() int { return 104 }

func (o *xxx_BackupClusterDatabaseOperation) OpName() string {
	return "/clusapi3/v3/ApiBackupClusterDatabase"
}

func (o *xxx_BackupClusterDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupClusterDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszPathName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PathName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupClusterDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszPathName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupClusterDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupClusterDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupClusterDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// BackupClusterDatabaseRequest structure represents the ApiBackupClusterDatabase operation request
type BackupClusterDatabaseRequest struct {
	PathName string `idl:"name:lpszPathName;string" json:"path_name"`
}

func (o *BackupClusterDatabaseRequest) xxx_ToOp(ctx context.Context) *xxx_BackupClusterDatabaseOperation {
	if o == nil {
		return &xxx_BackupClusterDatabaseOperation{}
	}
	return &xxx_BackupClusterDatabaseOperation{
		PathName: o.PathName,
	}
}

func (o *BackupClusterDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_BackupClusterDatabaseOperation) {
	if o == nil {
		return
	}
	o.PathName = op.PathName
}
func (o *BackupClusterDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *BackupClusterDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BackupClusterDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// BackupClusterDatabaseResponse structure represents the ApiBackupClusterDatabase operation response
type BackupClusterDatabaseResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiBackupClusterDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *BackupClusterDatabaseResponse) xxx_ToOp(ctx context.Context) *xxx_BackupClusterDatabaseOperation {
	if o == nil {
		return &xxx_BackupClusterDatabaseOperation{}
	}
	return &xxx_BackupClusterDatabaseOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *BackupClusterDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_BackupClusterDatabaseOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *BackupClusterDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *BackupClusterDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BackupClusterDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeClusterControlOperation structure represents the ApiNodeClusterControl operation
type xxx_NodeClusterControlOperation struct {
	Cluster        *Cluster `idl:"name:hCluster" json:"cluster"`
	HostNode       *Node    `idl:"name:hHostNode" json:"host_node"`
	ControlCode    uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeClusterControlOperation) OpNum() int { return 105 }

func (o *xxx_NodeClusterControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeClusterControl"
}

func (o *xxx_NodeClusterControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeClusterControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hHostNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.HostNode != nil {
			if err := o.HostNode.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeClusterControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hHostNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.HostNode == nil {
			o.HostNode = &Node{}
		}
		if err := o.HostNode.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeClusterControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeClusterControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeClusterControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeClusterControlRequest structure represents the ApiNodeClusterControl operation request
type NodeClusterControlRequest struct {
	Cluster       *Cluster `idl:"name:hCluster" json:"cluster"`
	HostNode      *Node    `idl:"name:hHostNode" json:"host_node"`
	ControlCode   uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeClusterControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeClusterControlOperation {
	if o == nil {
		return &xxx_NodeClusterControlOperation{}
	}
	return &xxx_NodeClusterControlOperation{
		Cluster:       o.Cluster,
		HostNode:      o.HostNode,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeClusterControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeClusterControlOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.HostNode = op.HostNode
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeClusterControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeClusterControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeClusterControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeClusterControlResponse structure represents the ApiNodeClusterControl operation response
type NodeClusterControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeClusterControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeClusterControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeClusterControlOperation {
	if o == nil {
		return &xxx_NodeClusterControlOperation{}
	}
	return &xxx_NodeClusterControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeClusterControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeClusterControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeClusterControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeClusterControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeClusterControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ClusterControlOperation structure represents the ApiClusterControl operation
type xxx_ClusterControlOperation struct {
	Cluster        *Cluster `idl:"name:hCluster" json:"cluster"`
	ControlCode    uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte   `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32   `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32   `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_ClusterControlOperation) OpNum() int { return 106 }

func (o *xxx_ClusterControlOperation) OpName() string { return "/clusapi3/v3/ApiClusterControl" }

func (o *xxx_ClusterControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClusterControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClusterControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClusterControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClusterControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClusterControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ClusterControlRequest structure represents the ApiClusterControl operation request
type ClusterControlRequest struct {
	Cluster       *Cluster `idl:"name:hCluster" json:"cluster"`
	ControlCode   uint32   `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte   `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32   `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32   `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *ClusterControlRequest) xxx_ToOp(ctx context.Context) *xxx_ClusterControlOperation {
	if o == nil {
		return &xxx_ClusterControlOperation{}
	}
	return &xxx_ClusterControlOperation{
		Cluster:       o.Cluster,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *ClusterControlRequest) xxx_FromOp(ctx context.Context, op *xxx_ClusterControlOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *ClusterControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ClusterControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClusterControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ClusterControlResponse structure represents the ApiClusterControl operation response
type ClusterControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiClusterControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ClusterControlResponse) xxx_ToOp(ctx context.Context) *xxx_ClusterControlOperation {
	if o == nil {
		return &xxx_ClusterControlOperation{}
	}
	return &xxx_ClusterControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *ClusterControlResponse) xxx_FromOp(ctx context.Context, op *xxx_ClusterControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ClusterControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ClusterControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClusterControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UnblockGetNotifyCallOperation structure represents the ApiUnblockGetNotifyCall operation
type xxx_UnblockGetNotifyCallOperation struct {
	Notify *Notify `idl:"name:hNotify" json:"notify"`
	Return uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_UnblockGetNotifyCallOperation) OpNum() int { return 107 }

func (o *xxx_UnblockGetNotifyCallOperation) OpName() string {
	return "/clusapi3/v3/ApiUnblockGetNotifyCall"
}

func (o *xxx_UnblockGetNotifyCallOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnblockGetNotifyCallOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_UnblockGetNotifyCallOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnblockGetNotifyCallOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnblockGetNotifyCallOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnblockGetNotifyCallOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UnblockGetNotifyCallRequest structure represents the ApiUnblockGetNotifyCall operation request
type UnblockGetNotifyCallRequest struct {
	Notify *Notify `idl:"name:hNotify" json:"notify"`
}

func (o *UnblockGetNotifyCallRequest) xxx_ToOp(ctx context.Context) *xxx_UnblockGetNotifyCallOperation {
	if o == nil {
		return &xxx_UnblockGetNotifyCallOperation{}
	}
	return &xxx_UnblockGetNotifyCallOperation{
		Notify: o.Notify,
	}
}

func (o *UnblockGetNotifyCallRequest) xxx_FromOp(ctx context.Context, op *xxx_UnblockGetNotifyCallOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *UnblockGetNotifyCallRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *UnblockGetNotifyCallRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnblockGetNotifyCallOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UnblockGetNotifyCallResponse structure represents the ApiUnblockGetNotifyCall operation response
type UnblockGetNotifyCallResponse struct {
	// Return: The ApiUnblockGetNotifyCall return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UnblockGetNotifyCallResponse) xxx_ToOp(ctx context.Context) *xxx_UnblockGetNotifyCallOperation {
	if o == nil {
		return &xxx_UnblockGetNotifyCallOperation{}
	}
	return &xxx_UnblockGetNotifyCallOperation{
		Return: o.Return,
	}
}

func (o *UnblockGetNotifyCallResponse) xxx_FromOp(ctx context.Context, op *xxx_UnblockGetNotifyCallOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *UnblockGetNotifyCallResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *UnblockGetNotifyCallResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnblockGetNotifyCallOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServiceAccountPasswordOperation structure represents the ApiSetServiceAccountPassword operation
type xxx_SetServiceAccountPasswordOperation struct {
	NewPassword               string                      `idl:"name:lpszNewPassword;string" json:"new_password"`
	Flags                     ClusterSetPasswordFlags     `idl:"name:dwFlags" json:"flags"`
	ReturnStatusBufferPointer []*ClusterSetPasswordStatus `idl:"name:ReturnStatusBufferPtr;size_is:(ReturnStatusBufferSize);length_is:(SizeReturned)" json:"return_status_buffer_pointer"`
	ReturnStatusBufferSize    uint32                      `idl:"name:ReturnStatusBufferSize" json:"return_status_buffer_size"`
	SizeReturned              uint32                      `idl:"name:SizeReturned" json:"size_returned"`
	ExpectedBufferSize        uint32                      `idl:"name:ExpectedBufferSize" json:"expected_buffer_size"`
	Return                    uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServiceAccountPasswordOperation) OpNum() int { return 108 }

func (o *xxx_SetServiceAccountPasswordOperation) OpName() string {
	return "/clusapi3/v3/ApiSetServiceAccountPassword"
}

func (o *xxx_SetServiceAccountPasswordOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.ReturnStatusBufferSize > uint32(65536) {
		return fmt.Errorf("ReturnStatusBufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceAccountPasswordOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNewPassword {in} (1:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NewPassword); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=IDL_CLUSTER_SET_PASSWORD_FLAGS}(enum))
	{
		if err := w.WriteData(uint16(o.Flags)); err != nil {
			return err
		}
	}
	// ReturnStatusBufferSize {in} (1:{range=(0,65536), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ReturnStatusBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceAccountPasswordOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNewPassword {in} (1:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NewPassword); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=IDL_CLUSTER_SET_PASSWORD_FLAGS}(enum))
	{
		if err := w.ReadData((*uint16)(&o.Flags)); err != nil {
			return err
		}
	}
	// ReturnStatusBufferSize {in} (1:{range=(0,65536), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ReturnStatusBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceAccountPasswordOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.ReturnStatusBufferPointer != nil && o.SizeReturned == 0 {
		o.SizeReturned = uint32(len(o.ReturnStatusBufferPointer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceAccountPasswordOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnStatusBufferPtr {out} (1:[dim:0,size_is=ReturnStatusBufferSize,length_is=SizeReturned])(2:{alias=IDL_CLUSTER_SET_PASSWORD_STATUS}(struct))
	{
		dimSize1 := uint64(o.ReturnStatusBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.SizeReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.ReturnStatusBufferPointer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if o.ReturnStatusBufferPointer[i1] != nil {
				if err := o.ReturnStatusBufferPointer[i1].MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ClusterSetPasswordStatus{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
		}
		for i1 := len(o.ReturnStatusBufferPointer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := (&ClusterSetPasswordStatus{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SizeReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SizeReturned); err != nil {
			return err
		}
	}
	// ExpectedBufferSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ExpectedBufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceAccountPasswordOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnStatusBufferPtr {out} (1:[dim:0,size_is=ReturnStatusBufferSize,length_is=SizeReturned])(2:{alias=IDL_CLUSTER_SET_PASSWORD_STATUS}(struct))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ReturnStatusBufferPointer", sizeInfo[0])
		}
		o.ReturnStatusBufferPointer = make([]*ClusterSetPasswordStatus, sizeInfo[0])
		for i1 := range o.ReturnStatusBufferPointer {
			i1 := i1
			if o.ReturnStatusBufferPointer[i1] == nil {
				o.ReturnStatusBufferPointer[i1] = &ClusterSetPasswordStatus{}
			}
			if err := o.ReturnStatusBufferPointer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SizeReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SizeReturned); err != nil {
			return err
		}
	}
	// ExpectedBufferSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ExpectedBufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServiceAccountPasswordRequest structure represents the ApiSetServiceAccountPassword operation request
type SetServiceAccountPasswordRequest struct {
	NewPassword            string                  `idl:"name:lpszNewPassword;string" json:"new_password"`
	Flags                  ClusterSetPasswordFlags `idl:"name:dwFlags" json:"flags"`
	ReturnStatusBufferSize uint32                  `idl:"name:ReturnStatusBufferSize" json:"return_status_buffer_size"`
}

func (o *SetServiceAccountPasswordRequest) xxx_ToOp(ctx context.Context) *xxx_SetServiceAccountPasswordOperation {
	if o == nil {
		return &xxx_SetServiceAccountPasswordOperation{}
	}
	return &xxx_SetServiceAccountPasswordOperation{
		NewPassword:            o.NewPassword,
		Flags:                  o.Flags,
		ReturnStatusBufferSize: o.ReturnStatusBufferSize,
	}
}

func (o *SetServiceAccountPasswordRequest) xxx_FromOp(ctx context.Context, op *xxx_SetServiceAccountPasswordOperation) {
	if o == nil {
		return
	}
	o.NewPassword = op.NewPassword
	o.Flags = op.Flags
	o.ReturnStatusBufferSize = op.ReturnStatusBufferSize
}
func (o *SetServiceAccountPasswordRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetServiceAccountPasswordRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceAccountPasswordOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServiceAccountPasswordResponse structure represents the ApiSetServiceAccountPassword operation response
type SetServiceAccountPasswordResponse struct {
	ReturnStatusBufferPointer []*ClusterSetPasswordStatus `idl:"name:ReturnStatusBufferPtr;size_is:(ReturnStatusBufferSize);length_is:(SizeReturned)" json:"return_status_buffer_pointer"`
	SizeReturned              uint32                      `idl:"name:SizeReturned" json:"size_returned"`
	ExpectedBufferSize        uint32                      `idl:"name:ExpectedBufferSize" json:"expected_buffer_size"`
	// Return: The ApiSetServiceAccountPassword return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetServiceAccountPasswordResponse) xxx_ToOp(ctx context.Context) *xxx_SetServiceAccountPasswordOperation {
	if o == nil {
		return &xxx_SetServiceAccountPasswordOperation{}
	}
	return &xxx_SetServiceAccountPasswordOperation{
		ReturnStatusBufferPointer: o.ReturnStatusBufferPointer,
		SizeReturned:              o.SizeReturned,
		ExpectedBufferSize:        o.ExpectedBufferSize,
		Return:                    o.Return,
	}
}

func (o *SetServiceAccountPasswordResponse) xxx_FromOp(ctx context.Context, op *xxx_SetServiceAccountPasswordOperation) {
	if o == nil {
		return
	}
	o.ReturnStatusBufferPointer = op.ReturnStatusBufferPointer
	o.SizeReturned = op.SizeReturned
	o.ExpectedBufferSize = op.ExpectedBufferSize
	o.Return = op.Return
}
func (o *SetServiceAccountPasswordResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetServiceAccountPasswordResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceAccountPasswordOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetResourceDependencyExpressionOperation structure represents the ApiSetResourceDependencyExpression operation
type xxx_SetResourceDependencyExpressionOperation struct {
	Resource             *Resource `idl:"name:hResource" json:"resource"`
	DependencyExpression string    `idl:"name:lpszDependencyExpression;string;pointer:unique" json:"dependency_expression"`
	RPCStatus            uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return               uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetResourceDependencyExpressionOperation) OpNum() int { return 109 }

func (o *xxx_SetResourceDependencyExpressionOperation) OpName() string {
	return "/clusapi3/v3/ApiSetResourceDependencyExpression"
}

func (o *xxx_SetResourceDependencyExpressionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceDependencyExpressionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszDependencyExpression {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.DependencyExpression != "" {
			_ptr_lpszDependencyExpression := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DependencyExpression); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DependencyExpression, _ptr_lpszDependencyExpression); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceDependencyExpressionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszDependencyExpression {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszDependencyExpression := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DependencyExpression); err != nil {
				return err
			}
			return nil
		})
		_s_lpszDependencyExpression := func(ptr interface{}) { o.DependencyExpression = *ptr.(*string) }
		if err := w.ReadPointer(&o.DependencyExpression, _s_lpszDependencyExpression, _ptr_lpszDependencyExpression); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceDependencyExpressionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceDependencyExpressionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetResourceDependencyExpressionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetResourceDependencyExpressionRequest structure represents the ApiSetResourceDependencyExpression operation request
type SetResourceDependencyExpressionRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous ApiOpenResource,
	// ApiOpenResourceEx, or ApiCreateResource method call.
	Resource *Resource `idl:"name:hResource" json:"resource"`
	// lpszDependencyExpression: A pointer to a null-terminated Unicode string buffer containing
	// a valid dependency expression.
	DependencyExpression string `idl:"name:lpszDependencyExpression;string;pointer:unique" json:"dependency_expression"`
}

func (o *SetResourceDependencyExpressionRequest) xxx_ToOp(ctx context.Context) *xxx_SetResourceDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetResourceDependencyExpressionOperation{}
	}
	return &xxx_SetResourceDependencyExpressionOperation{
		Resource:             o.Resource,
		DependencyExpression: o.DependencyExpression,
	}
}

func (o *SetResourceDependencyExpressionRequest) xxx_FromOp(ctx context.Context, op *xxx_SetResourceDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.DependencyExpression = op.DependencyExpression
}
func (o *SetResourceDependencyExpressionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetResourceDependencyExpressionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetResourceDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetResourceDependencyExpressionResponse structure represents the ApiSetResourceDependencyExpression operation response
type SetResourceDependencyExpressionResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether the runtime succeeded in executing
	// this method on the server. The encoding of the value passed in this parameter MUST
	// conform to encoding for comm_status and fault_status, as specified in Appendix E
	// of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetResourceDependencyExpression return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetResourceDependencyExpressionResponse) xxx_ToOp(ctx context.Context) *xxx_SetResourceDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetResourceDependencyExpressionOperation{}
	}
	return &xxx_SetResourceDependencyExpressionOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetResourceDependencyExpressionResponse) xxx_FromOp(ctx context.Context, op *xxx_SetResourceDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetResourceDependencyExpressionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetResourceDependencyExpressionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetResourceDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetResourceDependencyExpressionOperation structure represents the ApiGetResourceDependencyExpression operation
type xxx_GetResourceDependencyExpressionOperation struct {
	Resource             *Resource `idl:"name:hResource" json:"resource"`
	DependencyExpression string    `idl:"name:lpszDependencyExpression;string" json:"dependency_expression"`
	RPCStatus            uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return               uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetResourceDependencyExpressionOperation) OpNum() int { return 110 }

func (o *xxx_GetResourceDependencyExpressionOperation) OpName() string {
	return "/clusapi3/v3/ApiGetResourceDependencyExpression"
}

func (o *xxx_GetResourceDependencyExpressionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceDependencyExpressionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetResourceDependencyExpressionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceDependencyExpressionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceDependencyExpressionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpszDependencyExpression {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.DependencyExpression != "" {
			_ptr_lpszDependencyExpression := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DependencyExpression); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DependencyExpression, _ptr_lpszDependencyExpression); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceDependencyExpressionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpszDependencyExpression {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszDependencyExpression := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DependencyExpression); err != nil {
				return err
			}
			return nil
		})
		_s_lpszDependencyExpression := func(ptr interface{}) { o.DependencyExpression = *ptr.(*string) }
		if err := w.ReadPointer(&o.DependencyExpression, _s_lpszDependencyExpression, _ptr_lpszDependencyExpression); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetResourceDependencyExpressionRequest structure represents the ApiGetResourceDependencyExpression operation request
type GetResourceDependencyExpressionRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous ApiOpenResource,
	// ApiOpenResourceEx, or ApiCreateResource method call.
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *GetResourceDependencyExpressionRequest) xxx_ToOp(ctx context.Context) *xxx_GetResourceDependencyExpressionOperation {
	if o == nil {
		return &xxx_GetResourceDependencyExpressionOperation{}
	}
	return &xxx_GetResourceDependencyExpressionOperation{
		Resource: o.Resource,
	}
}

func (o *GetResourceDependencyExpressionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetResourceDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *GetResourceDependencyExpressionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetResourceDependencyExpressionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetResourceDependencyExpressionResponse structure represents the ApiGetResourceDependencyExpression operation response
type GetResourceDependencyExpressionResponse struct {
	// lpszDependencyExpression: The address of a pointer that receives a pointer to a Unicode
	// string buffer where the server MUST return the null-terminated complex dependency
	// expression after successful completion of this method. The server MUST allocate as
	// much memory as is required to return the expression. If the method fails, this parameter
	// MUST be ignored.
	DependencyExpression string `idl:"name:lpszDependencyExpression;string" json:"dependency_expression"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetResourceDependencyExpression return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetResourceDependencyExpressionResponse) xxx_ToOp(ctx context.Context) *xxx_GetResourceDependencyExpressionOperation {
	if o == nil {
		return &xxx_GetResourceDependencyExpressionOperation{}
	}
	return &xxx_GetResourceDependencyExpressionOperation{
		DependencyExpression: o.DependencyExpression,
		RPCStatus:            o.RPCStatus,
		Return:               o.Return,
	}
}

func (o *GetResourceDependencyExpressionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetResourceDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.DependencyExpression = op.DependencyExpression
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetResourceDependencyExpressionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetResourceDependencyExpressionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetResourceNetworkNameOperation structure represents the ApiGetResourceNetworkName operation
type xxx_GetResourceNetworkNameOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Name      string    `idl:"name:lpszName;string" json:"name"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetResourceNetworkNameOperation) OpNum() int { return 112 }

func (o *xxx_GetResourceNetworkNameOperation) OpName() string {
	return "/clusapi3/v3/ApiGetResourceNetworkName"
}

func (o *xxx_GetResourceNetworkNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceNetworkNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetResourceNetworkNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceNetworkNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceNetworkNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpszName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Name != "" {
			_ptr_lpszName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Name, _ptr_lpszName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetResourceNetworkNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpszName {out} (1:{string, pointer=ref}*(2))(2:{alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpszName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
				return err
			}
			return nil
		})
		_s_lpszName := func(ptr interface{}) { o.Name = *ptr.(*string) }
		if err := w.ReadPointer(&o.Name, _s_lpszName, _ptr_lpszName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetResourceNetworkNameRequest structure represents the ApiGetResourceNetworkName operation request
type GetResourceNetworkNameRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous ApiOpenResource,
	// ApiOpenResourceEx, or ApiCreateResource method call.
	Resource *Resource `idl:"name:hResource" json:"resource"`
}

func (o *GetResourceNetworkNameRequest) xxx_ToOp(ctx context.Context) *xxx_GetResourceNetworkNameOperation {
	if o == nil {
		return &xxx_GetResourceNetworkNameOperation{}
	}
	return &xxx_GetResourceNetworkNameOperation{
		Resource: o.Resource,
	}
}

func (o *GetResourceNetworkNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetResourceNetworkNameOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
}
func (o *GetResourceNetworkNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetResourceNetworkNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceNetworkNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetResourceNetworkNameResponse structure represents the ApiGetResourceNetworkName operation response
type GetResourceNetworkNameResponse struct {
	// lpszName: A pointer to a Unicode string buffer. The lpszName parameter receives the
	// NetBIOS computer name associated with the resource with the following properties:
	//
	// * This resource has a resource type that matches the Unicode string "Network Name".
	//
	// * This resource is depended upon by the specified resource, possibly through a chain
	// of dependencies.
	//
	// The server MUST allocate as much memory as is required to return the resource type.
	// If the method fails, this parameter MUST be ignored.
	Name string `idl:"name:lpszName;string" json:"name"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGetResourceNetworkName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetResourceNetworkNameResponse) xxx_ToOp(ctx context.Context) *xxx_GetResourceNetworkNameOperation {
	if o == nil {
		return &xxx_GetResourceNetworkNameOperation{}
	}
	return &xxx_GetResourceNetworkNameOperation{
		Name:      o.Name,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *GetResourceNetworkNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetResourceNetworkNameOperation) {
	if o == nil {
		return
	}
	o.Name = op.Name
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GetResourceNetworkNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetResourceNetworkNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetResourceNetworkNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ExecuteBatchOperation structure represents the ApiExecuteBatch operation
type xxx_ExecuteBatchOperation struct {
	Key           *Key   `idl:"name:hKey" json:"key"`
	DataLength    uint32 `idl:"name:cbData" json:"data_length"`
	Data          []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
	FailedCommand int32  `idl:"name:pdwFailedCommand" json:"failed_command"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ExecuteBatchOperation) OpNum() int { return 113 }

func (o *xxx_ExecuteBatchOperation) OpName() string { return "/clusapi3/v3/ApiExecuteBatch" }

func (o *xxx_ExecuteBatchOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteBatchOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// lpData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		dimSize1 := uint64(o.DataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ExecuteBatchOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// lpData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ExecuteBatchOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteBatchOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwFailedCommand {out} (1:{pointer=ref}*(1)(int32))
	{
		if err := w.WriteData(o.FailedCommand); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteBatchOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwFailedCommand {out} (1:{pointer=ref}*(1)(int32))
	{
		if err := w.ReadData(&o.FailedCommand); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ExecuteBatchRequest structure represents the ApiExecuteBatch operation request
type ExecuteBatchRequest struct {
	// hKey: The RPC context handle for a key that was previously obtained by a call to
	// ApiGetRootKey, ApiCreateKey, or ApiOpenKey. The key represented by this parameter
	// is the initial key from which all commands in the buffer of the lpData parameter
	// are executed.
	Key *Key `idl:"name:hKey" json:"key"`
	// cbData: A 32-bit integer that provides the size, in bytes, of the buffer pointed
	// to by the lpData parameter.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// lpData: A pointer to a buffer containing a variable-length CLUSTER_REG_BATCH_UPDATE
	// structure, as described in section 2.2.3.17, that contains a series of commands describing
	// a set of modifications to be applied to the cluster registry.
	Data []byte `idl:"name:lpData;size_is:(cbData)" json:"data"`
}

func (o *ExecuteBatchRequest) xxx_ToOp(ctx context.Context) *xxx_ExecuteBatchOperation {
	if o == nil {
		return &xxx_ExecuteBatchOperation{}
	}
	return &xxx_ExecuteBatchOperation{
		Key:        o.Key,
		DataLength: o.DataLength,
		Data:       o.Data,
	}
}

func (o *ExecuteBatchRequest) xxx_FromOp(ctx context.Context, op *xxx_ExecuteBatchOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.DataLength = op.DataLength
	o.Data = op.Data
}
func (o *ExecuteBatchRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ExecuteBatchRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteBatchOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ExecuteBatchResponse structure represents the ApiExecuteBatch operation response
type ExecuteBatchResponse struct {
	// pdwFailedCommand: A pointer to a 32-bit integer that is written, upon failure of
	// the method, with the number of the command that caused the failure. Commands are
	// numbered beginning at one and increase monotonically.
	FailedCommand int32 `idl:"name:pdwFailedCommand" json:"failed_command"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiExecuteBatch return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ExecuteBatchResponse) xxx_ToOp(ctx context.Context) *xxx_ExecuteBatchOperation {
	if o == nil {
		return &xxx_ExecuteBatchOperation{}
	}
	return &xxx_ExecuteBatchOperation{
		FailedCommand: o.FailedCommand,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *ExecuteBatchResponse) xxx_FromOp(ctx context.Context, op *xxx_ExecuteBatchOperation) {
	if o == nil {
		return
	}
	o.FailedCommand = op.FailedCommand
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ExecuteBatchResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ExecuteBatchResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteBatchOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateBatchPortOperation structure represents the ApiCreateBatchPort operation
type xxx_CreateBatchPortOperation struct {
	Key       *Key       `idl:"name:hKey" json:"key"`
	BatchPort *BatchPort `idl:"name:phBatchPort" json:"batch_port"`
	RPCStatus uint32     `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateBatchPortOperation) OpNum() int { return 114 }

func (o *xxx_CreateBatchPortOperation) OpName() string { return "/clusapi3/v3/ApiCreateBatchPort" }

func (o *xxx_CreateBatchPortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateBatchPortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateBatchPortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateBatchPortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateBatchPortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phBatchPort {out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort != nil {
			if err := o.BatchPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&BatchPort{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateBatchPortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phBatchPort {out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort == nil {
			o.BatchPort = &BatchPort{}
		}
		if err := o.BatchPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateBatchPortRequest structure represents the ApiCreateBatchPort operation request
type CreateBatchPortRequest struct {
	// hKey: The HKEY_RPC RPC context handle for a key that was previously obtained by a
	// call to ApiGetRootKey, ApiCreateKey, or ApiOpenKey.
	Key *Key `idl:"name:hKey" json:"key"`
}

func (o *CreateBatchPortRequest) xxx_ToOp(ctx context.Context) *xxx_CreateBatchPortOperation {
	if o == nil {
		return &xxx_CreateBatchPortOperation{}
	}
	return &xxx_CreateBatchPortOperation{
		Key: o.Key,
	}
}

func (o *CreateBatchPortRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateBatchPortOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
}
func (o *CreateBatchPortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateBatchPortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateBatchPortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateBatchPortResponse structure represents the ApiCreateBatchPort operation response
type CreateBatchPortResponse struct {
	// phBatchPort: If the method succeeds, the server MUST write a valid HBATCH_PORT_RPC
	// context handle, as specified in section 2.2.1.9, to the address supplied by this
	// parameter. Otherwise, the value at this address MUST be ignored.
	BatchPort *BatchPort `idl:"name:phBatchPort" json:"batch_port"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateBatchPort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateBatchPortResponse) xxx_ToOp(ctx context.Context) *xxx_CreateBatchPortOperation {
	if o == nil {
		return &xxx_CreateBatchPortOperation{}
	}
	return &xxx_CreateBatchPortOperation{
		BatchPort: o.BatchPort,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateBatchPortResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateBatchPortOperation) {
	if o == nil {
		return
	}
	o.BatchPort = op.BatchPort
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateBatchPortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateBatchPortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateBatchPortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetBatchNotificationOperation structure represents the ApiGetBatchNotification operation
type xxx_GetBatchNotificationOperation struct {
	BatchNotify *BatchPort `idl:"name:hBatchNotify" json:"batch_notify"`
	DataLength  uint32     `idl:"name:cbData" json:"data_length"`
	Data        []byte     `idl:"name:lpData;size_is:(, cbData)" json:"data"`
	Return      uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_GetBatchNotificationOperation) OpNum() int { return 115 }

func (o *xxx_GetBatchNotificationOperation) OpName() string {
	return "/clusapi3/v3/ApiGetBatchNotification"
}

func (o *xxx_GetBatchNotificationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetBatchNotificationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hBatchNotify {in} (1:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchNotify != nil {
			if err := o.BatchNotify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&BatchPort{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetBatchNotificationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hBatchNotify {in} (1:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchNotify == nil {
			o.BatchNotify = &BatchPort{}
		}
		if err := o.BatchNotify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetBatchNotificationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetBatchNotificationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// cbData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		if o.Data != nil || o.DataLength > 0 {
			_ptr_lpData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Data {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Data[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Data, _ptr_lpData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetBatchNotificationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// cbData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// lpData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbData](uchar))
	{
		_ptr_lpData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
			}
			o.Data = make([]byte, sizeInfo[0])
			for i1 := range o.Data {
				i1 := i1
				if err := w.ReadData(&o.Data[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Data, _s_lpData, _ptr_lpData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetBatchNotificationRequest structure represents the ApiGetBatchNotification operation request
type GetBatchNotificationRequest struct {
	// hBatchNotify: A pointer to an HBATCH_PORT_RPC context handle that was obtained in
	// a previous ApiCreateBatchPort method call.
	BatchNotify *BatchPort `idl:"name:hBatchNotify" json:"batch_notify"`
}

func (o *GetBatchNotificationRequest) xxx_ToOp(ctx context.Context) *xxx_GetBatchNotificationOperation {
	if o == nil {
		return &xxx_GetBatchNotificationOperation{}
	}
	return &xxx_GetBatchNotificationOperation{
		BatchNotify: o.BatchNotify,
	}
}

func (o *GetBatchNotificationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetBatchNotificationOperation) {
	if o == nil {
		return
	}
	o.BatchNotify = op.BatchNotify
}
func (o *GetBatchNotificationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetBatchNotificationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetBatchNotificationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetBatchNotificationResponse structure represents the ApiGetBatchNotification operation response
type GetBatchNotificationResponse struct {
	// cbData: A pointer to a 32-bit integer. Upon successful completion of this method,
	// the server MUST write the size, in bytes, of the lpData buffer to the integer location
	// indicated by cbData.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// lpData: The address of a pointer where the server MUST write, upon successful completion
	// of this method, a CLUSTER_REG_BATCH_UPDATE structure as previously described.
	Data []byte `idl:"name:lpData;size_is:(, cbData)" json:"data"`
	// Return: The ApiGetBatchNotification return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetBatchNotificationResponse) xxx_ToOp(ctx context.Context) *xxx_GetBatchNotificationOperation {
	if o == nil {
		return &xxx_GetBatchNotificationOperation{}
	}
	return &xxx_GetBatchNotificationOperation{
		DataLength: o.DataLength,
		Data:       o.Data,
		Return:     o.Return,
	}
}

func (o *GetBatchNotificationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetBatchNotificationOperation) {
	if o == nil {
		return
	}
	o.DataLength = op.DataLength
	o.Data = op.Data
	o.Return = op.Return
}
func (o *GetBatchNotificationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetBatchNotificationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetBatchNotificationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseBatchPortOperation structure represents the ApiCloseBatchPort operation
type xxx_CloseBatchPortOperation struct {
	BatchPort *BatchPort `idl:"name:phBatchPort" json:"batch_port"`
	Return    uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseBatchPortOperation) OpNum() int { return 116 }

func (o *xxx_CloseBatchPortOperation) OpName() string { return "/clusapi3/v3/ApiCloseBatchPort" }

func (o *xxx_CloseBatchPortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseBatchPortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// phBatchPort {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort != nil {
			if err := o.BatchPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&BatchPort{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseBatchPortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// phBatchPort {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort == nil {
			o.BatchPort = &BatchPort{}
		}
		if err := o.BatchPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseBatchPortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseBatchPortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phBatchPort {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort != nil {
			if err := o.BatchPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&BatchPort{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseBatchPortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phBatchPort {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HBATCH_PORT_RPC, names=ndr_context_handle}(struct))
	{
		if o.BatchPort == nil {
			o.BatchPort = &BatchPort{}
		}
		if err := o.BatchPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseBatchPortRequest structure represents the ApiCloseBatchPort operation request
type CloseBatchPortRequest struct {
	// phBatchPort: A pointer to an HBATCH_PORT_RPC context handle that was obtained in
	// a previous ApiCreateBatchPort method call. Upon success, the server MUST set to NULL
	// (0x00000000) the context handle pointed to by this parameter.
	BatchPort *BatchPort `idl:"name:phBatchPort" json:"batch_port"`
}

func (o *CloseBatchPortRequest) xxx_ToOp(ctx context.Context) *xxx_CloseBatchPortOperation {
	if o == nil {
		return &xxx_CloseBatchPortOperation{}
	}
	return &xxx_CloseBatchPortOperation{
		BatchPort: o.BatchPort,
	}
}

func (o *CloseBatchPortRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseBatchPortOperation) {
	if o == nil {
		return
	}
	o.BatchPort = op.BatchPort
}
func (o *CloseBatchPortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseBatchPortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseBatchPortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseBatchPortResponse structure represents the ApiCloseBatchPort operation response
type CloseBatchPortResponse struct {
	// phBatchPort: A pointer to an HBATCH_PORT_RPC context handle that was obtained in
	// a previous ApiCreateBatchPort method call. Upon success, the server MUST set to NULL
	// (0x00000000) the context handle pointed to by this parameter.
	BatchPort *BatchPort `idl:"name:phBatchPort" json:"batch_port"`
	// Return: The ApiCloseBatchPort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseBatchPortResponse) xxx_ToOp(ctx context.Context) *xxx_CloseBatchPortOperation {
	if o == nil {
		return &xxx_CloseBatchPortOperation{}
	}
	return &xxx_CloseBatchPortOperation{
		BatchPort: o.BatchPort,
		Return:    o.Return,
	}
}

func (o *CloseBatchPortResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseBatchPortOperation) {
	if o == nil {
		return
	}
	o.BatchPort = op.BatchPort
	o.Return = op.Return
}
func (o *CloseBatchPortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseBatchPortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseBatchPortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenClusterExOperation structure represents the ApiOpenClusterEx operation
type xxx_OpenClusterExOperation struct {
	DesiredAccess uint32   `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess uint32   `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status        uint32   `idl:"name:Status" json:"status"`
	Return        *Cluster `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenClusterExOperation) OpNum() int { return 117 }

func (o *xxx_OpenClusterExOperation) OpName() string { return "/clusapi3/v3/ApiOpenClusterEx" }

func (o *xxx_OpenClusterExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenClusterExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenClusterExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Cluster{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenClusterExRequest structure represents the ApiOpenClusterEx operation request
type OpenClusterExRequest struct {
	// dwDesiredAccess: Indicates the access level desired by the caller. The client SHOULD
	// set dwDesiredAccess to the bitwise OR of one or more values in the following table
	// (except for restrictions as noted in the table). The server SHOULD permit the cluster
	// security descriptor to express permissions other than those specified in the following
	// table. The server SHOULD perform an access check against those other permissions
	// if requested by the client, except if the client sets dwDesiredAccess to a value
	// that is invalid as specified in the following table. The server SHOULD NOT support
	// a value for dwDesiredAccess that allows the client to request an access level of
	// "Read with Backup Privilege".
	//
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	|                                  |                                                                                  |
	//	|              VALUE               |                                     MEANING                                      |
	//	|                                  |                                                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSAPI_READ_ACCESS 0x00000001   | The client requests a context handle that can be used in subsequent method calls |
	//	|                                  | that require "Read" access.                                                      |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSAPI_CHANGE_ACCESS 0x00000002 | The client requests a context handle that can be used in subsequent method       |
	//	|                                  | calls that require "All" access. The server MUST return ERROR_INVALID_PARAMETER  |
	//	|                                  | (0x00000057) if the dwDesiredAccess bitwise OR includes CLUSAPI_CHANGE_ACCESS    |
	//	|                                  | but not CLUSAPI_READ_ACCESS.                                                     |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC_READ 0x80000000          | The server MUST treat this value the same as CLUSAPI_READ_ACCESS.                |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC-WRITE 0x40000000         | The server MUST treat this value the same as the bitwise OR of                   |
	//	|                                  | CLUSAPI_READ_ACCESS and CLUSAPI_CHANGE_ACCESS.                                   |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC_EXECUTE 0x20000000       | The server MUST treat this value the same as the bitwise OR of                   |
	//	|                                  | CLUSAPI_READ_ACCESS and CLUSAPI_CHANGE_ACCESS.                                   |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC_ALL 0x10000000           | The server MUST treat this value the same as the bitwise OR of                   |
	//	|                                  | CLUSAPI_READ_ACCESS and CLUSAPI_CHANGE_ACCESS.                                   |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| MAXIMUM_ALLOWED 0x02000000       | The client requests a context handle that can be used in subsequent method calls |
	//	|                                  | that require the maximum access level granted to the client, as specified in     |
	//	|                                  | section 3.1.4.                                                                   |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenClusterExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenClusterExOperation {
	if o == nil {
		return &xxx_OpenClusterExOperation{}
	}
	return &xxx_OpenClusterExOperation{
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenClusterExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenClusterExOperation) {
	if o == nil {
		return
	}
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenClusterExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenClusterExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenClusterExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenClusterExResponse structure represents the ApiOpenClusterEx operation response
type OpenClusterExResponse struct {
	// lpdwGrantedAccess: A pointer to a 32-bit value that indicates the access level granted
	// to the client. If the method fails, the client MUST ignore this value. Upon successful
	// completion of this method, the server MUST set this value to one of the values in
	// the following table.
	//
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	|                         |                                                                                  |
	//	|          VALUE          |                                     MEANING                                      |
	//	|                         |                                                                                  |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC_READ 0x80000000 | The returned context handle can be used in subsequent methods that require       |
	//	|                         | "Read" access. If the client has backup privilege, the returned context handle   |
	//	|                         | can also be used in subsequent methods that require "Read with Backup Privilege" |
	//	|                         | access.                                                                          |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| GENERIC_ALL 0x10000000  | The returned context handle can be used in subsequent methods that require "All" |
	//	|                         | access.                                                                          |
	//	+-------------------------+----------------------------------------------------------------------------------+
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x00000000              | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                       | entitled to (section 3.1.4).                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1 | The server does not support this method.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// Return: The ApiOpenClusterEx return value.
	Return *Cluster `idl:"name:Return" json:"return"`
}

func (o *OpenClusterExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenClusterExOperation {
	if o == nil {
		return &xxx_OpenClusterExOperation{}
	}
	return &xxx_OpenClusterExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		Return:        o.Return,
	}
}

func (o *OpenClusterExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenClusterExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.Return = op.Return
}
func (o *OpenClusterExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenClusterExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenClusterExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNodeExOperation structure represents the ApiOpenNodeEx operation
type xxx_OpenNodeExOperation struct {
	NodeName      string `idl:"name:lpszNodeName;string" json:"node_name"`
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status        uint32 `idl:"name:Status" json:"status"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Node  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNodeExOperation) OpNum() int { return 118 }

func (o *xxx_OpenNodeExOperation) OpName() string { return "/clusapi3/v3/ApiOpenNodeEx" }

func (o *xxx_OpenNodeExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNodeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NodeName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNodeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NodeName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNodeExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNodeExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Node{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNodeExRequest structure represents the ApiOpenNodeEx operation request
type OpenNodeExRequest struct {
	// lpszNodeName: A null-terminated Unicode string that contains the computer name of
	// the node for which to establish context on the server.
	NodeName string `idl:"name:lpszNodeName;string" json:"node_name"`
	// dwDesiredAccess: The value for this parameter is the same as specified for dwDesiredAccess
	// in ApiOpenClusterEx.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenNodeExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNodeExOperation {
	if o == nil {
		return &xxx_OpenNodeExOperation{}
	}
	return &xxx_OpenNodeExOperation{
		NodeName:      o.NodeName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenNodeExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNodeExOperation) {
	if o == nil {
		return
	}
	o.NodeName = op.NodeName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenNodeExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNodeExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNodeExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNodeExResponse structure represents the ApiOpenNodeEx operation response
type OpenNodeExResponse struct {
	// lpdwGrantedAccess: The value for this parameter is the same as specified for lpdwGrantedAccess
	// in ApiOpenClusterEx, with the additional stipulation that if the server sets lpdwGrantedAccess
	// to GENERIC_READ and if the client has the backup privilege, as defined in [MS-LSAD],
	// then the returned context handle can also be used in a subsequent call to ApiMoveGroupToNode.
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                         |                                                                                  |
	//	|                  VALUE                  |                                     MEANING                                      |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x00000000                | Success.                                                                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005          | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                         | entitled to (section 3.1.4).                                                     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057      | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_CLUSTER_NODE_NOT_FOUND 0x000013B2 | A node that matches the name lpszNodeName was not found in the cluster           |
	//	|                                         | configuration.                                                                   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1   | The server does not support this method.                                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNodeEx return value.
	Return *Node `idl:"name:Return" json:"return"`
}

func (o *OpenNodeExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNodeExOperation {
	if o == nil {
		return &xxx_OpenNodeExOperation{}
	}
	return &xxx_OpenNodeExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *OpenNodeExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNodeExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNodeExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNodeExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNodeExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenGroupExOperation structure represents the ApiOpenGroupEx operation
type xxx_OpenGroupExOperation struct {
	GroupName     string `idl:"name:lpszGroupName;string" json:"group_name"`
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status        uint32 `idl:"name:Status" json:"status"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Group `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenGroupExOperation) OpNum() int { return 119 }

func (o *xxx_OpenGroupExOperation) OpName() string { return "/clusapi3/v3/ApiOpenGroupEx" }

func (o *xxx_OpenGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Group{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenGroupExRequest structure represents the ApiOpenGroupEx operation request
type OpenGroupExRequest struct {
	// lpszGroupName: A Unicode string that contains the name of the group for which to
	// establish context on the server.
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
	// dwDesiredAccess: The value for this parameter is the same as specified for dwDesiredAccess
	// in ApiOpenClusterEx.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenGroupExOperation {
	if o == nil {
		return &xxx_OpenGroupExOperation{}
	}
	return &xxx_OpenGroupExOperation{
		GroupName:     o.GroupName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupExOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenGroupExResponse structure represents the ApiOpenGroupEx operation response
type OpenGroupExResponse struct {
	// lpdwGrantedAccess: The value for this parameter is the same as specified for lpdwGrantedAccess
	// in ApiOpenClusterEx, with the additional stipulation that if the server sets lpdwGrantedAccess
	// to GENERIC_READ and if the client has the backup privilege, as defined in [MS-LSAD],
	// then the returned context handle can also be used in a subsequent call to ApiMoveGroup
	// or ApiMoveGroupToNode.
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x00000000              | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                       | entitled to (section 3.1.4).                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SHARING_PAUSED 0x00000046       | The remote server has been paused or is in the process of being started.         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1 | The server does not support this method.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_GROUP_NOT_FOUND 0x00001395      | A group that matches the name lpszGroupName was not found in the cluster         |
	//	|                                       | configuration.                                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenGroupEx return value.
	Return *Group `idl:"name:Return" json:"return"`
}

func (o *OpenGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenGroupExOperation {
	if o == nil {
		return &xxx_OpenGroupExOperation{}
	}
	return &xxx_OpenGroupExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *OpenGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenResourceExOperation structure represents the ApiOpenResourceEx operation
type xxx_OpenResourceExOperation struct {
	ResourceName  string    `idl:"name:lpszResourceName;string" json:"resource_name"`
	DesiredAccess uint32    `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess uint32    `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status        uint32    `idl:"name:Status" json:"status"`
	RPCStatus     uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Resource `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenResourceExOperation) OpNum() int { return 120 }

func (o *xxx_OpenResourceExOperation) OpName() string { return "/clusapi3/v3/ApiOpenResourceEx" }

func (o *xxx_OpenResourceExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszResourceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ResourceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszResourceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ResourceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenResourceExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenResourceExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Resource{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenResourceExRequest structure represents the ApiOpenResourceEx operation request
type OpenResourceExRequest struct {
	// lpszResourceName: A Unicode string that contains the name of the resource for which
	// to establish context on the server. For version 3.0, the server MUST also accept
	// the resource unique ID as returned by the ApiGetResourceId method.
	ResourceName string `idl:"name:lpszResourceName;string" json:"resource_name"`
	// dwDesiredAccess: The value for this parameter is the same as specified for dwDesiredAccess
	// in ApiOpenClusterEx.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenResourceExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenResourceExOperation {
	if o == nil {
		return &xxx_OpenResourceExOperation{}
	}
	return &xxx_OpenResourceExOperation{
		ResourceName:  o.ResourceName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenResourceExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenResourceExOperation) {
	if o == nil {
		return
	}
	o.ResourceName = op.ResourceName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenResourceExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenResourceExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenResourceExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenResourceExResponse structure represents the ApiOpenResourceEx operation response
type OpenResourceExResponse struct {
	// lpdwGrantedAccess: The value for this parameter is the same as specified for lpdwGrantedAccess
	// in ApiOpenClusterEx.
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x0000000               | Success.                                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                       | entitled to (section 3.1.4).                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1 | The server does not support this method.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_RESOURCE_NOT_FOUND 0x0000138f   | A resource that matches name lpszResourceName was not found in the cluster       |
	//	|                                       | configuration.                                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenResourceEx return value.
	Return *Resource `idl:"name:Return" json:"return"`
}

func (o *OpenResourceExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenResourceExOperation {
	if o == nil {
		return &xxx_OpenResourceExOperation{}
	}
	return &xxx_OpenResourceExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *OpenResourceExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenResourceExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenResourceExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenResourceExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenResourceExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNetworkExOperation structure represents the ApiOpenNetworkEx operation
type xxx_OpenNetworkExOperation struct {
	NetworkName   string   `idl:"name:lpszNetworkName;string" json:"network_name"`
	DesiredAccess uint32   `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess uint32   `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status        uint32   `idl:"name:Status" json:"status"`
	RPCStatus     uint32   `idl:"name:rpc_status" json:"rpc_status"`
	Return        *Network `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNetworkExOperation) OpNum() int { return 121 }

func (o *xxx_OpenNetworkExOperation) OpName() string { return "/clusapi3/v3/ApiOpenNetworkEx" }

func (o *xxx_OpenNetworkExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNetworkName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetworkExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Network{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNetworkExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETWORK_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Network{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNetworkExRequest structure represents the ApiOpenNetworkEx operation request
type OpenNetworkExRequest struct {
	// lpszNetworkName: A null-terminated Unicode string that contains the name of the cluster
	// network for which to establish context on the server.
	NetworkName string `idl:"name:lpszNetworkName;string" json:"network_name"`
	// dwDesiredAccess: The value for this parameter is the same as specified for dwDesiredAccess
	// in ApiOpenClusterEx.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenNetworkExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNetworkExOperation {
	if o == nil {
		return &xxx_OpenNetworkExOperation{}
	}
	return &xxx_OpenNetworkExOperation{
		NetworkName:   o.NetworkName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenNetworkExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNetworkExOperation) {
	if o == nil {
		return
	}
	o.NetworkName = op.NetworkName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenNetworkExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNetworkExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetworkExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNetworkExResponse structure represents the ApiOpenNetworkEx operation response
type OpenNetworkExResponse struct {
	// lpdwGrantedAccess: The value for this parameter is the same as specified for lpdwGrantedAccess
	// in ApiOpenClusterEx.
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|                   VALUE                    |                                     MEANING                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x00000000                   | Success.                                                                         |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005             | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                            | entitled to (section 3.1.4).                                                     |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057         | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1      | The server does not support this method.                                         |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_CLUSTER_NETWORK_NOT_FOUND 0x000013B5 | A cluster network that matches the name lpszNetworkName was not found in the     |
	//	|                                            | cluster configuration.                                                           |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNetworkEx return value.
	Return *Network `idl:"name:Return" json:"return"`
}

func (o *OpenNetworkExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNetworkExOperation {
	if o == nil {
		return &xxx_OpenNetworkExOperation{}
	}
	return &xxx_OpenNetworkExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *OpenNetworkExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNetworkExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNetworkExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNetworkExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetworkExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenNetInterfaceExOperation structure represents the ApiOpenNetInterfaceEx operation
type xxx_OpenNetInterfaceExOperation struct {
	NetInterfaceName string        `idl:"name:lpszNetInterfaceName;string" json:"net_interface_name"`
	DesiredAccess    uint32        `idl:"name:dwDesiredAccess" json:"desired_access"`
	GrantedAccess    uint32        `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	Status           uint32        `idl:"name:Status" json:"status"`
	RPCStatus        uint32        `idl:"name:rpc_status" json:"rpc_status"`
	Return           *NetInterface `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenNetInterfaceExOperation) OpNum() int { return 122 }

func (o *xxx_OpenNetInterfaceExOperation) OpName() string {
	return "/clusapi3/v3/ApiOpenNetInterfaceEx"
}

func (o *xxx_OpenNetInterfaceExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszNetInterfaceName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetInterfaceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszNetInterfaceName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetInterfaceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenNetInterfaceExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwGrantedAccess {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GrantedAccess); err != nil {
			return err
		}
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNETINTERFACE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &NetInterface{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenNetInterfaceExRequest structure represents the ApiOpenNetInterfaceEx operation request
type OpenNetInterfaceExRequest struct {
	// lpszNetInterfaceName: A null-terminated Unicode string that contains the name of
	// the cluster network interface for which to establish context on the server.
	NetInterfaceName string `idl:"name:lpszNetInterfaceName;string" json:"net_interface_name"`
	// dwDesiredAccess: The value for this parameter is the same as specified for dwDesiredAccess
	// in ApiOpenClusterEx.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenNetInterfaceExRequest) xxx_ToOp(ctx context.Context) *xxx_OpenNetInterfaceExOperation {
	if o == nil {
		return &xxx_OpenNetInterfaceExOperation{}
	}
	return &xxx_OpenNetInterfaceExOperation{
		NetInterfaceName: o.NetInterfaceName,
		DesiredAccess:    o.DesiredAccess,
	}
}

func (o *OpenNetInterfaceExRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenNetInterfaceExOperation) {
	if o == nil {
		return
	}
	o.NetInterfaceName = op.NetInterfaceName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenNetInterfaceExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenNetInterfaceExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetInterfaceExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenNetInterfaceExResponse structure represents the ApiOpenNetInterfaceEx operation response
type OpenNetInterfaceExResponse struct {
	// lpdwGrantedAccess: The value for this parameter is the same as specified for lpdwGrantedAccess
	// in ApiOpenClusterEx.
	GrantedAccess uint32 `idl:"name:lpdwGrantedAccess" json:"granted_access"`
	// Status: Indicates the status of this operation. The server MUST set Status to the
	// following error codes for the specified conditions.
	//
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                 |                                                                                  |
	//	|                      VALUE                      |                                     MEANING                                      |
	//	|                                                 |                                                                                  |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SUCCESS 0x00000000                        | Success.                                                                         |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005                  | dwDesiredAccess indicates a level of access exceeding what the client is         |
	//	|                                                 | entitled to (section 3.1.4).                                                     |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057              | dwDesiredAccess is invalid, as specified earlier in this section.                |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_S_PROCNUM_OUT_OF_RANGE 0x000006D1           | The server does not support this method.                                         |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_CLUSTER_NETINTERFACE_NOT_FOUND 0x000013b7 | A cluster network interface that matches the name lpszNetInterfaceName was not   |
	//	|                                                 | found in the cluster configuration.                                              |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenNetInterfaceEx return value.
	Return *NetInterface `idl:"name:Return" json:"return"`
}

func (o *OpenNetInterfaceExResponse) xxx_ToOp(ctx context.Context) *xxx_OpenNetInterfaceExOperation {
	if o == nil {
		return &xxx_OpenNetInterfaceExOperation{}
	}
	return &xxx_OpenNetInterfaceExOperation{
		GrantedAccess: o.GrantedAccess,
		Status:        o.Status,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *OpenNetInterfaceExResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenNetInterfaceExOperation) {
	if o == nil {
		return
	}
	o.GrantedAccess = op.GrantedAccess
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenNetInterfaceExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenNetInterfaceExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenNetInterfaceExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeCSVStateOperation structure represents the ApiChangeCsvState operation
type xxx_ChangeCSVStateOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	State     uint32    `idl:"name:dwState" json:"state"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeCSVStateOperation) OpNum() int { return 123 }

func (o *xxx_ChangeCSVStateOperation) OpName() string { return "/clusapi3/v3/ApiChangeCsvState" }

func (o *xxx_ChangeCSVStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeCSVStateRequest structure represents the ApiChangeCsvState operation request
type ChangeCSVStateRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous ApiOpenResource,
	// ApiOpenResourceEx, or ApiCreateResource method call.
	Resource *Resource `idl:"name:hResource" json:"resource"`
	// dwState: This MUST be 1 to make the disk associated with hResource accessible from
	// all cluster nodes. This MUST be 0 to make the disk associated with hResource accessible
	// only from the cluster node that mounted the disk.
	State uint32 `idl:"name:dwState" json:"state"`
}

func (o *ChangeCSVStateRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeCSVStateOperation {
	if o == nil {
		return &xxx_ChangeCSVStateOperation{}
	}
	return &xxx_ChangeCSVStateOperation{
		Resource: o.Resource,
		State:    o.State,
	}
}

func (o *ChangeCSVStateRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeCSVStateOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.State = op.State
}
func (o *ChangeCSVStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeCSVStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeCSVStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeCSVStateResponse structure represents the ApiChangeCsvState operation response
type ChangeCSVStateResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiChangeCsvState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeCSVStateResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeCSVStateOperation {
	if o == nil {
		return &xxx_ChangeCSVStateOperation{}
	}
	return &xxx_ChangeCSVStateOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ChangeCSVStateResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeCSVStateOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ChangeCSVStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeCSVStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeCSVStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNodeEnumExOperation structure represents the ApiCreateNodeEnumEx operation
type xxx_CreateNodeEnumExOperation struct {
	Node           *Node     `idl:"name:hNode" json:"node"`
	Type           uint32    `idl:"name:dwType" json:"type"`
	Options        uint32    `idl:"name:dwOptions" json:"options"`
	ReturnIDEnum   *EnumList `idl:"name:ReturnIdEnum" json:"return_id_enum"`
	ReturnNameEnum *EnumList `idl:"name:ReturnNameEnum" json:"return_name_enum"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNodeEnumExOperation) OpNum() int { return 124 }

func (o *xxx_CreateNodeEnumExOperation) OpName() string { return "/clusapi3/v3/ApiCreateNodeEnumEx" }

func (o *xxx_CreateNodeEnumExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnIdEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnIDEnum != nil {
			_ptr_ReturnIdEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnIDEnum != nil {
					if err := o.ReturnIDEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnIDEnum, _ptr_ReturnIdEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReturnNameEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnNameEnum != nil {
			_ptr_ReturnNameEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnNameEnum != nil {
					if err := o.ReturnNameEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnNameEnum, _ptr_ReturnNameEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNodeEnumExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnIdEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnIdEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnIDEnum == nil {
				o.ReturnIDEnum = &EnumList{}
			}
			if err := o.ReturnIDEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnIdEnum := func(ptr interface{}) { o.ReturnIDEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnIDEnum, _s_ReturnIdEnum, _ptr_ReturnIdEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReturnNameEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnNameEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnNameEnum == nil {
				o.ReturnNameEnum = &EnumList{}
			}
			if err := o.ReturnNameEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnNameEnum := func(ptr interface{}) { o.ReturnNameEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnNameEnum, _s_ReturnNameEnum, _ptr_ReturnNameEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateNodeEnumExRequest structure represents the ApiCreateNodeEnumEx operation request
type CreateNodeEnumExRequest struct {
	// hNode: An HNODE_RPC context handle that was obtained in a previous ApiOpenNode (Opnum
	// 66) or ApiOpenNodeEx (Opnum 118) method call.
	Node *Node `idl:"name:hNode" json:"node"`
	// dwType: The type of enumeration to be returned by the server. This value MUST be
	// set to the bitwise OR operator of one or more of the following values:
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|                   VALUE                    |                                     MEANING                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_NODE_ENUM_NETINTERFACES 0x00000001 | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                            | enumeration of IDs, in ReturnIdEnum, representing one or more cluster network    |
	//	|                                            | interfaces installed on the specified node. Each element of ReturnIdEnum that    |
	//	|                                            | sets dwType to CLUSTER_NODE_ENUM_NETINTERFACES contains the ID of the cluster    |
	//	|                                            | network interface as if the CLUSCTL_NETINTERFACE_GET_ID control code is sent     |
	//	|                                            | to the cluster network interface represented by the name in the corresponding    |
	//	|                                            | element of the ReturnNameEnum.                                                   |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_NODE_ENUM_GROUPS 0x00000002        | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                            | enumeration of IDs, in ReturnIdEnum, representing one or more cluster groups     |
	//	|                                            | currently owned by the specified node. Each element of ReturnIdEnum that sets    |
	//	|                                            | dwType to CLUSTER_NODE_ENUM_GROUPS contains the ID of the cluster group as if    |
	//	|                                            | the CLUSCTL_GROUP_GET_ID control code is sent to the cluster group represented   |
	//	|                                            | by the name in the corresponding element of the ReturnNameEnum.                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	Type uint32 `idl:"name:dwType" json:"type"`
	// dwOptions: A 32-bit integer that specifies the options on the type of elements to
	// return. The client MUST set this value to 0x00000000. The server MUST fail the call
	// if this parameter is not set to 0x00000000.
	Options uint32 `idl:"name:dwOptions" json:"options"`
}

func (o *CreateNodeEnumExRequest) xxx_ToOp(ctx context.Context) *xxx_CreateNodeEnumExOperation {
	if o == nil {
		return &xxx_CreateNodeEnumExOperation{}
	}
	return &xxx_CreateNodeEnumExOperation{
		Node:    o.Node,
		Type:    o.Type,
		Options: o.Options,
	}
}

func (o *CreateNodeEnumExRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateNodeEnumExOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.Type = op.Type
	o.Options = op.Options
}
func (o *CreateNodeEnumExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNodeEnumExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNodeEnumExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNodeEnumExResponse structure represents the ApiCreateNodeEnumEx operation response
type CreateNodeEnumExResponse struct {
	// ReturnIdEnum: A pointer to an ENUM_LIST (section 2.2.3.5) that contains IDs of the
	// objects that match the enumeration type that is indicated by the dwType parameter.
	// The server MUST allocate as much memory as is required to return the enumeration
	// data. If the method fails, this parameter MUST be ignored.
	ReturnIDEnum *EnumList `idl:"name:ReturnIdEnum" json:"return_id_enum"`
	// ReturnNameEnum: A pointer to an ENUM_LIST (section 2.2.3.5) that contains the names
	// of the objects that match the enumeration type that is indicated by the dwType parameter.
	// The server MUST allocate as much memory as is required to return the enumeration
	// data. If the method fails, this parameter MUST be ignored.
	ReturnNameEnum *EnumList `idl:"name:ReturnNameEnum" json:"return_name_enum"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether the runtime succeeded in executing
	// this method on the server. The encoding of the value passed in this parameter MUST
	// conform to encoding for comm_status and fault_status, as specified in Appendix E
	// of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNodeEnumEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateNodeEnumExResponse) xxx_ToOp(ctx context.Context) *xxx_CreateNodeEnumExOperation {
	if o == nil {
		return &xxx_CreateNodeEnumExOperation{}
	}
	return &xxx_CreateNodeEnumExOperation{
		ReturnIDEnum:   o.ReturnIDEnum,
		ReturnNameEnum: o.ReturnNameEnum,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *CreateNodeEnumExResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateNodeEnumExOperation) {
	if o == nil {
		return
	}
	o.ReturnIDEnum = op.ReturnIDEnum
	o.ReturnNameEnum = op.ReturnNameEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNodeEnumExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNodeEnumExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNodeEnumExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateEnumExOperation structure represents the ApiCreateEnumEx operation
type xxx_CreateEnumExOperation struct {
	Cluster        *Cluster  `idl:"name:hCluster" json:"cluster"`
	Type           uint32    `idl:"name:dwType" json:"type"`
	Options        uint32    `idl:"name:dwOptions" json:"options"`
	ReturnIDEnum   *EnumList `idl:"name:ReturnIdEnum" json:"return_id_enum"`
	ReturnNameEnum *EnumList `idl:"name:ReturnNameEnum" json:"return_name_enum"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateEnumExOperation) OpNum() int { return 125 }

func (o *xxx_CreateEnumExOperation) OpName() string { return "/clusapi3/v3/ApiCreateEnumEx" }

func (o *xxx_CreateEnumExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// dwOptions {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnIdEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnIDEnum != nil {
			_ptr_ReturnIdEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnIDEnum != nil {
					if err := o.ReturnIDEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnIDEnum, _ptr_ReturnIdEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReturnNameEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnNameEnum != nil {
			_ptr_ReturnNameEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnNameEnum != nil {
					if err := o.ReturnNameEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnNameEnum, _ptr_ReturnNameEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateEnumExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnIdEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnIdEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnIDEnum == nil {
				o.ReturnIDEnum = &EnumList{}
			}
			if err := o.ReturnIDEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnIdEnum := func(ptr interface{}) { o.ReturnIDEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnIDEnum, _s_ReturnIdEnum, _ptr_ReturnIdEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReturnNameEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnNameEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnNameEnum == nil {
				o.ReturnNameEnum = &EnumList{}
			}
			if err := o.ReturnNameEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnNameEnum := func(ptr interface{}) { o.ReturnNameEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnNameEnum, _s_ReturnNameEnum, _ptr_ReturnNameEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateEnumExRequest structure represents the ApiCreateEnumEx operation request
type CreateEnumExRequest struct {
	// hCluster: An HCLUSTER_RPC (section 2.2.1.1) context handle that was obtained in a
	// previous ApiOpenCluster (section 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116)
	// method call.
	Cluster *Cluster `idl:"name:hCluster" json:"cluster"`
	// dwType: The type of enumeration to be returned by the server. This value MUST be
	// set to the bitwise OR operator of one or more of the following values, except as
	// noted for CLUSTER_ENUM_INTERNAL_NETWORK.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                          |                                                                                  |
	//	|                  VALUE                   |                                     MEANING                                      |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NODE 0x00000001             | The server MUST return an enumeration of names, in ReturnNameEnum,               |
	//	|                                          | and an enumeration of IDs, in ReturnIdEnum, representing cluster nodes           |
	//	|                                          | that are members of the cluster. Each element of ReturnIdEnum that sets          |
	//	|                                          | dwType to CLUSTER_ENUM_NODE contains the ID of the cluster node as if the        |
	//	|                                          | CLUSCTL_NODE_GET_ID control code is sent to the node with the name in the        |
	//	|                                          | corresponding element of the ReturnNameEnum.                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_RESTYPE 0x00000002          | The serer MUST return an enumeration of names representing the resource types    |
	//	|                                          | installed in the cluster as the ReturnNameEnum out parameter. The server MUST    |
	//	|                                          | return an ENUM_LIST of equal length in the ReturnIdEnum out parameter with each  |
	//	|                                          | element that sets dwType to CLUSTER_ENUM_RESTYPE a zero-length null-terminated   |
	//	|                                          | Unicode string.                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_RESOURCE 0x00000004         | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                          | enumeration of IDs, in ReturnIdEnum,  representing the cluster resources. Each   |
	//	|                                          | element of ReturnIdEnum that sets dwType to CLUSTER_ENUM_RESOURCE contains       |
	//	|                                          | the ID of the cluster resource as if the CLUSCTL_RESOURCE_GET_ID control code    |
	//	|                                          | is sent to the resource with the name in the corresponding element of the        |
	//	|                                          | ReturnNameEnum.                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_GROUP 0x00000008            | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                          | enumeration of IDs, in ReturnIdEnum, of cluster groups. Each element of          |
	//	|                                          | ReturnIdEnum that sets dwType to CLUSTER_ENUM_GROUP contains the ID of the       |
	//	|                                          | cluster group as if the CLUSCTL_GROUP_GET_ID control code is sent to the group   |
	//	|                                          | with the name in the corresponding element of the ReturnNameEnum.                |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NETWORK 0x00000010          | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                          | enumeration of IDs, in ReturnIdEnum, of cluster networks. Each element of        |
	//	|                                          | ReturnIdEnum that sets dwType to CLUSTER_ENUM_NETWORK contains the ID of         |
	//	|                                          | the cluster network as if the CLUSCTL_NETWORK_GET_ID control code is sent        |
	//	|                                          | to the cluster network with the name in the corresponding element of the         |
	//	|                                          | ReturnNameEnum.                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_NETINTERFACE 0x00000020     | The server MUST return an enumeration of names, in ReturnNameEnum, and an        |
	//	|                                          | enumeration of IDs, in ReturnIdEnum, of cluster network interfaces. Each element |
	//	|                                          | of ReturnIdEnum that sets dwType to CLUSTER_ENUM_NETINTERFACE contains the ID    |
	//	|                                          | of the cluster network interface as if the CLUSCTL_NETINTERFACE_GET_ID control   |
	//	|                                          | code is sent to the cluster network interface with the name in the corresponding |
	//	|                                          | element of the ReturnNameEnum.                                                   |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_ENUM_INTERNAL_NETWORK 0x80000000 | Cannot be specified with any other value for this parameter. The server          |
	//	|                                          | MUST return an enumeration of names, in ReturnNameEnum, and an enumeration       |
	//	|                                          | of IDs, in ReturnIdEnum, of cluster networks that are used only for              |
	//	|                                          | internal communications. Each element of ReturnIdEnum that sets dwType to        |
	//	|                                          | CLUSTER_ENUM_INTERNAL_NETWORK contains the ID of the cluster network as if the   |
	//	|                                          | CLUSCTL_NETWORK_GET_ID control code is sent to the cluster network with the name |
	//	|                                          | in the corresponding element of the ReturnNameEnum.                              |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	Type uint32 `idl:"name:dwType" json:"type"`
	// dwOptions: A 32-bit integer that specifies the options on the type of elements to
	// return. The client MUST set this value to 0x00000000. The server MUST fail the call
	// if this parameter is not set to 0x00000000.
	Options uint32 `idl:"name:dwOptions" json:"options"`
}

func (o *CreateEnumExRequest) xxx_ToOp(ctx context.Context) *xxx_CreateEnumExOperation {
	if o == nil {
		return &xxx_CreateEnumExOperation{}
	}
	return &xxx_CreateEnumExOperation{
		Cluster: o.Cluster,
		Type:    o.Type,
		Options: o.Options,
	}
}

func (o *CreateEnumExRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateEnumExOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.Type = op.Type
	o.Options = op.Options
}
func (o *CreateEnumExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateEnumExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateEnumExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateEnumExResponse structure represents the ApiCreateEnumEx operation response
type CreateEnumExResponse struct {
	// ReturnIdEnum: A pointer to a PENUM_LIST (section 2.2.3.5). The pointer contains the
	// IDs of the objects that match the enumeration type that is indicated by the dwType
	// parameter. The server MUST allocate as much memory as is required to return the enumeration
	// data. If the method fails, this parameter MUST be ignored.
	ReturnIDEnum *EnumList `idl:"name:ReturnIdEnum" json:"return_id_enum"`
	// ReturnNameEnum: A pointer to a PENUM_LIST (section 2.2.3.5). The pointer contains
	// the name of the objects that match the enumeration type that is indicated by the
	// dwType parameter, except where noted above. The server MUST allocate as much memory
	// as is required to return the enumeration data. If the method fails, this parameter
	// MUST be ignored.
	ReturnNameEnum *EnumList `idl:"name:ReturnNameEnum" json:"return_name_enum"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateEnumEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateEnumExResponse) xxx_ToOp(ctx context.Context) *xxx_CreateEnumExOperation {
	if o == nil {
		return &xxx_CreateEnumExOperation{}
	}
	return &xxx_CreateEnumExOperation{
		ReturnIDEnum:   o.ReturnIDEnum,
		ReturnNameEnum: o.ReturnNameEnum,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *CreateEnumExResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateEnumExOperation) {
	if o == nil {
		return
	}
	o.ReturnIDEnum = op.ReturnIDEnum
	o.ReturnNameEnum = op.ReturnNameEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateEnumExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateEnumExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateEnumExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PauseNodeExOperation structure represents the ApiPauseNodeEx operation
type xxx_PauseNodeExOperation struct {
	Node       *Node  `idl:"name:hNode" json:"node"`
	DrainNode  bool   `idl:"name:bDrainNode" json:"drain_node"`
	PauseFlags uint32 `idl:"name:dwPauseFlags" json:"pause_flags"`
	RPCStatus  uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_PauseNodeExOperation) OpNum() int { return 126 }

func (o *xxx_PauseNodeExOperation) OpName() string { return "/clusapi3/v3/ApiPauseNodeEx" }

func (o *xxx_PauseNodeExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// bDrainNode {in} (1:{alias=BOOL}(int32))
	{
		if !o.DrainNode {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// dwPauseFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PauseFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// bDrainNode {in} (1:{alias=BOOL}(int32))
	{
		var _bDrainNode int32
		if err := w.ReadData(&_bDrainNode); err != nil {
			return err
		}
		o.DrainNode = _bDrainNode != 0
	}
	// dwPauseFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PauseFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PauseNodeExRequest structure represents the ApiPauseNodeEx operation request
type PauseNodeExRequest struct {
	// hNode: An HNODE_RPC context handle that was obtained in a previous call to ApiOpenNode
	// (section 3.1.4.1.67) or ApiOpenNodeEx (section 3.1.4.2.117).
	Node *Node `idl:"name:hNode" json:"node"`
	// bDrainNode: Indicates whether to evacuate the node. If set to TRUE, the server MUST
	// evacuate the node specified by the hNode parameter as specified in this section.
	DrainNode bool `idl:"name:bDrainNode" json:"drain_node"`
	// dwPauseFlags: This parameter can be set to CLUSAPI_NODE_PAUSE_REMAIN_ON_PAUSED_NODE_ON_MOVE_ERROR
	// (0x00000001), indicating that the server MUST allow a group to remain on the node
	// designated by the hNode parameter if policies prohibit moving the group to any other
	// nodes that are in the ClusterNodeUp state. Otherwise, this parameter MUST be set
	// to zero. The server MUST ignore the value of this parameter entirely if the bDrainNode
	// parameter is set to FALSE.
	PauseFlags uint32 `idl:"name:dwPauseFlags" json:"pause_flags"`
}

func (o *PauseNodeExRequest) xxx_ToOp(ctx context.Context) *xxx_PauseNodeExOperation {
	if o == nil {
		return &xxx_PauseNodeExOperation{}
	}
	return &xxx_PauseNodeExOperation{
		Node:       o.Node,
		DrainNode:  o.DrainNode,
		PauseFlags: o.PauseFlags,
	}
}

func (o *PauseNodeExRequest) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeExOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.DrainNode = op.DrainNode
	o.PauseFlags = op.PauseFlags
}
func (o *PauseNodeExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *PauseNodeExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PauseNodeExResponse structure represents the ApiPauseNodeEx operation response
type PauseNodeExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiPauseNodeEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *PauseNodeExResponse) xxx_ToOp(ctx context.Context) *xxx_PauseNodeExOperation {
	if o == nil {
		return &xxx_PauseNodeExOperation{}
	}
	return &xxx_PauseNodeExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *PauseNodeExResponse) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *PauseNodeExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *PauseNodeExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PauseNodeWithDrainTargetOperation structure represents the ApiPauseNodeWithDrainTarget operation
type xxx_PauseNodeWithDrainTargetOperation struct {
	Node            *Node  `idl:"name:hNode" json:"node"`
	PauseFlags      uint32 `idl:"name:dwPauseFlags" json:"pause_flags"`
	NodeDrainTarget *Node  `idl:"name:hNodeDrainTarget" json:"node_drain_target"`
	RPCStatus       uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_PauseNodeWithDrainTargetOperation) OpNum() int { return 127 }

func (o *xxx_PauseNodeWithDrainTargetOperation) OpName() string {
	return "/clusapi3/v3/ApiPauseNodeWithDrainTarget"
}

func (o *xxx_PauseNodeWithDrainTargetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeWithDrainTargetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwPauseFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PauseFlags); err != nil {
			return err
		}
	}
	// hNodeDrainTarget {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NodeDrainTarget != nil {
			if err := o.NodeDrainTarget.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_PauseNodeWithDrainTargetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwPauseFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PauseFlags); err != nil {
			return err
		}
	}
	// hNodeDrainTarget {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.NodeDrainTarget == nil {
			o.NodeDrainTarget = &Node{}
		}
		if err := o.NodeDrainTarget.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeWithDrainTargetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeWithDrainTargetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PauseNodeWithDrainTargetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PauseNodeWithDrainTargetRequest structure represents the ApiPauseNodeWithDrainTarget operation request
type PauseNodeWithDrainTargetRequest struct {
	// hNode: An HNODE_RPC context handle that was obtained in a previous call to ApiOpenNode
	// (section 3.1.4.1.67) or ApiOpenNodeEx (section 3.1.4.2.117).
	Node *Node `idl:"name:hNode" json:"node"`
	// dwPauseFlags: This parameter can be set to CLUSAPI_NODE_PAUSE_REMAIN_ON_PAUSED_NODE_ON_MOVE_ERROR
	// (0x00000001), indicating that the server MUST allow a group to remain on the node
	// designated by the hNode parameter if policies prohibit moving the group to the node
	// designated by the hNodeDrainTarget parameter. Otherwise, this parameter MUST be set
	// to zero.
	PauseFlags uint32 `idl:"name:dwPauseFlags" json:"pause_flags"`
	// hNodeDrainTarget: An HNODE_RPC context handle to the destination node, obtained in
	// a previous call to ApiOpenNode (section 3.1.4.1.67) or ApiOpenNodeEx (section 3.1.4.2.117).
	// The hNodeDrainTarget parameter MUST NOT specify the same node as the hNode parameter.
	NodeDrainTarget *Node `idl:"name:hNodeDrainTarget" json:"node_drain_target"`
}

func (o *PauseNodeWithDrainTargetRequest) xxx_ToOp(ctx context.Context) *xxx_PauseNodeWithDrainTargetOperation {
	if o == nil {
		return &xxx_PauseNodeWithDrainTargetOperation{}
	}
	return &xxx_PauseNodeWithDrainTargetOperation{
		Node:            o.Node,
		PauseFlags:      o.PauseFlags,
		NodeDrainTarget: o.NodeDrainTarget,
	}
}

func (o *PauseNodeWithDrainTargetRequest) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeWithDrainTargetOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.PauseFlags = op.PauseFlags
	o.NodeDrainTarget = op.NodeDrainTarget
}
func (o *PauseNodeWithDrainTargetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *PauseNodeWithDrainTargetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeWithDrainTargetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PauseNodeWithDrainTargetResponse structure represents the ApiPauseNodeWithDrainTarget operation response
type PauseNodeWithDrainTargetResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiPauseNodeWithDrainTarget return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *PauseNodeWithDrainTargetResponse) xxx_ToOp(ctx context.Context) *xxx_PauseNodeWithDrainTargetOperation {
	if o == nil {
		return &xxx_PauseNodeWithDrainTargetOperation{}
	}
	return &xxx_PauseNodeWithDrainTargetOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *PauseNodeWithDrainTargetResponse) xxx_FromOp(ctx context.Context, op *xxx_PauseNodeWithDrainTargetOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *PauseNodeWithDrainTargetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *PauseNodeWithDrainTargetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PauseNodeWithDrainTargetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ResumeNodeExOperation structure represents the ApiResumeNodeEx operation
type xxx_ResumeNodeExOperation struct {
	Node                *Node  `idl:"name:hNode" json:"node"`
	ResumeFailbackType  uint32 `idl:"name:dwResumeFailbackType" json:"resume_failback_type"`
	ResumeFlagsReserved uint32 `idl:"name:dwResumeFlagsReserved" json:"resume_flags_reserved"`
	RPCStatus           uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return              uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ResumeNodeExOperation) OpNum() int { return 128 }

func (o *xxx_ResumeNodeExOperation) OpName() string { return "/clusapi3/v3/ApiResumeNodeEx" }

func (o *xxx_ResumeNodeExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwResumeFailbackType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ResumeFailbackType); err != nil {
			return err
		}
	}
	// dwResumeFlagsReserved {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ResumeFlagsReserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwResumeFailbackType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ResumeFailbackType); err != nil {
			return err
		}
	}
	// dwResumeFlagsReserved {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ResumeFlagsReserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ResumeNodeExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ResumeNodeExRequest structure represents the ApiResumeNodeEx operation request
type ResumeNodeExRequest struct {
	Node                *Node  `idl:"name:hNode" json:"node"`
	ResumeFailbackType  uint32 `idl:"name:dwResumeFailbackType" json:"resume_failback_type"`
	ResumeFlagsReserved uint32 `idl:"name:dwResumeFlagsReserved" json:"resume_flags_reserved"`
}

func (o *ResumeNodeExRequest) xxx_ToOp(ctx context.Context) *xxx_ResumeNodeExOperation {
	if o == nil {
		return &xxx_ResumeNodeExOperation{}
	}
	return &xxx_ResumeNodeExOperation{
		Node:                o.Node,
		ResumeFailbackType:  o.ResumeFailbackType,
		ResumeFlagsReserved: o.ResumeFlagsReserved,
	}
}

func (o *ResumeNodeExRequest) xxx_FromOp(ctx context.Context, op *xxx_ResumeNodeExOperation) {
	if o == nil {
		return
	}
	o.Node = op.Node
	o.ResumeFailbackType = op.ResumeFailbackType
	o.ResumeFlagsReserved = op.ResumeFlagsReserved
}
func (o *ResumeNodeExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ResumeNodeExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResumeNodeExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ResumeNodeExResponse structure represents the ApiResumeNodeEx operation response
type ResumeNodeExResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiResumeNodeEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ResumeNodeExResponse) xxx_ToOp(ctx context.Context) *xxx_ResumeNodeExOperation {
	if o == nil {
		return &xxx_ResumeNodeExOperation{}
	}
	return &xxx_ResumeNodeExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ResumeNodeExResponse) xxx_FromOp(ctx context.Context, op *xxx_ResumeNodeExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ResumeNodeExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ResumeNodeExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ResumeNodeExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupExOperation structure represents the ApiCreateGroupEx operation
type xxx_CreateGroupExOperation struct {
	GroupName string                     `idl:"name:lpszGroupName;string" json:"group_name"`
	GroupInfo *ClusterCreateGroupInfoRPC `idl:"name:pGroupInfo;pointer:unique" json:"group_info"`
	Status    uint32                     `idl:"name:Status" json:"status"`
	RPCStatus uint32                     `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Group                     `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupExOperation) OpNum() int { return 129 }

func (o *xxx_CreateGroupExOperation) OpName() string { return "/clusapi3/v3/ApiCreateGroupEx" }

func (o *xxx_CreateGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	// pGroupInfo {in} (1:{pointer=unique, alias=PCLUSTER_CREATE_GROUP_INFO_RPC}*(1))(2:{alias=CLUSTER_CREATE_GROUP_INFO_RPC}(struct))
	{
		if o.GroupInfo != nil {
			_ptr_pGroupInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.GroupInfo != nil {
					if err := o.GroupInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ClusterCreateGroupInfoRPC{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupInfo, _ptr_pGroupInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	// pGroupInfo {in} (1:{pointer=unique, alias=PCLUSTER_CREATE_GROUP_INFO_RPC}*(1))(2:{alias=CLUSTER_CREATE_GROUP_INFO_RPC}(struct))
	{
		_ptr_pGroupInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.GroupInfo == nil {
				o.GroupInfo = &ClusterCreateGroupInfoRPC{}
			}
			if err := o.GroupInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pGroupInfo := func(ptr interface{}) { o.GroupInfo = *ptr.(**ClusterCreateGroupInfoRPC) }
		if err := w.ReadPointer(&o.GroupInfo, _s_pGroupInfo, _ptr_pGroupInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Group{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupExRequest structure represents the ApiCreateGroupEx operation request
type CreateGroupExRequest struct {
	// lpszGroupName: A Unicode string that is the name associated with the group.
	GroupName string `idl:"name:lpszGroupName;string" json:"group_name"`
	// pGroupInfo: Contains information about the group to be created. The client MUST set
	// the dwVersion field of the CLUSTER_CREATE_GROUP_INFO_RPC (section 2.2.3.21) to 0x00000001.
	// Except for the following reserved values, the client sets the dwGroupType field to
	// an arbitrary value that the client can use to associate meaning or context with the
	// group. Upon successful creation of the group, the server MUST set the group type
	// to the value specified by the client and the server MUST treat all values identically.
	// If a client does not need to associate any particular meaning or context with the
	// group, the client SHOULD set the group type to 0x0000270F (ClusGroupTypeUnknown).
	//
	//	+-----------------------------------+-------------------------+
	//	|                                   |                         |
	//	|               VALUE               |       DESCRIPTION       |
	//	|                                   |                         |
	//	+-----------------------------------+-------------------------+
	//	+-----------------------------------+-------------------------+
	//	| 0x00000001 ClusGroupTypeReserved1 | Reserved for local use. |
	//	+-----------------------------------+-------------------------+
	//	| 0x00000002 ClusGroupTypeReserved2 | Reserved for local use. |
	//	+-----------------------------------+-------------------------+
	//	| 0x00000004 ClusGroupTypeReserved3 | Reserved for local use. |
	//	+-----------------------------------+-------------------------+
	//	| 0x00000005 ClusGroupTypeReserved4 | Reserved for local use. |
	//	+-----------------------------------+-------------------------+
	GroupInfo *ClusterCreateGroupInfoRPC `idl:"name:pGroupInfo;pointer:unique" json:"group_info"`
}

func (o *CreateGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupExOperation {
	if o == nil {
		return &xxx_CreateGroupExOperation{}
	}
	return &xxx_CreateGroupExOperation{
		GroupName: o.GroupName,
		GroupInfo: o.GroupInfo,
	}
}

func (o *CreateGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupExOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
	o.GroupInfo = op.GroupInfo
}
func (o *CreateGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupExResponse structure represents the ApiCreateGroupEx operation response
type CreateGroupExResponse struct {
	// Status: Indicates the status of this operation. The server MUST set this parameter
	// to one of the following error codes:
	//
	//	+----------------------------------------+--------------------------------------------------------------------+
	//	|                                        |                                                                    |
	//	|                 VALUE                  |                            DESCRIPTION                             |
	//	|                                        |                                                                    |
	//	+----------------------------------------+--------------------------------------------------------------------+
	//	+----------------------------------------+--------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS               | The operation completed successfully.                              |
	//	+----------------------------------------+--------------------------------------------------------------------+
	//	| 0x00000046 ERROR_SHARING_PAUSED        | The remote server is paused or is in the process of being started. |
	//	+----------------------------------------+--------------------------------------------------------------------+
	//	| 0x00001392 ERROR_OBJECT_ALREADY_EXISTS | A group with the designated name already exists.                   |
	//	+----------------------------------------+--------------------------------------------------------------------+
	Status uint32 `idl:"name:Status" json:"status"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroupEx return value.
	Return *Group `idl:"name:Return" json:"return"`
}

func (o *CreateGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupExOperation {
	if o == nil {
		return &xxx_CreateGroupExOperation{}
	}
	return &xxx_CreateGroupExOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupExOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OnlineGroupExOperation structure represents the ApiOnlineGroupEx operation
type xxx_OnlineGroupExOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	OnlineFlags    uint32 `idl:"name:dwOnlineFlags" json:"online_flags"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_OnlineGroupExOperation) OpNum() int { return 130 }

func (o *xxx_OnlineGroupExOperation) OpName() string { return "/clusapi3/v3/ApiOnlineGroupEx" }

func (o *xxx_OnlineGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwOnlineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OnlineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwOnlineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OnlineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OnlineGroupExRequest structure represents the ApiOnlineGroupEx operation request
type OnlineGroupExRequest struct {
	// hGroup: An HGROUP_RPC context handle that was obtained in a previous call to ApiOpenGroup
	// (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup (section
	// 3.1.4.2.43).
	Group *Group `idl:"name:hGroup" json:"group"`
	// dwOnlineFlags: A bitwise-OR of zero or more of the following flags.
	//
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                        |                                                                                  |
	//	|                         VALUE                          |                                   DESCRIPTION                                    |
	//	|                                                        |                                                                                  |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 CLUSAPI_GROUP_ONLINE_IGNORE_RESOURCE_STATUS | The server MUST ignore the locked mode of the group as specified in section      |
	//	|                                                        | 3.1.1.1.4.                                                                       |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 CLUSAPI_GROUP_ONLINE_SYNCHRONOUS            | The server MUST perform the operation synchronously to bring the group           |
	//	|                                                        | online.<110>                                                                     |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 CLUSAPI_GROUP_ONLINE_BEST_POSSIBLE_NODE     | The server MUST determine the best possible node that will host the group when   |
	//	|                                                        | it is brought online.<111>                                                       |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 CLUSAPI_GROUP_ONLINE_IGNORE_AFFINITY_RULE   | The server MUST ignore the affinity rule of the group.<112>                      |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	OnlineFlags uint32 `idl:"name:dwOnlineFlags" json:"online_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client SHOULD set the property name to the name of the resource
	// type of one of the resources in the group. The client MAY provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client MAY provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	//
	//	+-----------------+-------------------------+------------+-------------------------+
	//	|    PROPERTY     |                         |            |                         |
	//	|      NAME       | CLUSTER PROPERTY FORMAT |   VALUE    |       DESCRIPTION       |
	//	|                 |                         |            |                         |
	//	+-----------------+-------------------------+------------+-------------------------+
	//	+-----------------+-------------------------+------------+-------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000004 | Reserved for local use. |
	//	+-----------------+-------------------------+------------+-------------------------+
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *OnlineGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_OnlineGroupExOperation {
	if o == nil {
		return &xxx_OnlineGroupExOperation{}
	}
	return &xxx_OnlineGroupExOperation{
		Group:          o.Group,
		OnlineFlags:    o.OnlineFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *OnlineGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_OnlineGroupExOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.OnlineFlags = op.OnlineFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *OnlineGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OnlineGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OnlineGroupExResponse structure represents the ApiOnlineGroupEx operation response
type OnlineGroupExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOnlineGroupEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OnlineGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_OnlineGroupExOperation {
	if o == nil {
		return &xxx_OnlineGroupExOperation{}
	}
	return &xxx_OnlineGroupExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OnlineGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_OnlineGroupExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OnlineGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OnlineGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OfflineGroupExOperation structure represents the ApiOfflineGroupEx operation
type xxx_OfflineGroupExOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	OfflineFlags   uint32 `idl:"name:dwOfflineFlags" json:"offline_flags"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_OfflineGroupExOperation) OpNum() int { return 131 }

func (o *xxx_OfflineGroupExOperation) OpName() string { return "/clusapi3/v3/ApiOfflineGroupEx" }

func (o *xxx_OfflineGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwOfflineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OfflineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwOfflineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OfflineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OfflineGroupExRequest structure represents the ApiOfflineGroupEx operation request
type OfflineGroupExRequest struct {
	// hGroup: An HGROUP_RPC context handle that was obtained in a previous call to ApiOpenGroup
	// (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup (section
	// 3.1.4.2.43).
	Group *Group `idl:"name:hGroup" json:"group"`
	// dwOfflineFlags: Either CLUSAPI_GROUP_OFFLINE_IGNORE_RESOURCE_STATUS (0x00000001),
	// if the client needs the server to ignore the locked mode for the group specified
	// by the hGroup parameter (section 3.1.1.1.4), or zero.
	OfflineFlags uint32 `idl:"name:dwOfflineFlags" json:"offline_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client SHOULD set the property name to the name of the resource
	// type of one of the resources in the group. The client MAY provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client MAY provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	//
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	|    PROPERTY     |                         |            |                                                                                  |
	//	|      NAME       | CLUSTER PROPERTY FORMAT |   VALUE    |                                   DESCRIPTION                                    |
	//	|                 |                         |            |                                                                                  |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000000 | For a resource of type "Virtual Machine" in the group that is in the             |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST turn off the   |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000001 | For a resource of type "Virtual Machine" in the group that is in the             |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST save the       |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000002 | For a resource of type "Virtual Machine" in the group that is in the             |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST shut down the  |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000003 | For a resource of type "Virtual Machine" in the group that is in the             |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST forcibly shut  |
	//	|                 |                         |            | down the corresponding virtual machine.                                          |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000004 | Reserved.                                                                        |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *OfflineGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_OfflineGroupExOperation {
	if o == nil {
		return &xxx_OfflineGroupExOperation{}
	}
	return &xxx_OfflineGroupExOperation{
		Group:          o.Group,
		OfflineFlags:   o.OfflineFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *OfflineGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_OfflineGroupExOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.OfflineFlags = op.OfflineFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *OfflineGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OfflineGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OfflineGroupExResponse structure represents the ApiOfflineGroupEx operation response
type OfflineGroupExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOfflineGroupEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OfflineGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_OfflineGroupExOperation {
	if o == nil {
		return &xxx_OfflineGroupExOperation{}
	}
	return &xxx_OfflineGroupExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OfflineGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_OfflineGroupExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OfflineGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OfflineGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_MoveGroupExOperation structure represents the ApiMoveGroupEx operation
type xxx_MoveGroupExOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	MoveFlags      uint32 `idl:"name:dwMoveFlags" json:"move_flags"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_MoveGroupExOperation) OpNum() int { return 132 }

func (o *xxx_MoveGroupExOperation) OpName() string { return "/clusapi3/v3/ApiMoveGroupEx" }

func (o *xxx_MoveGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwMoveFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MoveFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwMoveFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MoveFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// MoveGroupExRequest structure represents the ApiMoveGroupEx operation request
type MoveGroupExRequest struct {
	// hGroup: An HGROUP_RPC context handle that was obtained in a previous call to ApiOpenGroup
	// (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup (section
	// 3.1.4.2.43).
	Group *Group `idl:"name:hGroup" json:"group"`
	// dwMoveFlags: A bitwise-OR of zero or more of the following flags, with the exception
	// that CLUSAPI_GROUP_MOVE_IGNORE_RESOURCE_STATUS and CLUSAPI_GROUP_MOVE_QUEUE_ENABLED
	// cannot be specified together and MUST be rejected by the server with the error 0x00000057
	// (ERROR_INVALID_PARAMETER).
	//
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                              |                                                                                  |
	//	|                            VALUE                             |                                   DESCRIPTION                                    |
	//	|                                                              |                                                                                  |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 CLUSAPI_GROUP_MOVE_IGNORE_RESOURCE_STATUS         | The server MUST ignore the group locked mode as specified in section 3.1.1.1.4.  |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 CLUSAPI_GROUP_MOVE_RETURN_TO_SOURCE_NODE_ON_ERROR | If the designated group cannot be brought to its persistent state on the         |
	//	|                                                              | destination node selected by the server, the server MUST move the group back to  |
	//	|                                                              | the source node and bring the group to its persistent state on the source node.  |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 CLUSAPI_GROUP_MOVE_QUEUE_ENABLED                  | If server implementation-specific policies preclude the move operation from      |
	//	|                                                              | proceeding, the server MUST retry the move operation until either the move       |
	//	|                                                              | succeeds, or the move fails due to a different reason, or the move is canceled.  |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 CLUSAPI_GROUP_MOVE_HIGH_PRIORITY_START            | When bringing the group to its persistent state on the destination node, the     |
	//	|                                                              | server SHOULD bring this group to its persistent state as soon as possible       |
	//	|                                                              | without regard to implementation-specific policies that govern the ordering      |
	//	|                                                              | and/or prioritization of bringing groups to their persistent states.             |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSAPI_GROUP_MOVE_FAILBACK 0x00000010                       | If move group operation fails, the server MUST perform failback operation.       |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSAPI_GROUP_MOVE_IGNORE_AFFINITY_RULE 0x00000020           | The server MUST ignore the affinity rule while performing move group             |
	//	|                                                              | operation.<115>                                                                  |
	//	+--------------------------------------------------------------+----------------------------------------------------------------------------------+
	MoveFlags uint32 `idl:"name:dwMoveFlags" json:"move_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client sets the property name to the name of the resource
	// type of one of the resources in the group. The client MAY provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client MAY provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	//
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	|    PROPERTY     |                         |            |                                                                                  |
	//	|      NAME       | CLUSTER PROPERTY FORMAT |   VALUE    |                                   DESCRIPTION                                    |
	//	|                 |                         |            |                                                                                  |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000000 | For a resource of resource type "Virtual Machine" in the group that is in the    |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST turn off the   |
	//	|                 |                         |            | corresponding virtual machine on the source node of the move operation.          |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000001 | For a resource of resource type "Virtual Machine" in the group that is in the    |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST save the       |
	//	|                 |                         |            | corresponding virtual machine on the source node of the move operation.          |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000002 | For a resource of resource type "Virtual Machine" in the group that is in the    |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST shut down the  |
	//	|                 |                         |            | corresponding virtual machine on the source node of the move operation.          |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000003 | For a resource of resource type "Virtual Machine" in the group that is in the    |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST forcibly shut  |
	//	|                 |                         |            | down the corresponding virtual machine on the source node of the move operation. |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000004 | For a resource of resource type "Virtual Machine" in the group that is in the    |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST migrate the    |
	//	|                 |                         |            | corresponding virtual machine to a destination node chosen by the server. If     |
	//	|                 |                         |            | the client includes this property value in the lpInBuffer parameter, the client  |
	//	|                 |                         |            | SHOULD also enable the CLUSAPI_GROUP_MOVE_RETURN_TO_SOURCE_NODE_ON_ERROR,        |
	//	|                 |                         |            | CLUSAPI_GROUP_MOVE_QUEUE_ENABLED, and CLUSAPI_GROUP_MOVE_HIGH_PRIORITY_START     |
	//	|                 |                         |            | flags in the dwMoveFlags parameter.                                              |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *MoveGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_MoveGroupExOperation {
	if o == nil {
		return &xxx_MoveGroupExOperation{}
	}
	return &xxx_MoveGroupExOperation{
		Group:          o.Group,
		MoveFlags:      o.MoveFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *MoveGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupExOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.MoveFlags = op.MoveFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *MoveGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *MoveGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// MoveGroupExResponse structure represents the ApiMoveGroupEx operation response
type MoveGroupExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiMoveGroupEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *MoveGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_MoveGroupExOperation {
	if o == nil {
		return &xxx_MoveGroupExOperation{}
	}
	return &xxx_MoveGroupExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *MoveGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *MoveGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *MoveGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_MoveGroupToNodeExOperation structure represents the ApiMoveGroupToNodeEx operation
type xxx_MoveGroupToNodeExOperation struct {
	Group          *Group `idl:"name:hGroup" json:"group"`
	Node           *Node  `idl:"name:hNode" json:"node"`
	MoveFlags      uint32 `idl:"name:dwMoveFlags" json:"move_flags"`
	InBuffer       []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_MoveGroupToNodeExOperation) OpNum() int { return 133 }

func (o *xxx_MoveGroupToNodeExOperation) OpName() string { return "/clusapi3/v3/ApiMoveGroupToNodeEx" }

func (o *xxx_MoveGroupToNodeExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwMoveFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MoveFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwMoveFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MoveFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToNodeExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// MoveGroupToNodeExRequest structure represents the ApiMoveGroupToNodeEx operation request
type MoveGroupToNodeExRequest struct {
	// hGroup: An HGROUP_RPC context handle that was obtained in a previous call to ApiOpenGroup
	// (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup (section
	// 3.1.4.2.43).
	Group *Group `idl:"name:hGroup" json:"group"`
	// hNode: An HNODE_RPC context handle that was obtained in a previous call to ApiOpenNode
	// (section 3.1.4.2.67) or ApiOpenNodeEx (section 3.1.4.2.117), indicating the node
	// that will take ownership of the group specified in the hGroup parameter.
	Node *Node `idl:"name:hNode" json:"node"`
	// dwMoveFlags: The available values for this parameter are identical to those specified
	// for the ApiMoveGroupEx (section 3.1.4.2.131) method.
	MoveFlags uint32 `idl:"name:dwMoveFlags" json:"move_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client sets the property name to the name of the resource
	// type of one of the resources in the group. The client can provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client can provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *MoveGroupToNodeExRequest) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToNodeExOperation {
	if o == nil {
		return &xxx_MoveGroupToNodeExOperation{}
	}
	return &xxx_MoveGroupToNodeExOperation{
		Group:          o.Group,
		Node:           o.Node,
		MoveFlags:      o.MoveFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *MoveGroupToNodeExRequest) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToNodeExOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.Node = op.Node
	o.MoveFlags = op.MoveFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *MoveGroupToNodeExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *MoveGroupToNodeExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToNodeExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// MoveGroupToNodeExResponse structure represents the ApiMoveGroupToNodeEx operation response
type MoveGroupToNodeExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiMoveGroupToNodeEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *MoveGroupToNodeExResponse) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToNodeExOperation {
	if o == nil {
		return &xxx_MoveGroupToNodeExOperation{}
	}
	return &xxx_MoveGroupToNodeExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *MoveGroupToNodeExResponse) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToNodeExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *MoveGroupToNodeExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *MoveGroupToNodeExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToNodeExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CancelClusterGroupOperationOperation structure represents the ApiCancelClusterGroupOperation operation
type xxx_CancelClusterGroupOperationOperation struct {
	Group       *Group `idl:"name:hGroup" json:"group"`
	CancelFlags uint32 `idl:"name:dwCancelFlags" json:"cancel_flags"`
	RPCStatus   uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CancelClusterGroupOperationOperation) OpNum() int { return 134 }

func (o *xxx_CancelClusterGroupOperationOperation) OpName() string {
	return "/clusapi3/v3/ApiCancelClusterGroupOperation"
}

func (o *xxx_CancelClusterGroupOperationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CancelClusterGroupOperationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwCancelFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.CancelFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CancelClusterGroupOperationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwCancelFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.CancelFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CancelClusterGroupOperationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CancelClusterGroupOperationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CancelClusterGroupOperationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CancelClusterGroupOperationRequest structure represents the ApiCancelClusterGroupOperation operation request
type CancelClusterGroupOperationRequest struct {
	// hGroup: An HGROUP_RPC context handle that was obtained in a previous call to ApiOpenGroup
	// (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup (section
	// 3.1.4.2.43).
	Group *Group `idl:"name:hGroup" json:"group"`
	// dwCancelFlags: Reserved. The client MUST set this parameter to 0.
	CancelFlags uint32 `idl:"name:dwCancelFlags" json:"cancel_flags"`
}

func (o *CancelClusterGroupOperationRequest) xxx_ToOp(ctx context.Context) *xxx_CancelClusterGroupOperationOperation {
	if o == nil {
		return &xxx_CancelClusterGroupOperationOperation{}
	}
	return &xxx_CancelClusterGroupOperationOperation{
		Group:       o.Group,
		CancelFlags: o.CancelFlags,
	}
}

func (o *CancelClusterGroupOperationRequest) xxx_FromOp(ctx context.Context, op *xxx_CancelClusterGroupOperationOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.CancelFlags = op.CancelFlags
}
func (o *CancelClusterGroupOperationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CancelClusterGroupOperationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CancelClusterGroupOperationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CancelClusterGroupOperationResponse structure represents the ApiCancelClusterGroupOperation operation response
type CancelClusterGroupOperationResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCancelClusterGroupOperation return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CancelClusterGroupOperationResponse) xxx_ToOp(ctx context.Context) *xxx_CancelClusterGroupOperationOperation {
	if o == nil {
		return &xxx_CancelClusterGroupOperationOperation{}
	}
	return &xxx_CancelClusterGroupOperationOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CancelClusterGroupOperationResponse) xxx_FromOp(ctx context.Context, op *xxx_CancelClusterGroupOperationOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CancelClusterGroupOperationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CancelClusterGroupOperationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CancelClusterGroupOperationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OnlineResourceExOperation structure represents the ApiOnlineResourceEx operation
type xxx_OnlineResourceExOperation struct {
	Resource       *Resource `idl:"name:hResource" json:"resource"`
	OnlineFlags    uint32    `idl:"name:dwOnlineFlags" json:"online_flags"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32    `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_OnlineResourceExOperation) OpNum() int { return 135 }

func (o *xxx_OnlineResourceExOperation) OpName() string { return "/clusapi3/v3/ApiOnlineResourceEx" }

func (o *xxx_OnlineResourceExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwOnlineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OnlineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwOnlineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OnlineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OnlineResourceExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OnlineResourceExRequest structure represents the ApiOnlineResourceEx operation request
type OnlineResourceExRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous call to ApiOpenResource
	// (section 3.1.4.2.9), ApiOpenResourceEx (section 3.1.4.2.119), or ApiCreateResource
	// (section 3.1.4.2.10).
	Resource *Resource `idl:"name:hResource" json:"resource"`
	// dwOnlineFlags: A bitwise-OR of zero or more of the following flags.
	//
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                                   |                                                                                  |
	//	|                               VALUE                               |                                   DESCRIPTION                                    |
	//	|                                                                   |                                                                                  |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 CLUSAPI_RESOURCE_ONLINE_IGNORE_RESOURCE_STATUS         | The server MUST ignore the resource locked mode as specified in section          |
	//	|                                                                   | 3.1.1.1.1.                                                                       |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 CLUSAPI_RESOURCE_ONLINE_DO_NOT_UPDATE_PERSISTENT_STATE | The server MUST not update the persistent state of the resource.                 |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 CLUSAPI_RESOURCE_ONLINE_NECESSARY_FOR_QUORUM           | The server MUST bring the resource to online to maintain a quorum.               |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 CLUSAPI_RESOURCE_ONLINE_BEST_POSSIBLE_NODE             | The server MUST determine the best possible node that will host the              |
	//	|                                                                   | resource.<119>                                                                   |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000020 CLUSAPI_RESOURCE_ONLINE_IGNORE_AFFINITY_RULE           | The server MUST ignore the affinity rule of the resource.<120>                   |
	//	+-------------------------------------------------------------------+----------------------------------------------------------------------------------+
	OnlineFlags uint32 `idl:"name:dwOnlineFlags" json:"online_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client SHOULD set the property name to the name of the resource
	// type of one of the resources in the group. The client MAY provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client MAY provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	//
	//	+-----------------+-------------------------+------------+-------------------------+
	//	|    PROPERTY     |                         |            |                         |
	//	|      NAME       | CLUSTER PROPERTY FORMAT |   VALUE    |       DESCRIPTION       |
	//	|                 |                         |            |                         |
	//	+-----------------+-------------------------+------------+-------------------------+
	//	+-----------------+-------------------------+------------+-------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000004 | Reserved for local use. |
	//	+-----------------+-------------------------+------------+-------------------------+
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *OnlineResourceExRequest) xxx_ToOp(ctx context.Context) *xxx_OnlineResourceExOperation {
	if o == nil {
		return &xxx_OnlineResourceExOperation{}
	}
	return &xxx_OnlineResourceExOperation{
		Resource:       o.Resource,
		OnlineFlags:    o.OnlineFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *OnlineResourceExRequest) xxx_FromOp(ctx context.Context, op *xxx_OnlineResourceExOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.OnlineFlags = op.OnlineFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *OnlineResourceExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OnlineResourceExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineResourceExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OnlineResourceExResponse structure represents the ApiOnlineResourceEx operation response
type OnlineResourceExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOnlineResourceEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OnlineResourceExResponse) xxx_ToOp(ctx context.Context) *xxx_OnlineResourceExOperation {
	if o == nil {
		return &xxx_OnlineResourceExOperation{}
	}
	return &xxx_OnlineResourceExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OnlineResourceExResponse) xxx_FromOp(ctx context.Context, op *xxx_OnlineResourceExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OnlineResourceExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OnlineResourceExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OnlineResourceExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OfflineResourceExOperation structure represents the ApiOfflineResourceEx operation
type xxx_OfflineResourceExOperation struct {
	Resource       *Resource `idl:"name:hResource" json:"resource"`
	OfflineFlags   uint32    `idl:"name:dwOfflineFlags" json:"offline_flags"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	InBufferLength uint32    `idl:"name:cbInBufferSize" json:"in_buffer_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_OfflineResourceExOperation) OpNum() int { return 136 }

func (o *xxx_OfflineResourceExOperation) OpName() string { return "/clusapi3/v3/ApiOfflineResourceEx" }

func (o *xxx_OfflineResourceExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferLength == 0 {
		o.InBufferLength = uint32(len(o.InBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwOfflineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OfflineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		dimSize1 := uint64(o.InBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwOfflineFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OfflineFlags); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbInBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
		}
		o.InBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.InBuffer {
			i1 := i1
			if err := w.ReadData(&o.InBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// cbInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OfflineResourceExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OfflineResourceExRequest structure represents the ApiOfflineResourceEx operation request
type OfflineResourceExRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous call to ApiOpenResource
	// (section 3.1.4.2.9), ApiOpenResourceEx (section 3.1.4.2.119), or ApiCreateResource
	// (section 3.1.4.2.10).
	Resource *Resource `idl:"name:hResource" json:"resource"`
	// dwOfflineFlags: A bitwise-OR of zero or more of the following flags.
	//
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                                    |                                                                                  |
	//	|                               VALUE                                |                                   DESCRIPTION                                    |
	//	|                                                                    |                                                                                  |
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 CLUSAPI_RESOURCE_OFFLINE_IGNORE_RESOURCE_STATUS         | The server MUST ignore the locked mode value of the resource as well as the      |
	//	|                                                                    | locked mode value of any of its dependent resources as specified in section      |
	//	|                                                                    | 3.1.1.1.2.                                                                       |
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 CLUSAPI_RESOURCE_OFFLINE_FORCE_WITH_TERMINATION         | The server MUST shut down the resource.                                          |
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 CLUSAPI_RESOURCE_OFFLINE_DO_NOT_UPDATE_PERSISTENT_STATE | The server MUST not update the persistent state of the resource when it is       |
	//	|                                                                    | brought offline.<122>                                                            |
	//	+--------------------------------------------------------------------+----------------------------------------------------------------------------------+
	OfflineFlags uint32 `idl:"name:dwOfflineFlags" json:"offline_flags"`
	// lpInBuffer: A pointer to a buffer that the server will provide to implementation-specific
	// objects that control the resource operations for each resource in the group. The
	// client SHOULD set this parameter to a PROPERTY_LIST (section 2.2.3.10). For each
	// value in this list, the client SHOULD set the property name to the name of the resource
	// type of one of the resources in the group. The client MAY provide a buffer that does
	// not have a property value corresponding to each resource type in the group, and the
	// client MAY provide a buffer that has multiple property values for the same resource
	// type. Except for the following property values, the server MUST treat all property
	// values provided by the client identically.
	//
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	|    PROPERTY     |                         |            |                                                                                  |
	//	|      NAME       | CLUSTER PROPERTY FORMAT |   VALUE    |                                   DESCRIPTION                                    |
	//	|                 |                         |            |                                                                                  |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000000 | For a resource of resource type "Virtual Machine" that is in the                 |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST turn off the   |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000001 | For a resource of resource type "Virtual Machine" that is in the                 |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST save the       |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000002 | For a resource of resource type "Virtual Machine" that is in the                 |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST shut down the  |
	//	|                 |                         |            | corresponding virtual machine.                                                   |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000003 | For a resource of resource type "Virtual Machine" that is in the                 |
	//	|                 |                         |            | ClusterResourceOnline state (section 3.1.4.2.13), the server MUST forcibly shut  |
	//	|                 |                         |            | down the corresponding virtual machine.                                          |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	//	| Virtual Machine | CLUSPROP_FORMAT_DWORD   | 0x00000000 | Reserved.                                                                        |
	//	+-----------------+-------------------------+------------+----------------------------------------------------------------------------------+
	InBuffer []byte `idl:"name:lpInBuffer;size_is:(cbInBufferSize)" json:"in_buffer"`
	// cbInBufferSize: The size in bytes of the buffer pointed to by the lpInBuffer parameter.
	InBufferLength uint32 `idl:"name:cbInBufferSize" json:"in_buffer_length"`
}

func (o *OfflineResourceExRequest) xxx_ToOp(ctx context.Context) *xxx_OfflineResourceExOperation {
	if o == nil {
		return &xxx_OfflineResourceExOperation{}
	}
	return &xxx_OfflineResourceExOperation{
		Resource:       o.Resource,
		OfflineFlags:   o.OfflineFlags,
		InBuffer:       o.InBuffer,
		InBufferLength: o.InBufferLength,
	}
}

func (o *OfflineResourceExRequest) xxx_FromOp(ctx context.Context, op *xxx_OfflineResourceExOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.OfflineFlags = op.OfflineFlags
	o.InBuffer = op.InBuffer
	o.InBufferLength = op.InBufferLength
}
func (o *OfflineResourceExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OfflineResourceExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineResourceExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OfflineResourceExResponse structure represents the ApiOfflineResourceEx operation response
type OfflineResourceExResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOfflineResourceEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OfflineResourceExResponse) xxx_ToOp(ctx context.Context) *xxx_OfflineResourceExOperation {
	if o == nil {
		return &xxx_OfflineResourceExOperation{}
	}
	return &xxx_OfflineResourceExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OfflineResourceExResponse) xxx_FromOp(ctx context.Context, op *xxx_OfflineResourceExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OfflineResourceExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OfflineResourceExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OfflineResourceExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNotifyV2Operation structure represents the ApiCreateNotifyV2 operation
type xxx_CreateNotifyV2Operation struct {
	Error     uint32  `idl:"name:rpc_error" json:"error"`
	RPCStatus uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return    *Notify `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNotifyV2Operation) OpNum() int { return 137 }

func (o *xxx_CreateNotifyV2Operation) OpName() string { return "/clusapi3/v3/ApiCreateNotifyV2" }

func (o *xxx_CreateNotifyV2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNotifyV2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_CreateNotifyV2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_CreateNotifyV2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNotifyV2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_error {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Error); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateNotifyV2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_error {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Error); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &Notify{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateNotifyV2Request structure represents the ApiCreateNotifyV2 operation request
type CreateNotifyV2Request struct {
}

func (o *CreateNotifyV2Request) xxx_ToOp(ctx context.Context) *xxx_CreateNotifyV2Operation {
	if o == nil {
		return &xxx_CreateNotifyV2Operation{}
	}
	return &xxx_CreateNotifyV2Operation{}
}

func (o *CreateNotifyV2Request) xxx_FromOp(ctx context.Context, op *xxx_CreateNotifyV2Operation) {
	if o == nil {
		return
	}
}
func (o *CreateNotifyV2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNotifyV2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNotifyV2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNotifyV2Response structure represents the ApiCreateNotifyV2 operation response
type CreateNotifyV2Response struct {
	// rpc_error: Indicates the status of the operation. The server MUST set this parameter
	// to the value ERROR_SUCCESS (0x00000000) on success, or to one of the values specified
	// in ApiCreateNotify (section 3.1.4.2.56) for other conditions. Clients MUST treat
	// all values the same except as specified in section 3.2.4.6.
	Error uint32 `idl:"name:rpc_error" json:"error"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNotifyV2 return value.
	Return *Notify `idl:"name:Return" json:"return"`
}

func (o *CreateNotifyV2Response) xxx_ToOp(ctx context.Context) *xxx_CreateNotifyV2Operation {
	if o == nil {
		return &xxx_CreateNotifyV2Operation{}
	}
	return &xxx_CreateNotifyV2Operation{
		Error:     o.Error,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateNotifyV2Response) xxx_FromOp(ctx context.Context, op *xxx_CreateNotifyV2Operation) {
	if o == nil {
		return
	}
	o.Error = op.Error
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNotifyV2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNotifyV2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNotifyV2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyV2Operation structure represents the ApiAddNotifyV2 operation
type xxx_AddNotifyV2Operation struct {
	Notify             *Notify                 `idl:"name:hNotify" json:"notify"`
	Object             *Generic                `idl:"name:hObject" json:"object"`
	Filter             *NotifyFilterAndTypeRPC `idl:"name:filter" json:"filter"`
	NotifyKey          uint32                  `idl:"name:dwNotifyKey" json:"notify_key"`
	Version            uint32                  `idl:"name:dwVersion" json:"version"`
	IsTargetedAtObject bool                    `idl:"name:isTargetedAtObject" json:"is_targeted_at_object"`
	RPCStatus          uint32                  `idl:"name:rpc_status" json:"rpc_status"`
	Return             uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyV2Operation) OpNum() int { return 138 }

func (o *xxx_AddNotifyV2Operation) OpName() string { return "/clusapi3/v3/ApiAddNotifyV2" }

func (o *xxx_AddNotifyV2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyV2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hObject {in} (1:{context_handle, alias=HGENERIC_RPC, names=ndr_context_handle}(struct))
	{
		if o.Object != nil {
			if err := o.Object.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Generic{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// filter {in} (1:{alias=NOTIFY_FILTER_AND_TYPE_RPC}(struct))
	{
		if o.Filter != nil {
			if err := o.Filter.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NotifyFilterAndTypeRPC{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// isTargetedAtObject {in} (1:{alias=BOOL}(int32))
	{
		if !o.IsTargetedAtObject {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddNotifyV2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hObject {in} (1:{context_handle, alias=HGENERIC_RPC, names=ndr_context_handle}(struct))
	{
		if o.Object == nil {
			o.Object = &Generic{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// filter {in} (1:{alias=NOTIFY_FILTER_AND_TYPE_RPC}(struct))
	{
		if o.Filter == nil {
			o.Filter = &NotifyFilterAndTypeRPC{}
		}
		if err := o.Filter.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// isTargetedAtObject {in} (1:{alias=BOOL}(int32))
	{
		var _bIsTargetedAtObject int32
		if err := w.ReadData(&_bIsTargetedAtObject); err != nil {
			return err
		}
		o.IsTargetedAtObject = _bIsTargetedAtObject != 0
	}
	return nil
}

func (o *xxx_AddNotifyV2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyV2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyV2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyV2Request structure represents the ApiAddNotifyV2 operation request
type AddNotifyV2Request struct {
	// hNotify: An HNOTIFY_RPC context handle that was obtained in a previous call to ApiCreateNotifyV2
	// (section 3.1.4.2.136).
	Notify *Notify `idl:"name:hNotify" json:"notify"`
	// hObject: A context handle. The type of handle depends on the value of the filter
	// parameter.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                     CONTEXT                                      |
	//	|                FILTER                 |                                      HANDLE                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_CLUSTER           | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | (section 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116).                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_QUORUM            | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | (section 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116).                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_RESOURCE_TYPE     | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | (section 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116).                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_GROUP             | An HGROUP_RPC context handle that was obtained from a call to ApiOpenGroup       |
	//	|                                       | (section 3.1.4.2.42), ApiOpenGroupEx (section 3.1.4.2.118), or ApiCreateGroup    |
	//	|                                       | (section 3.1.4.2.43).                                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_RESOURCE          | An HRES_RPC context handle that was obtained from a call to ApiOpenResource      |
	//	|                                       | (section 3.1.4.2.9), ApiOpenResourceEx (section 3.1.4.2.119), or                 |
	//	|                                       | ApiCreateResource (section 3.1.4.2.10).                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NETWORK           | An HNETWORK_RPC context handle that was obtained from a call to ApiOpenNetwork   |
	//	|                                       | (section 3.1.4.2.81) or ApiOpenNetworkEx (section 3.1.4.2.120).                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NETWORK_INTERFACE | An HNETINTERFACE_RPC context handle that was obtained from a call to             |
	//	|                                       | ApiOpenNetInterface (section 3.1.4.2.92) or ApiOpenNetInterfaceEx (section       |
	//	|                                       | 3.1.4.2.121).                                                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NODE              | An HNODE_RPC context handle that was obtained from a call to ApiOpenNode         |
	//	|                                       | (section 3.1.4.2.67) or ApiOpenNodeEx (section 3.1.4.2.117).                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_REGISTRY          | An HKEY_RPC context handle that was obtained from a call to ApiGetRootKey        |
	//	|                                       | (section 3.1.4.2.29), ApiCreateKey (section 3.1.4.2.30), or ApiOpenKey (section  |
	//	|                                       | 3.1.4.2.31).                                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_SHARED_VOLUME     | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | (section 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116).                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_SPACEPORT         | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | or ApiOpenClusterEx.                                                             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_UPGRADE           | An HCLUSTER_RPC context handle that was obtained from a call to ApiOpenCluster   |
	//	|                                       | or ApiOpenClusterEx.                                                             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_GROUPSET          | An HGROUPSET_RPC context handle that was obtained from a call to ApiOpenGroupSet |
	//	|                                       | (section 3.1.4.2.147) or ApiCreateGroupSet (section 3.1.4.2.146).                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Object *Generic `idl:"name:hObject" json:"object"`
	// filter: Identifies the notifications for the specified object type that the client
	// is registering for. For details of the NOTIFY_FILTER_AND_TYPE_RPC structure, see
	// section 2.2.3.22. Clients MUST set this structure with the object type, as specified
	// in section 2.2.2.12, and a bitwise-OR of flags from enumerations that correspond
	// to the desired notifications. For some notifications, certain flags are disallowed.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|             NOTIFICATION              |                                                                                  |
	//	|                 TYPE                  |                                   ENUMERATION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_CLUSTER           | CLUSTER_CHANGE_CLUSTER_V2 (section 2.2.2.12) The client MUST NOT                 |
	//	|                                       | set the following flags: CLUSTER_CHANGE_CLUSTER_RECONNECT_V2,                    |
	//	|                                       | CLUSTER_CHANGE_CLUSTER_HANDLE_CLOSE_V2, CLUSTER_CHANGE_CLUSTER_STATE_V2.         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_QUORUM            | CLUSTER_CHANGE_QUORUM_V2 (section 2.2.2.20)                                      |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_RESOURCE_TYPE     | CLUSTER_CHANGE_RESOURCE_TYPE_V2 (section 2.2.2.15)                               |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_GROUP             | CLUSTER_CHANGE_GROUP_V2 (section 2.2.2.13) The client MUST NOT set the           |
	//	|                                       | CLUSTER_CHANGE_GROUP_HANDLE_CLOSE_V2 flag.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_RESOURCE          | CLUSTER_CHANGE_RESOURCE_V2 (section 2.2.2.14) The client MUST NOT set the        |
	//	|                                       | CLUSTER_CHANGE_RESOURCE_HANDLE_CLOSE_V2 flag.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NETWORK           | CLUSTER_CHANGE_NETWORK_V2 (section 2.2.2.17) The client MUST NOT set the         |
	//	|                                       | CLUSTER_CHANGE_NETWORK_HANDLE_CLOSE_V2 flag.                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NETWORK_INTERFACE | CLUSTER_CHANGE_NETINTERFACE_V2 (section 2.2.2.16) The client MUST NOT set the    |
	//	|                                       | CLUSTER_CHANGE_NETINTERFACE_HANDLE_CLOSE_V2 flag.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_NODE              | CLUSTER_CHANGE_NODE_V2 (section 2.2.2.18) The client MUST NOT set the            |
	//	|                                       | CLUSTER_CHANGE_NODE_HANDLE_CLOSE_V2 flag.                                        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_REGISTRY          | CLUSTER_CHANGE_REGISTRY_V2 (section 2.2.2.19) The client MUST NOT set the        |
	//	|                                       | CLUSTER_CHANGE_REGISTRY_HANDLE_CLOSE_V2 flag.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_SHARED_VOLUME     | CLUSTER_CHANGE_SHARED_VOLUME_V2 (section 2.2.2.21).                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_SPACEPORT         | CLUSTER_CHANGE_SPACEPORT_V2 (section 2.2.2.25).                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_UPGRADE           | CLUSTER_CHANGE_NODE_UPGRADE_PHASE_V2 (section 2.2.2.26).                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_OBJECT_TYPE_GROUPSET          | CLUSTER_CHANGE_GROUPSET_V2 (section 2.2.2.24). The client MUST NOT set the       |
	//	|                                       | CLUSTER_CHANGE_GROUPSET_HANDLE_CLOSE_v2 flag.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Filter *NotifyFilterAndTypeRPC `idl:"name:filter" json:"filter"`
	// dwNotifyKey: A 32-bit integer context value chosen by the client. This value MUST
	// be returned to the client via a subsequent completion of the ApiGetNotifyV2 (section
	// 3.1.4.2.138) method, if the name of the object pertaining to the event matches the
	// name of the object indicated by the hObject parameter.
	NotifyKey uint32 `idl:"name:dwNotifyKey" json:"notify_key"`
	// dwVersion: Clients MUST set this value to 2.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// isTargetedAtObject: A value of TRUE indicates that the client is registering for
	// notification for a particular object that it MUST specify in the hObject parameter.
	// A value of FALSE indicates that the hObject parameter contains an HCLUSTER_RPC context
	// handle that the client has previously obtained from a call to ApiOpenCluster (section
	// 3.1.4.2.1) or ApiOpenClusterEx (section 3.1.4.2.116).
	IsTargetedAtObject bool `idl:"name:isTargetedAtObject" json:"is_targeted_at_object"`
}

func (o *AddNotifyV2Request) xxx_ToOp(ctx context.Context) *xxx_AddNotifyV2Operation {
	if o == nil {
		return &xxx_AddNotifyV2Operation{}
	}
	return &xxx_AddNotifyV2Operation{
		Notify:             o.Notify,
		Object:             o.Object,
		Filter:             o.Filter,
		NotifyKey:          o.NotifyKey,
		Version:            o.Version,
		IsTargetedAtObject: o.IsTargetedAtObject,
	}
}

func (o *AddNotifyV2Request) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyV2Operation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Object = op.Object
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.Version = op.Version
	o.IsTargetedAtObject = op.IsTargetedAtObject
}
func (o *AddNotifyV2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyV2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyV2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyV2Response structure represents the ApiAddNotifyV2 operation response
type AddNotifyV2Response struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyV2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyV2Response) xxx_ToOp(ctx context.Context) *xxx_AddNotifyV2Operation {
	if o == nil {
		return &xxx_AddNotifyV2Operation{}
	}
	return &xxx_AddNotifyV2Operation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddNotifyV2Response) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyV2Operation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyV2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyV2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyV2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNotifyV2Operation structure represents the ApiGetNotifyV2 operation
type xxx_GetNotifyV2Operation struct {
	Notify              *Notify            `idl:"name:hNotify" json:"notify"`
	Notifications       []*NotificationRPC `idl:"name:Notifications;size_is:(, dwNumNotifications)" json:"notifications"`
	NotificationsLength uint32             `idl:"name:dwNumNotifications" json:"notifications_length"`
	Return              uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNotifyV2Operation) OpNum() int { return 139 }

func (o *xxx_GetNotifyV2Operation) OpName() string { return "/clusapi3/v3/ApiGetNotifyV2" }

func (o *xxx_GetNotifyV2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyV2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNotifyV2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyV2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Notifications != nil && o.NotificationsLength == 0 {
		o.NotificationsLength = uint32(len(o.Notifications))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyV2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Notifications {out} (1:{pointer=ref}*(2))(2:{alias=PNOTIFICATION_RPC}*(1))(3:{alias=NOTIFICATION_RPC}[dim:0,size_is=dwNumNotifications](struct))
	{
		if o.Notifications != nil || o.NotificationsLength > 0 {
			_ptr_Notifications := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.NotificationsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Notifications {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Notifications[i1] != nil {
						if err := o.Notifications[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&NotificationRPC{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Notifications); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&NotificationRPC{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Notifications, _ptr_Notifications); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwNumNotifications {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotificationsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyV2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Notifications {out} (1:{pointer=ref}*(2))(2:{alias=PNOTIFICATION_RPC,pointer=ref}*(1))(3:{alias=NOTIFICATION_RPC}[dim:0,size_is=dwNumNotifications](struct))
	{
		_ptr_Notifications := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Notifications", sizeInfo[0])
			}
			o.Notifications = make([]*NotificationRPC, sizeInfo[0])
			for i1 := range o.Notifications {
				i1 := i1
				if o.Notifications[i1] == nil {
					o.Notifications[i1] = &NotificationRPC{}
				}
				if err := o.Notifications[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Notifications := func(ptr interface{}) { o.Notifications = *ptr.(*[]*NotificationRPC) }
		if err := w.ReadPointer(&o.Notifications, _s_Notifications, _ptr_Notifications); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwNumNotifications {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotificationsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNotifyV2Request structure represents the ApiGetNotifyV2 operation request
type GetNotifyV2Request struct {
	// hNotify: An HNOTIFY_RPC context handle that was obtained from a previous call to
	// ApiCreateNotifyV2 (section 3.1.4.2.136).
	Notify *Notify `idl:"name:hNotify" json:"notify"`
}

func (o *GetNotifyV2Request) xxx_ToOp(ctx context.Context) *xxx_GetNotifyV2Operation {
	if o == nil {
		return &xxx_GetNotifyV2Operation{}
	}
	return &xxx_GetNotifyV2Operation{
		Notify: o.Notify,
	}
}

func (o *GetNotifyV2Request) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyV2Operation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *GetNotifyV2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNotifyV2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyV2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNotifyV2Response structure represents the ApiGetNotifyV2 operation response
type GetNotifyV2Response struct {
	// Notifications: A pointer to an array of one or more NOTIFICATION_RPC (section 2.2.3.24)
	// structures corresponding to notification events that have been generated on the designated
	// notification port since the previous call to ApiGetNotifyV2 or since the client registered
	// for events with ApiAddNotifyV2. For each NOTIFICATION_RPC element in the array, the
	// dwNotifyKey member is set to the value provided by the client in the previous ApiAddNotifyV2
	// call corresponding to the event indication contained in the NOTIFICATION_RPC structure.
	// Each NOTIFICATION_RPC structure contains a NOTIFICATION_DATA_RPC (section 2.2.3.23)
	// structure, which is populated according to the particular notification event.
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_CLUSTER (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_CLUSTER_V2 (section
	// 2.2.2.12) ( d529b7a9-9f5b-4191-b093-dbb38ffa4277 ) enumeration, indicating the event
	// that occurred.
	//
	// * ObjectId: an empty Unicode string ( 694e5e7a-5833-4f3d-b47e-323ee1d452c2#gt_b069acb4-e364-453e-ac83-42d469bb339e
	// ).
	//
	// * Type: an empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	|                                                |                                                                                  |                                |                                               |                                    |
	//	|           FILTERANDTYPE FILTERFLAGS            |                                      BUFFER                                      |            OBJECTID            |                   PARENTID                    |                NAME                |
	//	|                                                |                                                                                  |                                |                                               |                                    |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_GROUP _ADDED_V2         | A DWORD containing the type of the group.                                        | The ID of the group.           | The ID of the node where the group is hosted. | The name of the group              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_NETWORK _ADDED_V2       | Empty.                                                                           | The ID of the cluster network. | An empty Unicode string.                      | The name of the cluster network.   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_NODE _ADDED_V2          | A DWORD containing the state of the node, as specified in 3.1.4.2.69             | The ID of the cluster node.    | An empty Unicode string.                      | The name of the cluster node.      |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_RESOURCE _TYPE_ADDED_V2 | Empty.                                                                           | An empty Unicode string.       | An empty Unicode string.                      | The name of the new resource type. |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_COMMON _PROPERTY_V2     | A Property List (section 2.2.3.10) containing one or more Property Values        | An empty Unicode string.       | An empty Unicode string.                      | An empty Unicode string.           |
	//	|                                                | (section 2.2.3.10.1) with updated values.                                        |                                |                                               |                                    |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_PRIVATE _PROPERTY       | A Property List (section 2.2.3.10) containing one or more Property Values        | An empty Unicode string.       | An empty Unicode string.                      | An empty Unicode string.           |
	//	|                                                | (section 2.2.3.10.1) with updated values.                                        |                                |                                               |                                    |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER_LOST _NOTIFICATIONS_V2  | Empty.                                                                           | An empty Unicode string.       | An empty Unicode string.                      | An empty Unicode string.           |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER _RENAME_V2              | Empty.                                                                           | An empty Unicode string.       | An empty Unicode string.                      | The new name of the cluster.       |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER _MEMBERSHIP_V2          | A CLUSTER_MEMBERSHIP_INFO (section 2.2.3.42) containing new information about    | An empty Unicode string.       | An empty Unicode string.                      | An empty Unicode string.           |
	//	|                                                | the cluster membership.                                                          |                                |                                               |                                    |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//	| CLUSTER_CHANGE_CLUSTER _UPGRADED_V2            | A DWORD containing the cluster operating version.                                | An empty Unicode string.       | An empty Unicode string.                      | An empty Unicode string.           |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+--------------------------------+-----------------------------------------------+------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_GROUP (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_GROUP_V2 (section 2.2.2.13)
	// ( a4c12a3c-3c9b-4b81-ac40-79cb5018474a ) enumeration, indicating the event that occurred.
	//
	// * ParentId: ID of the node on which the group is hosted.
	//
	// * Type: an empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                          |                                                                                  |                                                                                  |                                                                                  |
	//	|        FILTERANDTYPE FILTERFLAGS         |                                      BUFFER                                      |                                     OBJECTID                                     |                                       NAME                                       |
	//	|                                          |                                                                                  |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_DELETED_V2          | Empty.                                                                           | The ID of the group.                                                             | The name of the group.                                                           |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_COMMON_PROPERTY_V2  | A Property List (section 2.2.3.10) containing one or more Property Values        | The ID of the group.                                                             | The name of the group.                                                           |
	//	|                                          | (section 2.2.3.10.1) with updated values.                                        |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_PRIVATE_PROPERTY_V2 | A Property List (section 2.2.3.10) containing one or more Property Values        | The ID of the group.                                                             | The name of the group.                                                           |
	//	|                                          | (section 2.2.3.10.1) with updated values.                                        |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_STATE_V2            | A DWORD containing the new group state (see section 3.1.4.2.46).                 | The ID of the group.                                                             | The name of the group.                                                           |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_OWNER_NODE_V2       | The ID of the new owner node.                                                    | The ID of the group.                                                             | The name of the group.                                                           |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_PREFERRED_OWNER_V2  | A MULTI_SZ list of string IDs of the preferred owners, as would be set for a     | The ID of the group.                                                             | The name of the group.                                                           |
	//	|                                          | multiSzNodeList in a call to ApiSetGroupNodeList (section 3.1.4.2.55).           |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_RESOURCE_ADDED_V2   | The ID of the group.                                                             | The ID of the resource created in the cluster and contained in this group (see   | The name of the resource created in the cluster and contained in this group (see |
	//	|                                          |                                                                                  | ApiCreateResource (section 3.1.4.2.10)).                                         | ApiCreateResource (section 3.1.4.2.10)).                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_RESOURCE_GAINED_V2  | The ID of the resource added to this group, either by ApiCreateResource          | The ID of the group.                                                             | The name of the group.                                                           |
	//	|                                          | (section 3.1.4.2.10) or ApiChangeResourceGroup (section 3.1.4.2.26) or           |                                                                                  |                                                                                  |
	//	|                                          | ApiChangeResourceGroupEx (section 3.1.4.2.166).                                  |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_GROUP_RESOURCE_LOST_V2    | The ID of the resource removed from this group, either by ApiDeleteResource      | The ID of the group.                                                             | The name of the group.                                                           |
	//	|                                          | (section 3.1.4.2.11) or ApiChangeResourceGroup (section 3.1.4.2.26) or           |                                                                                  |                                                                                  |
	//	|                                          | ApiChangeResourceGroupEx (section 3.1.4.2.166).                                  |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_RESOURCE (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_RESOURCE_V2 (section
	// 2.2.2.14) ( 95b267da-b5d7-4788-acd0-1a0815579e61 ) enumeration, indicating the event
	// that occurred.
	//
	// * ObjectId: ID of the resource.
	//
	// * ParentId: ID of the group that contains the resource.
	//
	// * Name: the name of the resource.
	//
	// * Type: the name of the resource type.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                             |                                                                                  |
	//	|          FILTERANDTYPE FILTERFLAGS          |                                      BUFFER                                      |
	//	|                                             |                                                                                  |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_COMMON_PROPERTY_V2  | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                             | (section 2.2.3.10.1) with updated values.                                        |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_PRIVATE_PROPERTY_V2 | Empty.                                                                           |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_STATE_V2            | A DWORD containing the resource state (see 3.1.4.2.13).                          |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_OWNER_GROUP_V2      | The ID of the group that now contains the resource.                              |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_DEPENDENCIES_V2     | A new dependency expression, as would be returned by a call to                   |
	//	|                                             | ApiGetResourceDependencyExpression (section 3.1.4.2.110).                        |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_DEPENDENTS_V2       | A MULTI_SZ list of resource ID strings that now list this resource as a          |
	//	|                                             | provider.                                                                        |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_POSSIBLE_OWNERS_V2  | A MULTI_SZ list of node IDs that can host the resource.                          |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_DELETED_V2          | The ID of the group that contained the resource before it was deleted.           |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_DLL_UPGRADED_V2     | The ID of the node that issued CLUSCTL_RESOURCE_UPGRADED_DLL (section            |
	//	|                                             | 3.1.4.3.1.27).                                                                   |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_RESOURCE_TYPE (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_RESOURCE_TYPE_V2 (section
	// 2.2.2.15) ( aec62676-9b9f-4d49-914c-dd3d5bd7fcb3 ) enumeration, indicating the event
	// that occurred.
	//
	// * ObjectId: An empty Unicode string.
	//
	// * ParentId: An empty Unicode string.
	//
	// * Name: the name of the resource type.
	//
	// * Type: An empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The buffer field is set depending on the event that occurred, identified by the FilterAndType.FilterFlags
	// field, as specified in the following table.
	//
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                  |                                                                                  |
	//	|            FILTERANDTYPE FILTERFLAGS             |                                      BUFFER                                      |
	//	|                                                  |                                                                                  |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_TYPE_DELETED_V2          | Empty.                                                                           |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_TYPE_COMMON_PROPERTY_V2  | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                                  | (section 2.2.3.10.1) with updated values.                                        |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_TYPE_PRIVATE_PROPERTY_V2 | Empty.                                                                           |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_TYPE_POSSIBLE_OWNERS_V2  | A MULTI_SZ list of cluster node IDs that can host this resource type.            |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_RESOURCE_TYPE_DLL_UPGRADED_V2     | The ID of the node that issued CLUSCTL_RESOURCE_UPGRADED_DLL (section            |
	//	|                                                  | 3.1.4.3.1.27).                                                                   |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_RESOURCE_TYPE_SPECIFIC_V2                | The same buffer field that a resource DLL used when it raised the notification.  |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_NETWORK_INTERFACE (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_NETINTERFACE_V2 (section
	// 2.2.2.16) ( 866c77e9-f692-4ecb-982b-38b682895492 ) enumeration, indicating the event
	// that occurred.
	//
	// * ObjectId: ID of the cluster network interface.
	//
	// * ParentId: ID of the node associated with the cluster network interface.
	//
	// * Name: the name of the cluster network interface.
	//
	// * Type: An empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The buffer field is set depending on the event that occurred, identified by the FilterAndType.FilterFlags
	// field, as specified in the following table.
	//
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                 |                                                                                  |
	//	|            FILTERANDTYPE FILTERFLAGS            |                                      BUFFER                                      |
	//	|                                                 |                                                                                  |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETINTERFACE_DELETED_V2          | Empty.                                                                           |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETINTERFACE_COMMON_PROPERTY_V2  | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                                 | (section 2.2.3.10.1) with updated values.                                        |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETINTERFACE_PRIVATE_PROPERTY_V2 | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                                 | (section 2.2.3.10.1) with updated values.                                        |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETINTERFACE_STATE_V2            | A DWORD containing the cluster network interface state as would be returned from |
	//	|                                                 | a call to ApiGetNetInterfaceState (section 3.1.4.2.94).                          |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_NETWORK (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_NETWORK_V2 (section
	// 2.2.2.17) ( e6d7a85b-b667-420d-8b0a-7f2f738c6215 ) enumeration, indicating the event
	// that occurred.
	//
	// * ObjectId: ID of the cluster network.
	//
	// * ParentId: An empty Unicode string.
	//
	// * Name: the name of the cluster network.
	//
	// * Type: An empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The buffer field is set depending on the event that occurred, identified by the FilterAndType.FilterFlags
	// field, as specified in the following table.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|         FILTERANDTYPE FILTERFLAGS          |                                      BUFFER                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETWORK_DELETED_V2          | Empty.                                                                           |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETWORK_COMMON_PROPERTY_V2  | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                            | (section 2.2.3.10.1) with updated values.                                        |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETWORK_PRIVATE_PROPERTY_V2 | A Property List (section 2.2.3.10) containing one or more Property Values        |
	//	|                                            | (section 2.2.3.10.1) with updated values.                                        |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_NETWORK_STATE_V2            | A DWORD containing the cluster network state, as would be returned by a call to  |
	//	|                                            | ApiGetNetworkState (section 3.1.4.2.83).                                         |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_NODE (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_NODE_V2 (section 2.2.2.18)
	// ( 7db74409-6418-40f6-aa53-f323bdc6e346 ) enumeration, indicating the event that occurred.
	//
	// * ParentId: An empty Unicode string.
	//
	// * Type: An empty Unicode string.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	|                                           |                                                                                  |                                          |                                            |
	//	|         FILTERANDTYPE FILTERFLAGS         |                                      BUFFER                                      |                 OBJECTID                 |                    NAME                    |
	//	|                                           |                                                                                  |                                          |                                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_NETINTERFACE_ADDED_V2 | The ID of the cluster node.                                                      | The ID of the cluster network interface. | The name of the cluster network interface. |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_DELETED_V2            | A DWORD containing the state of the cluster node as would be returned from a     | The ID of the cluster node.              | The name of the cluster node.              |
	//	|                                           | call to ApiGetNodeState (section 3.1.4.2.69).                                    |                                          |                                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_COMMON_PROPERTY_V2    | A Property List (section 2.2.3.10) containing one or more Property Values        | The ID of the cluster node.              | The name of the cluster node.              |
	//	|                                           | (section 2.2.3.10.1) with updated values.                                        |                                          |                                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_PRIVATE_PROPERTY_V2   | A Property List (section 2.2.3.10) containing one or more Property Values        | The ID of the cluster node.              | The name of the cluster node.              |
	//	|                                           | (section 2.2.3.10.1) with updated values.                                        |                                          |                                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_STATE_V2              | A DWORD containing the state of the cluster node as would be returned from a     | The ID of the cluster node.              | The name of the cluster node.              |
	//	|                                           | call to ApiGetNodeState (section 3.1.4.2.69).                                    |                                          |                                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_GROUP_GAINED_V2       | The ID of the group that has moved to this node.                                 | The ID of the cluster node.              | The name of the cluster node.              |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//	| CLUSTER_CHANGE_NODE_GROUP_LOST_V2         | The ID of the group that has moved away from this node.                          | The ID of the cluster node.              | The name of the cluster node.              |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+------------------------------------------+--------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_REGISTRY (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_REGISTRY_V2 (section
	// 2.2.2.19) ( 3ec56e14-7d7c-461a-95bf-9650d73876ff ) enumeration, indicating the event
	// that occurred.
	//
	// * ParentId: An empty Unicode string.
	//
	// * Type: An empty Unicode string.
	//
	// * buffer: An empty buffer.
	//
	// * dwBufferSize: 0x00000000.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	|                                       |                                |                                                                     |
	//	|       FILTERANDTYPE FILTERFLAGS       |            OBJECTID            |                                NAME                                 |
	//	|                                       |                                |                                                                     |
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_REGISTRY_ATTRIBUTES_V2 | An empty Unicode string.       | Relative name of the cluster database key whose attributes changed. |
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_REGISTRY_NAME_V2       | The name of the changed value. | Relative name of the renamed cluster database key.                  |
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_REGISTRY_SUBTREE_V2    | An empty Unicode string.       | An empty Unicode string.                                            |
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//	| CLUSTER_CHANGE_REGISTRY_VALUE_V2      | The name of the changed value. | Relative name of the changed cluster database key.                  |
	//	+---------------------------------------+--------------------------------+---------------------------------------------------------------------+
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_QUORUM (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_QUORUM_V2 (section
	// 2.2.2.19) enumeration, indicating the event that occurred.
	//
	// * ParentId: NULL.
	//
	// * Type: NULL.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+-------------------------+---------------------------+
	//	|                                |                                                                                  |                         |                           |
	//	|   FILTERANDTYPE FILTERFLAGS    |                                      BUFFER                                      |        OBJECTID         |           NAME            |
	//	|                                |                                                                                  |                         |                           |
	//	+--------------------------------+----------------------------------------------------------------------------------+-------------------------+---------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+-------------------------+---------------------------+
	//	| CLUSTER_CHANGE_QUORUM_STATE_V2 | A DWORD describing the new state of the resource, as would be returned from a    | The ID of the resource. | The name of the resource. |
	//	|                                | call to ApiGetResourceState (section 3.1.4.2.13).                                |                         |                           |
	//	+--------------------------------+----------------------------------------------------------------------------------+-------------------------+---------------------------+
	//
	// Note  For the CLUSTER_CHANGE_QUORUM_STATE_V2 value, if and only if a quorum disk
	// resource is included, a payload will also be provided and the target will be the
	// resource.
	//
	// * FilterAndType.dwObjectType: CLUSTER_OBJECT_TYPE_SHARED_VOLUME (section 2.2.2.11).
	//
	// * FilterAndType.FilterFlags: one flag from the CLUSTER_CHANGE_SHARED_VOLUME_V2 (section
	// 2.2.2.21) ( f84ad01b-d0e5-4dc1-945c-4c39d90fab13 ) enumeration, indicating the event
	// that occurred.
	//
	// * ParentId: NULL.
	//
	// * Type: NULL.
	//
	// * dwBufferSize: the number of bytes in the *buffer* field.
	//
	// The remaining fields are set depending on the event that occurred, identified by
	// the FilterAndType.FilterFlags field, as specified in the following table.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------------------+
	//	|                                       |                                                                                  |                                               |                                                 |
	//	|       FILTERANDTYPE FILTERFLAGS       |                                      BUFFER                                      |                   OBJECTID                    |                      NAME                       |
	//	|                                       |                                                                                  |                                               |                                                 |
	//	+---------------------------------------+----------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------------------+
	//	| CLUSTER_CHANGE_SHARED_VOLUME_STATE_V2 | A Property List (section 2.2.3.10) containing one or more Property Values        | The ID of the cluster shared volume resource. | The name of the cluster shared volume resource. |
	//	|                                       | (section 2.2.3.10.1) of type binary value, with each binary data value           |                                               |                                                 |
	//	|                                       | representing a CLUSTER_SHARED_VOLUME_STATE_INFO_EX (section 2.2.3.32) structure. |                                               |                                                 |
	//	+---------------------------------------+----------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------------------+
	Notifications []*NotificationRPC `idl:"name:Notifications;size_is:(, dwNumNotifications)" json:"notifications"`
	// dwNumNotifications: A pointer to a DWORD that contains the count of NOTIFICATION_RPC
	// structures.
	NotificationsLength uint32 `idl:"name:dwNumNotifications" json:"notifications_length"`
	// Return: The ApiGetNotifyV2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNotifyV2Response) xxx_ToOp(ctx context.Context) *xxx_GetNotifyV2Operation {
	if o == nil {
		return &xxx_GetNotifyV2Operation{}
	}
	return &xxx_GetNotifyV2Operation{
		Notifications:       o.Notifications,
		NotificationsLength: o.NotificationsLength,
		Return:              o.Return,
	}
}

func (o *GetNotifyV2Response) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyV2Operation) {
	if o == nil {
		return
	}
	o.Notifications = op.Notifications
	o.NotificationsLength = op.NotificationsLength
	o.Return = op.Return
}
func (o *GetNotifyV2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNotifyV2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyV2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupEnumOperation structure represents the ApiCreateGroupEnum operation
type xxx_CreateGroupEnumOperation struct {
	Cluster                  *Cluster       `idl:"name:hCluster" json:"cluster"`
	Properties               []byte         `idl:"name:pProperties;size_is:(cbProperties);pointer:unique" json:"properties"`
	PropertiesLength         uint32         `idl:"name:cbProperties" json:"properties_length"`
	ReadOnlyProperties       []byte         `idl:"name:pRoProperties;size_is:(cbRoProperties);pointer:unique" json:"read_only_properties"`
	ReadOnlyPropertiesLength uint32         `idl:"name:cbRoProperties" json:"read_only_properties_length"`
	ResultList               *GroupEnumList `idl:"name:ppResultList" json:"result_list"`
	RPCStatus                uint32         `idl:"name:rpc_status" json:"rpc_status"`
	Return                   uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupEnumOperation) OpNum() int { return 143 }

func (o *xxx_CreateGroupEnumOperation) OpName() string { return "/clusapi3/v3/ApiCreateGroupEnum" }

func (o *xxx_CreateGroupEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Properties != nil && o.PropertiesLength == 0 {
		o.PropertiesLength = uint32(len(o.Properties))
	}
	if o.ReadOnlyProperties != nil && o.ReadOnlyPropertiesLength == 0 {
		o.ReadOnlyPropertiesLength = uint32(len(o.ReadOnlyProperties))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbProperties](uchar))
	{
		if o.Properties != nil || o.PropertiesLength > 0 {
			_ptr_pProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PropertiesLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Properties {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Properties[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Properties); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Properties, _ptr_pProperties); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PropertiesLength); err != nil {
			return err
		}
	}
	// pRoProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbRoProperties](uchar))
	{
		if o.ReadOnlyProperties != nil || o.ReadOnlyPropertiesLength > 0 {
			_ptr_pRoProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.ReadOnlyPropertiesLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.ReadOnlyProperties {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.ReadOnlyProperties[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.ReadOnlyProperties); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReadOnlyProperties, _ptr_pRoProperties); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbRoProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ReadOnlyPropertiesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbProperties](uchar))
	{
		_ptr_pProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Properties", sizeInfo[0])
			}
			o.Properties = make([]byte, sizeInfo[0])
			for i1 := range o.Properties {
				i1 := i1
				if err := w.ReadData(&o.Properties[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pProperties := func(ptr interface{}) { o.Properties = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Properties, _s_pProperties, _ptr_pProperties); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PropertiesLength); err != nil {
			return err
		}
	}
	// pRoProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbRoProperties](uchar))
	{
		_ptr_pRoProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.ReadOnlyProperties", sizeInfo[0])
			}
			o.ReadOnlyProperties = make([]byte, sizeInfo[0])
			for i1 := range o.ReadOnlyProperties {
				i1 := i1
				if err := w.ReadData(&o.ReadOnlyProperties[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pRoProperties := func(ptr interface{}) { o.ReadOnlyProperties = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.ReadOnlyProperties, _s_pRoProperties, _ptr_pRoProperties); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbRoProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ReadOnlyPropertiesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppResultList {out} (1:{pointer=ref}*(2))(2:{alias=PGROUP_ENUM_LIST}*(1))(3:{alias=GROUP_ENUM_LIST}(struct))
	{
		if o.ResultList != nil {
			_ptr_ppResultList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ResultList != nil {
					if err := o.ResultList.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&GroupEnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ResultList, _ptr_ppResultList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppResultList {out} (1:{pointer=ref}*(2))(2:{alias=PGROUP_ENUM_LIST,pointer=ref}*(1))(3:{alias=GROUP_ENUM_LIST}(struct))
	{
		_ptr_ppResultList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ResultList == nil {
				o.ResultList = &GroupEnumList{}
			}
			if err := o.ResultList.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppResultList := func(ptr interface{}) { o.ResultList = *ptr.(**GroupEnumList) }
		if err := w.ReadPointer(&o.ResultList, _s_ppResultList, _ptr_ppResultList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupEnumRequest structure represents the ApiCreateGroupEnum operation request
type CreateGroupEnumRequest struct {
	// hCluster: A valid context handle to the cluster from which the client wishes to obtain
	// a group enumeration.
	Cluster *Cluster `idl:"name:hCluster" json:"cluster"`
	// pProperties: A MULTI_SZ list containing a list of names of common properties requested
	// by the client. For each GROUP_ENUM_ENTRY (section 2.2.3.25) in the resulting GROUP_ENUM_LIST
	// (section 2.2.3.26), the server MUST return a PROPERTY_LIST (section 2.2.3.10) containing
	// a Property Value (section 2.2.3.10.1) for each property name specified by the client
	// in the pProperties parameter. If the client sets the pProperties parameter to a single
	// NULL-terminated Unicode string equaling "*", then the server MUST return a PROPERTY_LIST
	// containing a Property Value for each of the common properties of the group, as would
	// be returned by a call to CLUSCTL_GROUP_GET_COMMON_PROPERTIES (section 3.1.4.3.3.8).
	Properties []byte `idl:"name:pProperties;size_is:(cbProperties);pointer:unique" json:"properties"`
	// cbProperties: The size in bytes of the property list buffer pointed to by the pProperties
	// parameter.
	PropertiesLength uint32 `idl:"name:cbProperties" json:"properties_length"`
	// pRoProperties: A MULTI_SZ list containing a list of names of common read-only properties
	// requested by the client. For each GROUP_ENUM_ENTRY (section 2.2.3.25) in the resulting
	// GROUP_ENUM_LIST (section 2.2.3.26), the server MUST return a PROPERTY_LIST (section
	// 2.2.3.10) containing a Property Value (section 2.2.3.10.1) for each property name
	// specified by the client in the pRoProperties parameter. If the client sets the pRoProperties
	// parameter to a single NULL-terminated Unicode string equaling "*", then the server
	// MUST return a PROPERTY_LIST containing a Property Value for each of the common read-only
	// properties of the group, as would be returned by a call to CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES
	// (section 3.1.4.3.3.7).
	ReadOnlyProperties []byte `idl:"name:pRoProperties;size_is:(cbRoProperties);pointer:unique" json:"read_only_properties"`
	// cbRoProperties: The size in bytes of the property list buffer pointed to by the pRoProperties
	// parameter.
	ReadOnlyPropertiesLength uint32 `idl:"name:cbRoProperties" json:"read_only_properties_length"`
}

func (o *CreateGroupEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupEnumOperation {
	if o == nil {
		return &xxx_CreateGroupEnumOperation{}
	}
	return &xxx_CreateGroupEnumOperation{
		Cluster:                  o.Cluster,
		Properties:               o.Properties,
		PropertiesLength:         o.PropertiesLength,
		ReadOnlyProperties:       o.ReadOnlyProperties,
		ReadOnlyPropertiesLength: o.ReadOnlyPropertiesLength,
	}
}

func (o *CreateGroupEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupEnumOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.Properties = op.Properties
	o.PropertiesLength = op.PropertiesLength
	o.ReadOnlyProperties = op.ReadOnlyProperties
	o.ReadOnlyPropertiesLength = op.ReadOnlyPropertiesLength
}
func (o *CreateGroupEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupEnumResponse structure represents the ApiCreateGroupEnum operation response
type CreateGroupEnumResponse struct {
	// ppResultList: A pointer to the enumerated group list as specified in GROUP_ENUM_LIST
	// (section 2.2.3.26). Each entry in the list is specified by a GROUP_ENUM_ENTRY (section
	// 2.2.3.25).
	ResultList *GroupEnumList `idl:"name:ppResultList" json:"result_list"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroupEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateGroupEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupEnumOperation {
	if o == nil {
		return &xxx_CreateGroupEnumOperation{}
	}
	return &xxx_CreateGroupEnumOperation{
		ResultList: o.ResultList,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateGroupEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupEnumOperation) {
	if o == nil {
		return
	}
	o.ResultList = op.ResultList
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateResourceEnumOperation structure represents the ApiCreateResourceEnum operation
type xxx_CreateResourceEnumOperation struct {
	Cluster                  *Cluster          `idl:"name:hCluster" json:"cluster"`
	Properties               []byte            `idl:"name:pProperties;size_is:(cbProperties);pointer:unique" json:"properties"`
	PropertiesLength         uint32            `idl:"name:cbProperties" json:"properties_length"`
	ReadOnlyProperties       []byte            `idl:"name:pRoProperties;size_is:(cbRoProperties);pointer:unique" json:"read_only_properties"`
	ReadOnlyPropertiesLength uint32            `idl:"name:cbRoProperties" json:"read_only_properties_length"`
	ResultList               *ResourceEnumList `idl:"name:ppResultList" json:"result_list"`
	RPCStatus                uint32            `idl:"name:rpc_status" json:"rpc_status"`
	Return                   uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateResourceEnumOperation) OpNum() int { return 144 }

func (o *xxx_CreateResourceEnumOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateResourceEnum"
}

func (o *xxx_CreateResourceEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Properties != nil && o.PropertiesLength == 0 {
		o.PropertiesLength = uint32(len(o.Properties))
	}
	if o.ReadOnlyProperties != nil && o.ReadOnlyPropertiesLength == 0 {
		o.ReadOnlyPropertiesLength = uint32(len(o.ReadOnlyProperties))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbProperties](uchar))
	{
		if o.Properties != nil || o.PropertiesLength > 0 {
			_ptr_pProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PropertiesLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Properties {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Properties[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Properties); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Properties, _ptr_pProperties); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PropertiesLength); err != nil {
			return err
		}
	}
	// pRoProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbRoProperties](uchar))
	{
		if o.ReadOnlyProperties != nil || o.ReadOnlyPropertiesLength > 0 {
			_ptr_pRoProperties := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.ReadOnlyPropertiesLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.ReadOnlyProperties {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.ReadOnlyProperties[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.ReadOnlyProperties); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReadOnlyProperties, _ptr_pRoProperties); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbRoProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ReadOnlyPropertiesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbProperties](uchar))
	{
		_ptr_pProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Properties", sizeInfo[0])
			}
			o.Properties = make([]byte, sizeInfo[0])
			for i1 := range o.Properties {
				i1 := i1
				if err := w.ReadData(&o.Properties[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pProperties := func(ptr interface{}) { o.Properties = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Properties, _s_pProperties, _ptr_pProperties); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PropertiesLength); err != nil {
			return err
		}
	}
	// pRoProperties {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbRoProperties](uchar))
	{
		_ptr_pRoProperties := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.ReadOnlyProperties", sizeInfo[0])
			}
			o.ReadOnlyProperties = make([]byte, sizeInfo[0])
			for i1 := range o.ReadOnlyProperties {
				i1 := i1
				if err := w.ReadData(&o.ReadOnlyProperties[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pRoProperties := func(ptr interface{}) { o.ReadOnlyProperties = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.ReadOnlyProperties, _s_pRoProperties, _ptr_pRoProperties); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbRoProperties {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ReadOnlyPropertiesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppResultList {out} (1:{pointer=ref}*(2))(2:{alias=PRESOURCE_ENUM_LIST}*(1))(3:{alias=RESOURCE_ENUM_LIST}(struct))
	{
		if o.ResultList != nil {
			_ptr_ppResultList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ResultList != nil {
					if err := o.ResultList.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ResourceEnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ResultList, _ptr_ppResultList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateResourceEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppResultList {out} (1:{pointer=ref}*(2))(2:{alias=PRESOURCE_ENUM_LIST,pointer=ref}*(1))(3:{alias=RESOURCE_ENUM_LIST}(struct))
	{
		_ptr_ppResultList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ResultList == nil {
				o.ResultList = &ResourceEnumList{}
			}
			if err := o.ResultList.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppResultList := func(ptr interface{}) { o.ResultList = *ptr.(**ResourceEnumList) }
		if err := w.ReadPointer(&o.ResultList, _s_ppResultList, _ptr_ppResultList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateResourceEnumRequest structure represents the ApiCreateResourceEnum operation request
type CreateResourceEnumRequest struct {
	// hCluster: A valid context handle to the cluster from which the client wishes to obtain
	// a resource enumeration.
	Cluster *Cluster `idl:"name:hCluster" json:"cluster"`
	// pProperties: A MULTI_SZ list containing a list of names of common properties requested
	// by the client. For each RESOURCE_ENUM_ENTRY (section 2.2.3.27) in the resulting RESOURCE_ENUM_LIST
	// (section 2.2.3.28), the server MUST return a PROPERTY_LIST (section 2.2.3.10) containing
	// a Property Value (section 2.2.3.10.1) for each property name specified by the client
	// in the pProperties parameter. If the client sets the pProperties parameter to a single
	// NULL-terminated Unicode string equaling "*", then the server MUST return a PROPERTY_LIST
	// containing a Property Value for each of the common properties of the resource, as
	// would be returned by a call to CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES (section 3.1.4.3.1.11).
	Properties []byte `idl:"name:pProperties;size_is:(cbProperties);pointer:unique" json:"properties"`
	// cbProperties: The size in bytes of the property list buffer pointed to by the pProperties
	// parameter.
	PropertiesLength uint32 `idl:"name:cbProperties" json:"properties_length"`
	// pRoProperties: A MULTI_SZ list containing a list of names of read-only properties
	// requested by the client. For each RESOURCE_ENUM_ENTRY (section 2.2.3.27) in the resulting
	// RESOURCE_ENUM_LIST (section 2.2.3.28), the server MUST return a PROPERTY_LIST (section
	// 2.2.3.10) containing a Property Value (section 2.2.3.10.1) for each property name
	// specified by the client in the pRoProperties parameter. If the client sets the pRoProperties
	// parameter to a single NULL-terminated Unicode string equaling "*", then the server
	// MUST return a PROPERTY_LIST containing a Property Value for each of the read-only
	// properties of the resource, as would be returned by a call to CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES
	// (section 3.1.4.3.1.10).
	ReadOnlyProperties []byte `idl:"name:pRoProperties;size_is:(cbRoProperties);pointer:unique" json:"read_only_properties"`
	// cbRoProperties: The size in bytes of the property list buffer pointed to by the pRoProperties
	// parameter.
	ReadOnlyPropertiesLength uint32 `idl:"name:cbRoProperties" json:"read_only_properties_length"`
}

func (o *CreateResourceEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateResourceEnumOperation {
	if o == nil {
		return &xxx_CreateResourceEnumOperation{}
	}
	return &xxx_CreateResourceEnumOperation{
		Cluster:                  o.Cluster,
		Properties:               o.Properties,
		PropertiesLength:         o.PropertiesLength,
		ReadOnlyProperties:       o.ReadOnlyProperties,
		ReadOnlyPropertiesLength: o.ReadOnlyPropertiesLength,
	}
}

func (o *CreateResourceEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceEnumOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.Properties = op.Properties
	o.PropertiesLength = op.PropertiesLength
	o.ReadOnlyProperties = op.ReadOnlyProperties
	o.ReadOnlyPropertiesLength = op.ReadOnlyPropertiesLength
}
func (o *CreateResourceEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateResourceEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateResourceEnumResponse structure represents the ApiCreateResourceEnum operation response
type CreateResourceEnumResponse struct {
	// ppResultList: A pointer to the enumerated resource list as specified in RESOURCE_ENUM_LIST
	// (section 2.2.3.28). Each entry in the list is specified by a RESOURCE_ENUM_ENTRY
	// (section 2.2.3.27).
	ResultList *ResourceEnumList `idl:"name:ppResultList" json:"result_list"`
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateResourceEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateResourceEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateResourceEnumOperation {
	if o == nil {
		return &xxx_CreateResourceEnumOperation{}
	}
	return &xxx_CreateResourceEnumOperation{
		ResultList: o.ResultList,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateResourceEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateResourceEnumOperation) {
	if o == nil {
		return
	}
	o.ResultList = op.ResultList
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateResourceEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateResourceEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateResourceEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ExecuteReadBatchOperation structure represents the ApiExecuteReadBatch operation
type xxx_ExecuteReadBatchOperation struct {
	Key           *Key   `idl:"name:hKey" json:"key"`
	InDataLength  uint32 `idl:"name:cbInData" json:"in_data_length"`
	InData        []byte `idl:"name:lpInData;size_is:(cbInData)" json:"in_data"`
	OutDataLength uint32 `idl:"name:cbOutData" json:"out_data_length"`
	OutData       []byte `idl:"name:lpOutData;size_is:(, cbOutData)" json:"out_data"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ExecuteReadBatchOperation) OpNum() int { return 145 }

func (o *xxx_ExecuteReadBatchOperation) OpName() string { return "/clusapi3/v3/ApiExecuteReadBatch" }

func (o *xxx_ExecuteReadBatchOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InData != nil && o.InDataLength == 0 {
		o.InDataLength = uint32(len(o.InData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbInData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InDataLength); err != nil {
			return err
		}
	}
	// lpInData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbInData](uchar))
	{
		dimSize1 := uint64(o.InDataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InData {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InData[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InData); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbInData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InDataLength); err != nil {
			return err
		}
	}
	// lpInData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbInData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InData", sizeInfo[0])
		}
		o.InData = make([]byte, sizeInfo[0])
		for i1 := range o.InData {
			i1 := i1
			if err := w.ReadData(&o.InData[i1]); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutData != nil && o.OutDataLength == 0 {
		o.OutDataLength = uint32(len(o.OutData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// cbOutData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutDataLength); err != nil {
			return err
		}
	}
	// lpOutData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbOutData](uchar))
	{
		if o.OutData != nil || o.OutDataLength > 0 {
			_ptr_lpOutData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.OutDataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.OutData {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.OutData[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.OutData); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OutData, _ptr_lpOutData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// cbOutData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutDataLength); err != nil {
			return err
		}
	}
	// lpOutData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbOutData](uchar))
	{
		_ptr_lpOutData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.OutData", sizeInfo[0])
			}
			o.OutData = make([]byte, sizeInfo[0])
			for i1 := range o.OutData {
				i1 := i1
				if err := w.ReadData(&o.OutData[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpOutData := func(ptr interface{}) { o.OutData = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.OutData, _s_lpOutData, _ptr_lpOutData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ExecuteReadBatchRequest structure represents the ApiExecuteReadBatch operation request
type ExecuteReadBatchRequest struct {
	Key          *Key   `idl:"name:hKey" json:"key"`
	InDataLength uint32 `idl:"name:cbInData" json:"in_data_length"`
	InData       []byte `idl:"name:lpInData;size_is:(cbInData)" json:"in_data"`
}

func (o *ExecuteReadBatchRequest) xxx_ToOp(ctx context.Context) *xxx_ExecuteReadBatchOperation {
	if o == nil {
		return &xxx_ExecuteReadBatchOperation{}
	}
	return &xxx_ExecuteReadBatchOperation{
		Key:          o.Key,
		InDataLength: o.InDataLength,
		InData:       o.InData,
	}
}

func (o *ExecuteReadBatchRequest) xxx_FromOp(ctx context.Context, op *xxx_ExecuteReadBatchOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.InDataLength = op.InDataLength
	o.InData = op.InData
}
func (o *ExecuteReadBatchRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ExecuteReadBatchRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteReadBatchOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ExecuteReadBatchResponse structure represents the ApiExecuteReadBatch operation response
type ExecuteReadBatchResponse struct {
	OutDataLength uint32 `idl:"name:cbOutData" json:"out_data_length"`
	OutData       []byte `idl:"name:lpOutData;size_is:(, cbOutData)" json:"out_data"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiExecuteReadBatch return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ExecuteReadBatchResponse) xxx_ToOp(ctx context.Context) *xxx_ExecuteReadBatchOperation {
	if o == nil {
		return &xxx_ExecuteReadBatchOperation{}
	}
	return &xxx_ExecuteReadBatchOperation{
		OutDataLength: o.OutDataLength,
		OutData:       o.OutData,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *ExecuteReadBatchResponse) xxx_FromOp(ctx context.Context, op *xxx_ExecuteReadBatchOperation) {
	if o == nil {
		return
	}
	o.OutDataLength = op.OutDataLength
	o.OutData = op.OutData
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ExecuteReadBatchResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ExecuteReadBatchResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteReadBatchOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RestartResourceOperation structure represents the ApiRestartResource operation
type xxx_RestartResourceOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Flags     uint32    `idl:"name:dwFlags" json:"flags"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_RestartResourceOperation) OpNum() int { return 146 }

func (o *xxx_RestartResourceOperation) OpName() string { return "/clusapi3/v3/ApiRestartResource" }

func (o *xxx_RestartResourceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestartResourceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestartResourceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestartResourceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestartResourceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestartResourceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RestartResourceRequest structure represents the ApiRestartResource operation request
type RestartResourceRequest struct {
	// hResource: An HRES_RPC context handle that was obtained in a previous call to ApiOpenResource
	// (section 3.1.4.2.9), ApiOpenResourceEx (section 3.1.4.2.119), or ApiCreateResource
	// (section 3.1.4.2.10).
	Resource *Resource `idl:"name:hResource" json:"resource"`
	// dwFlags: This field is reserved and is ignored by the server. Clients MUST set this
	// value to 0.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *RestartResourceRequest) xxx_ToOp(ctx context.Context) *xxx_RestartResourceOperation {
	if o == nil {
		return &xxx_RestartResourceOperation{}
	}
	return &xxx_RestartResourceOperation{
		Resource: o.Resource,
		Flags:    o.Flags,
	}
}

func (o *RestartResourceRequest) xxx_FromOp(ctx context.Context, op *xxx_RestartResourceOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Flags = op.Flags
}
func (o *RestartResourceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RestartResourceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestartResourceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RestartResourceResponse structure represents the ApiRestartResource operation response
type RestartResourceResponse struct {
	// rpc_status: A 32-bit integer used to indicate success or failure. The RPC runtime
	// MUST indicate, by writing to this parameter, whether it succeeded in executing this
	// method on the server. The encoding of the value passed in this parameter MUST conform
	// to encoding for comm_status and fault_status, as specified in Appendix E of [C706].
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRestartResource return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RestartResourceResponse) xxx_ToOp(ctx context.Context) *xxx_RestartResourceOperation {
	if o == nil {
		return &xxx_RestartResourceOperation{}
	}
	return &xxx_RestartResourceOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RestartResourceResponse) xxx_FromOp(ctx context.Context, op *xxx_RestartResourceOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RestartResourceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RestartResourceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestartResourceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNotifyAsyncOperation structure represents the ApiGetNotifyAsync operation
type xxx_GetNotifyAsyncOperation struct {
	Notify              *Notify                     `idl:"name:hNotify" json:"notify"`
	Notifications       []*NotificationDataAsyncRPC `idl:"name:Notifications;size_is:(, dwNumNotifications)" json:"notifications"`
	NotificationsLength uint32                      `idl:"name:dwNumNotifications" json:"notifications_length"`
	Return              uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNotifyAsyncOperation) OpNum() int { return 147 }

func (o *xxx_GetNotifyAsyncOperation) OpName() string { return "/clusapi3/v3/ApiGetNotifyAsync" }

func (o *xxx_GetNotifyAsyncOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyAsyncOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNotifyAsyncOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyAsyncOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Notifications != nil && o.NotificationsLength == 0 {
		o.NotificationsLength = uint32(len(o.Notifications))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyAsyncOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Notifications {out} (1:{pointer=ref}*(2))(2:{alias=PNOTIFICATION_DATA_ASYNC_RPC}*(1))(3:{alias=NOTIFICATION_DATA_ASYNC_RPC}[dim:0,size_is=dwNumNotifications](struct))
	{
		if o.Notifications != nil || o.NotificationsLength > 0 {
			_ptr_Notifications := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.NotificationsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Notifications {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Notifications[i1] != nil {
						if err := o.Notifications[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&NotificationDataAsyncRPC{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Notifications); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&NotificationDataAsyncRPC{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Notifications, _ptr_Notifications); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwNumNotifications {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotificationsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyAsyncOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Notifications {out} (1:{pointer=ref}*(2))(2:{alias=PNOTIFICATION_DATA_ASYNC_RPC,pointer=ref}*(1))(3:{alias=NOTIFICATION_DATA_ASYNC_RPC}[dim:0,size_is=dwNumNotifications](struct))
	{
		_ptr_Notifications := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Notifications", sizeInfo[0])
			}
			o.Notifications = make([]*NotificationDataAsyncRPC, sizeInfo[0])
			for i1 := range o.Notifications {
				i1 := i1
				if o.Notifications[i1] == nil {
					o.Notifications[i1] = &NotificationDataAsyncRPC{}
				}
				if err := o.Notifications[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Notifications := func(ptr interface{}) { o.Notifications = *ptr.(*[]*NotificationDataAsyncRPC) }
		if err := w.ReadPointer(&o.Notifications, _s_Notifications, _ptr_Notifications); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwNumNotifications {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotificationsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNotifyAsyncRequest structure represents the ApiGetNotifyAsync operation request
type GetNotifyAsyncRequest struct {
	// hNotify: An HNOTIFY_RPC (section 2.2.1.6) context handle that was obtained in a previous
	// ApiCreateNotify (section 3.1.4.2.56) method call.
	Notify *Notify `idl:"name:hNotify" json:"notify"`
}

func (o *GetNotifyAsyncRequest) xxx_ToOp(ctx context.Context) *xxx_GetNotifyAsyncOperation {
	if o == nil {
		return &xxx_GetNotifyAsyncOperation{}
	}
	return &xxx_GetNotifyAsyncOperation{
		Notify: o.Notify,
	}
}

func (o *GetNotifyAsyncRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyAsyncOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *GetNotifyAsyncRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNotifyAsyncRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyAsyncOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNotifyAsyncResponse structure represents the ApiGetNotifyAsync operation response
type GetNotifyAsyncResponse struct {
	// Notifications: A pointer to an array of one or more NOTIFICATION_DATA_ASYNC_RPC (section
	// 2.2.3.30) structures corresponding to the next notification events that have been
	// generated on the specified notification port, but have not yet been retrieved through
	// previous calls to ApiGetNotifyAsync or ApiGetNotify.
	Notifications []*NotificationDataAsyncRPC `idl:"name:Notifications;size_is:(, dwNumNotifications)" json:"notifications"`
	// dwNumNotifications: A pointer to a DWORD that contains the count of NOTIFICATION_DATA_ASYNC_RPC
	// structures.
	NotificationsLength uint32 `idl:"name:dwNumNotifications" json:"notifications_length"`
	// Return: The ApiGetNotifyAsync return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNotifyAsyncResponse) xxx_ToOp(ctx context.Context) *xxx_GetNotifyAsyncOperation {
	if o == nil {
		return &xxx_GetNotifyAsyncOperation{}
	}
	return &xxx_GetNotifyAsyncOperation{
		Notifications:       o.Notifications,
		NotificationsLength: o.NotificationsLength,
		Return:              o.Return,
	}
}

func (o *GetNotifyAsyncResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyAsyncOperation) {
	if o == nil {
		return
	}
	o.Notifications = op.Notifications
	o.NotificationsLength = op.NotificationsLength
	o.Return = op.Return
}
func (o *GetNotifyAsyncResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNotifyAsyncResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyAsyncOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_Opnum149otUsedOnWireOperation structure represents the Opnum149otUsedOnWire operation
type xxx_Opnum149otUsedOnWireOperation struct {
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_Opnum149otUsedOnWireOperation) OpNum() int { return 149 }

func (o *xxx_Opnum149otUsedOnWireOperation) OpName() string {
	return "/clusapi3/v3/Opnum149otUsedOnWire"
}

func (o *xxx_Opnum149otUsedOnWireOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Opnum149otUsedOnWireOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_Opnum149otUsedOnWireOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_Opnum149otUsedOnWireOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Opnum149otUsedOnWireOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Opnum149otUsedOnWireOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// Opnum149otUsedOnWireRequest structure represents the Opnum149otUsedOnWire operation request
type Opnum149otUsedOnWireRequest struct {
}

func (o *Opnum149otUsedOnWireRequest) xxx_ToOp(ctx context.Context) *xxx_Opnum149otUsedOnWireOperation {
	if o == nil {
		return &xxx_Opnum149otUsedOnWireOperation{}
	}
	return &xxx_Opnum149otUsedOnWireOperation{}
}

func (o *Opnum149otUsedOnWireRequest) xxx_FromOp(ctx context.Context, op *xxx_Opnum149otUsedOnWireOperation) {
	if o == nil {
		return
	}
}
func (o *Opnum149otUsedOnWireRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *Opnum149otUsedOnWireRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Opnum149otUsedOnWireOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// Opnum149otUsedOnWireResponse structure represents the Opnum149otUsedOnWire operation response
type Opnum149otUsedOnWireResponse struct {
	// Return: The Opnum149otUsedOnWire return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *Opnum149otUsedOnWireResponse) xxx_ToOp(ctx context.Context) *xxx_Opnum149otUsedOnWireOperation {
	if o == nil {
		return &xxx_Opnum149otUsedOnWireOperation{}
	}
	return &xxx_Opnum149otUsedOnWireOperation{
		Return: o.Return,
	}
}

func (o *Opnum149otUsedOnWireResponse) xxx_FromOp(ctx context.Context, op *xxx_Opnum149otUsedOnWireOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *Opnum149otUsedOnWireResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *Opnum149otUsedOnWireResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Opnum149otUsedOnWireOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddNotifyResourceTypeV2Operation structure represents the ApiAddNotifyResourceTypeV2 operation
type xxx_AddNotifyResourceTypeV2Operation struct {
	Notify    *Notify `idl:"name:hNotify" json:"notify"`
	Filter    int64   `idl:"name:filter" json:"filter"`
	NotifyKey uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	TypeName  string  `idl:"name:resTypeName" json:"type_name"`
	Version   uint32  `idl:"name:dwVersion" json:"version"`
	RPCStatus uint32  `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddNotifyResourceTypeV2Operation) OpNum() int { return 155 }

func (o *xxx_AddNotifyResourceTypeV2Operation) OpName() string {
	return "/clusapi3/v3/ApiAddNotifyResourceTypeV2"
}

func (o *xxx_AddNotifyResourceTypeV2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceTypeV2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// filter {in} (1:{alias=LONGLONG}(int64))
	{
		if err := w.WriteData(o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NotifyKey); err != nil {
			return err
		}
	}
	// resTypeName {in} (1:{alias=LPCWSTR}*(1)[dim:0,string](wchar))
	{
		if err := ndr.WriteUTF16String(ctx, w, o.TypeName); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceTypeV2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=HNOTIFY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// filter {in} (1:{alias=LONGLONG}(int64))
	{
		if err := w.ReadData(&o.Filter); err != nil {
			return err
		}
	}
	// dwNotifyKey {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NotifyKey); err != nil {
			return err
		}
	}
	// resTypeName {in} (1:{alias=LPCWSTR,pointer=ref}*(1)[dim:0,string](wchar))
	{
		if err := ndr.ReadUTF16String(ctx, w, &o.TypeName); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceTypeV2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceTypeV2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddNotifyResourceTypeV2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddNotifyResourceTypeV2Request structure represents the ApiAddNotifyResourceTypeV2 operation request
type AddNotifyResourceTypeV2Request struct {
	Notify    *Notify `idl:"name:hNotify" json:"notify"`
	Filter    int64   `idl:"name:filter" json:"filter"`
	NotifyKey uint32  `idl:"name:dwNotifyKey" json:"notify_key"`
	TypeName  string  `idl:"name:resTypeName" json:"type_name"`
	Version   uint32  `idl:"name:dwVersion" json:"version"`
}

func (o *AddNotifyResourceTypeV2Request) xxx_ToOp(ctx context.Context) *xxx_AddNotifyResourceTypeV2Operation {
	if o == nil {
		return &xxx_AddNotifyResourceTypeV2Operation{}
	}
	return &xxx_AddNotifyResourceTypeV2Operation{
		Notify:    o.Notify,
		Filter:    o.Filter,
		NotifyKey: o.NotifyKey,
		TypeName:  o.TypeName,
		Version:   o.Version,
	}
}

func (o *AddNotifyResourceTypeV2Request) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyResourceTypeV2Operation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.Filter = op.Filter
	o.NotifyKey = op.NotifyKey
	o.TypeName = op.TypeName
	o.Version = op.Version
}
func (o *AddNotifyResourceTypeV2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddNotifyResourceTypeV2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyResourceTypeV2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddNotifyResourceTypeV2Response structure represents the ApiAddNotifyResourceTypeV2 operation response
type AddNotifyResourceTypeV2Response struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddNotifyResourceTypeV2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddNotifyResourceTypeV2Response) xxx_ToOp(ctx context.Context) *xxx_AddNotifyResourceTypeV2Operation {
	if o == nil {
		return &xxx_AddNotifyResourceTypeV2Operation{}
	}
	return &xxx_AddNotifyResourceTypeV2Operation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddNotifyResourceTypeV2Response) xxx_FromOp(ctx context.Context, op *xxx_AddNotifyResourceTypeV2Operation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddNotifyResourceTypeV2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddNotifyResourceTypeV2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddNotifyResourceTypeV2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ExecuteReadBatchExOperation structure represents the ApiExecuteReadBatchEx operation
type xxx_ExecuteReadBatchExOperation struct {
	Key           *Key   `idl:"name:hKey" json:"key"`
	InDataLength  uint32 `idl:"name:cbInData" json:"in_data_length"`
	InData        []byte `idl:"name:lpInData;size_is:(cbInData)" json:"in_data"`
	Flags         uint32 `idl:"name:flags" json:"flags"`
	OutDataLength uint32 `idl:"name:cbOutData" json:"out_data_length"`
	OutData       []byte `idl:"name:lpOutData;size_is:(, cbOutData)" json:"out_data"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ExecuteReadBatchExOperation) OpNum() int { return 157 }

func (o *xxx_ExecuteReadBatchExOperation) OpName() string {
	return "/clusapi3/v3/ApiExecuteReadBatchEx"
}

func (o *xxx_ExecuteReadBatchExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InData != nil && o.InDataLength == 0 {
		o.InDataLength = uint32(len(o.InData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key != nil {
			if err := o.Key.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Key{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbInData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InDataLength); err != nil {
			return err
		}
	}
	// lpInData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbInData](uchar))
	{
		dimSize1 := uint64(o.InDataLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.InData {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.InData[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.InData); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hKey {in} (1:{context_handle, alias=HKEY_RPC, names=ndr_context_handle}(struct))
	{
		if o.Key == nil {
			o.Key = &Key{}
		}
		if err := o.Key.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbInData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InDataLength); err != nil {
			return err
		}
	}
	// lpInData {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=cbInData](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InData", sizeInfo[0])
		}
		o.InData = make([]byte, sizeInfo[0])
		for i1 := range o.InData {
			i1 := i1
			if err := w.ReadData(&o.InData[i1]); err != nil {
				return err
			}
		}
	}
	// flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutData != nil && o.OutDataLength == 0 {
		o.OutDataLength = uint32(len(o.OutData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// cbOutData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutDataLength); err != nil {
			return err
		}
	}
	// lpOutData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbOutData](uchar))
	{
		if o.OutData != nil || o.OutDataLength > 0 {
			_ptr_lpOutData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.OutDataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.OutData {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.OutData[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.OutData); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OutData, _ptr_lpOutData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteReadBatchExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// cbOutData {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutDataLength); err != nil {
			return err
		}
	}
	// lpOutData {out} (1:{pointer=ref}*(2)*(1))(2:{alias=UCHAR}[dim:0,size_is=cbOutData](uchar))
	{
		_ptr_lpOutData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.OutData", sizeInfo[0])
			}
			o.OutData = make([]byte, sizeInfo[0])
			for i1 := range o.OutData {
				i1 := i1
				if err := w.ReadData(&o.OutData[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpOutData := func(ptr interface{}) { o.OutData = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.OutData, _s_lpOutData, _ptr_lpOutData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ExecuteReadBatchExRequest structure represents the ApiExecuteReadBatchEx operation request
type ExecuteReadBatchExRequest struct {
	Key          *Key   `idl:"name:hKey" json:"key"`
	InDataLength uint32 `idl:"name:cbInData" json:"in_data_length"`
	InData       []byte `idl:"name:lpInData;size_is:(cbInData)" json:"in_data"`
	Flags        uint32 `idl:"name:flags" json:"flags"`
}

func (o *ExecuteReadBatchExRequest) xxx_ToOp(ctx context.Context) *xxx_ExecuteReadBatchExOperation {
	if o == nil {
		return &xxx_ExecuteReadBatchExOperation{}
	}
	return &xxx_ExecuteReadBatchExOperation{
		Key:          o.Key,
		InDataLength: o.InDataLength,
		InData:       o.InData,
		Flags:        o.Flags,
	}
}

func (o *ExecuteReadBatchExRequest) xxx_FromOp(ctx context.Context, op *xxx_ExecuteReadBatchExOperation) {
	if o == nil {
		return
	}
	o.Key = op.Key
	o.InDataLength = op.InDataLength
	o.InData = op.InData
	o.Flags = op.Flags
}
func (o *ExecuteReadBatchExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ExecuteReadBatchExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteReadBatchExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ExecuteReadBatchExResponse structure represents the ApiExecuteReadBatchEx operation response
type ExecuteReadBatchExResponse struct {
	OutDataLength uint32 `idl:"name:cbOutData" json:"out_data_length"`
	OutData       []byte `idl:"name:lpOutData;size_is:(, cbOutData)" json:"out_data"`
	RPCStatus     uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiExecuteReadBatchEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ExecuteReadBatchExResponse) xxx_ToOp(ctx context.Context) *xxx_ExecuteReadBatchExOperation {
	if o == nil {
		return &xxx_ExecuteReadBatchExOperation{}
	}
	return &xxx_ExecuteReadBatchExOperation{
		OutDataLength: o.OutDataLength,
		OutData:       o.OutData,
		RPCStatus:     o.RPCStatus,
		Return:        o.Return,
	}
}

func (o *ExecuteReadBatchExResponse) xxx_FromOp(ctx context.Context, op *xxx_ExecuteReadBatchExOperation) {
	if o == nil {
		return
	}
	o.OutDataLength = op.OutDataLength
	o.OutData = op.OutData
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ExecuteReadBatchExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ExecuteReadBatchExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteReadBatchExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupSetOperation structure represents the ApiCreateGroupSet operation
type xxx_CreateGroupSetOperation struct {
	GroupSetName string    `idl:"name:lpszGroupSetName;string" json:"group_set_name"`
	Status       uint32    `idl:"name:Status" json:"status"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       *GroupSet `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupSetOperation) OpNum() int { return 163 }

func (o *xxx_CreateGroupSetOperation) OpName() string { return "/clusapi3/v3/ApiCreateGroupSet" }

func (o *xxx_CreateGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupSetName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupSetName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupSetName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupSetName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &GroupSet{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupSetRequest structure represents the ApiCreateGroupSet operation request
type CreateGroupSetRequest struct {
	GroupSetName string `idl:"name:lpszGroupSetName;string" json:"group_set_name"`
}

func (o *CreateGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupSetOperation {
	if o == nil {
		return &xxx_CreateGroupSetOperation{}
	}
	return &xxx_CreateGroupSetOperation{
		GroupSetName: o.GroupSetName,
	}
}

func (o *CreateGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSetName = op.GroupSetName
}
func (o *CreateGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupSetResponse structure represents the ApiCreateGroupSet operation response
type CreateGroupSetResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroupSet return value.
	Return *GroupSet `idl:"name:Return" json:"return"`
}

func (o *CreateGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupSetOperation {
	if o == nil {
		return &xxx_CreateGroupSetOperation{}
	}
	return &xxx_CreateGroupSetOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *CreateGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupSetOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenGroupSetOperation structure represents the ApiOpenGroupSet operation
type xxx_OpenGroupSetOperation struct {
	GroupSetName string    `idl:"name:lpszGroupSetName;string" json:"group_set_name"`
	Status       uint32    `idl:"name:Status" json:"status"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       *GroupSet `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenGroupSetOperation) OpNum() int { return 164 }

func (o *xxx_OpenGroupSetOperation) OpName() string { return "/clusapi3/v3/ApiOpenGroupSet" }

func (o *xxx_OpenGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpszGroupSetName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupSetName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpszGroupSetName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupSetName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return != nil {
			if err := o.Return.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_OpenGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.Return == nil {
			o.Return = &GroupSet{}
		}
		if err := o.Return.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OpenGroupSetRequest structure represents the ApiOpenGroupSet operation request
type OpenGroupSetRequest struct {
	GroupSetName string `idl:"name:lpszGroupSetName;string" json:"group_set_name"`
}

func (o *OpenGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_OpenGroupSetOperation {
	if o == nil {
		return &xxx_OpenGroupSetOperation{}
	}
	return &xxx_OpenGroupSetOperation{
		GroupSetName: o.GroupSetName,
	}
}

func (o *OpenGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSetName = op.GroupSetName
}
func (o *OpenGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenGroupSetResponse structure represents the ApiOpenGroupSet operation response
type OpenGroupSetResponse struct {
	Status    uint32 `idl:"name:Status" json:"status"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiOpenGroupSet return value.
	Return *GroupSet `idl:"name:Return" json:"return"`
}

func (o *OpenGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_OpenGroupSetOperation {
	if o == nil {
		return &xxx_OpenGroupSetOperation{}
	}
	return &xxx_OpenGroupSetOperation{
		Status:    o.Status,
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *OpenGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenGroupSetOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *OpenGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseGroupSetOperation structure represents the ApiCloseGroupSet operation
type xxx_CloseGroupSetOperation struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Return   uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseGroupSetOperation) OpNum() int { return 165 }

func (o *xxx_CloseGroupSetOperation) OpName() string { return "/clusapi3/v3/ApiCloseGroupSet" }

func (o *xxx_CloseGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// GroupSet {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// GroupSet {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseGroupSetRequest structure represents the ApiCloseGroupSet operation request
type CloseGroupSetRequest struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
}

func (o *CloseGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_CloseGroupSetOperation {
	if o == nil {
		return &xxx_CloseGroupSetOperation{}
	}
	return &xxx_CloseGroupSetOperation{
		GroupSet: o.GroupSet,
	}
}

func (o *CloseGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
}
func (o *CloseGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseGroupSetResponse structure represents the ApiCloseGroupSet operation response
type CloseGroupSetResponse struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
	// Return: The ApiCloseGroupSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_CloseGroupSetOperation {
	if o == nil {
		return &xxx_CloseGroupSetOperation{}
	}
	return &xxx_CloseGroupSetOperation{
		GroupSet: o.GroupSet,
		Return:   o.Return,
	}
}

func (o *CloseGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.Return = op.Return
}
func (o *CloseGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteGroupSetOperation structure represents the ApiDeleteGroupSet operation
type xxx_DeleteGroupSetOperation struct {
	GroupSet  *GroupSet `idl:"name:GroupSet" json:"group_set"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteGroupSetOperation) OpNum() int { return 166 }

func (o *xxx_DeleteGroupSetOperation) OpName() string { return "/clusapi3/v3/ApiDeleteGroupSet" }

func (o *xxx_DeleteGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteGroupSetRequest structure represents the ApiDeleteGroupSet operation request
type DeleteGroupSetRequest struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
}

func (o *DeleteGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteGroupSetOperation {
	if o == nil {
		return &xxx_DeleteGroupSetOperation{}
	}
	return &xxx_DeleteGroupSetOperation{
		GroupSet: o.GroupSet,
	}
}

func (o *DeleteGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
}
func (o *DeleteGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteGroupSetResponse structure represents the ApiDeleteGroupSet operation response
type DeleteGroupSetResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiDeleteGroupSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteGroupSetOperation {
	if o == nil {
		return &xxx_DeleteGroupSetOperation{}
	}
	return &xxx_DeleteGroupSetOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *DeleteGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteGroupSetOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *DeleteGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddGroupToGroupSetOperation structure represents the ApiAddGroupToGroupSet operation
type xxx_AddGroupToGroupSetOperation struct {
	GroupSet  *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group     *Group    `idl:"name:Group" json:"group"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddGroupToGroupSetOperation) OpNum() int { return 167 }

func (o *xxx_AddGroupToGroupSetOperation) OpName() string {
	return "/clusapi3/v3/ApiAddGroupToGroupSet"
}

func (o *xxx_AddGroupToGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddGroupToGroupSetRequest structure represents the ApiAddGroupToGroupSet operation request
type AddGroupToGroupSetRequest struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group    *Group    `idl:"name:Group" json:"group"`
}

func (o *AddGroupToGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetOperation{}
	}
	return &xxx_AddGroupToGroupSetOperation{
		GroupSet: o.GroupSet,
		Group:    o.Group,
	}
}

func (o *AddGroupToGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.Group = op.Group
}
func (o *AddGroupToGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddGroupToGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddGroupToGroupSetResponse structure represents the ApiAddGroupToGroupSet operation response
type AddGroupToGroupSetResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddGroupToGroupSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddGroupToGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetOperation{}
	}
	return &xxx_AddGroupToGroupSetOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddGroupToGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddGroupToGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddGroupToGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveGroupFromGroupSetOperation structure represents the ApiRemoveGroupFromGroupSet operation
type xxx_RemoveGroupFromGroupSetOperation struct {
	Group     *Group `idl:"name:Group" json:"group"`
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveGroupFromGroupSetOperation) OpNum() int { return 168 }

func (o *xxx_RemoveGroupFromGroupSetOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveGroupFromGroupSet"
}

func (o *xxx_RemoveGroupFromGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupFromGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveGroupFromGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupFromGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupFromGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupFromGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveGroupFromGroupSetRequest structure represents the ApiRemoveGroupFromGroupSet operation request
type RemoveGroupFromGroupSetRequest struct {
	Group *Group `idl:"name:Group" json:"group"`
}

func (o *RemoveGroupFromGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveGroupFromGroupSetOperation {
	if o == nil {
		return &xxx_RemoveGroupFromGroupSetOperation{}
	}
	return &xxx_RemoveGroupFromGroupSetOperation{
		Group: o.Group,
	}
}

func (o *RemoveGroupFromGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveGroupFromGroupSetOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *RemoveGroupFromGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveGroupFromGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveGroupFromGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveGroupFromGroupSetResponse structure represents the ApiRemoveGroupFromGroupSet operation response
type RemoveGroupFromGroupSetResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveGroupFromGroupSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveGroupFromGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveGroupFromGroupSetOperation {
	if o == nil {
		return &xxx_RemoveGroupFromGroupSetOperation{}
	}
	return &xxx_RemoveGroupFromGroupSetOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveGroupFromGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveGroupFromGroupSetOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveGroupFromGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveGroupFromGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveGroupFromGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_MoveGroupToGroupSetOperation structure represents the ApiMoveGroupToGroupSet operation
type xxx_MoveGroupToGroupSetOperation struct {
	GroupSet  *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group     *Group    `idl:"name:Group" json:"group"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_MoveGroupToGroupSetOperation) OpNum() int { return 169 }

func (o *xxx_MoveGroupToGroupSetOperation) OpName() string {
	return "/clusapi3/v3/ApiMoveGroupToGroupSet"
}

func (o *xxx_MoveGroupToGroupSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToGroupSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_MoveGroupToGroupSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToGroupSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToGroupSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_MoveGroupToGroupSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// MoveGroupToGroupSetRequest structure represents the ApiMoveGroupToGroupSet operation request
type MoveGroupToGroupSetRequest struct {
	GroupSet *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group    *Group    `idl:"name:Group" json:"group"`
}

func (o *MoveGroupToGroupSetRequest) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToGroupSetOperation {
	if o == nil {
		return &xxx_MoveGroupToGroupSetOperation{}
	}
	return &xxx_MoveGroupToGroupSetOperation{
		GroupSet: o.GroupSet,
		Group:    o.Group,
	}
}

func (o *MoveGroupToGroupSetRequest) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToGroupSetOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.Group = op.Group
}
func (o *MoveGroupToGroupSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *MoveGroupToGroupSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToGroupSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// MoveGroupToGroupSetResponse structure represents the ApiMoveGroupToGroupSet operation response
type MoveGroupToGroupSetResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiMoveGroupToGroupSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *MoveGroupToGroupSetResponse) xxx_ToOp(ctx context.Context) *xxx_MoveGroupToGroupSetOperation {
	if o == nil {
		return &xxx_MoveGroupToGroupSetOperation{}
	}
	return &xxx_MoveGroupToGroupSetOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *MoveGroupToGroupSetResponse) xxx_FromOp(ctx context.Context, op *xxx_MoveGroupToGroupSetOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *MoveGroupToGroupSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *MoveGroupToGroupSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_MoveGroupToGroupSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddGroupSetDependencyOperation structure represents the ApiAddGroupSetDependency operation
type xxx_AddGroupSetDependencyOperation struct {
	DependentGroupSet *GroupSet `idl:"name:DependentGroupSet" json:"dependent_group_set"`
	ProviderGroupSet  *GroupSet `idl:"name:ProviderGroupSet" json:"provider_group_set"`
	RPCStatus         uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return            uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddGroupSetDependencyOperation) OpNum() int { return 171 }

func (o *xxx_AddGroupSetDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiAddGroupSetDependency"
}

func (o *xxx_AddGroupSetDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupSetDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// DependentGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DependentGroupSet != nil {
			if err := o.DependentGroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ProviderGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.ProviderGroupSet != nil {
			if err := o.ProviderGroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddGroupSetDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// DependentGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DependentGroupSet == nil {
			o.DependentGroupSet = &GroupSet{}
		}
		if err := o.DependentGroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ProviderGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.ProviderGroupSet == nil {
			o.ProviderGroupSet = &GroupSet{}
		}
		if err := o.ProviderGroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupSetDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupSetDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupSetDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddGroupSetDependencyRequest structure represents the ApiAddGroupSetDependency operation request
type AddGroupSetDependencyRequest struct {
	DependentGroupSet *GroupSet `idl:"name:DependentGroupSet" json:"dependent_group_set"`
	ProviderGroupSet  *GroupSet `idl:"name:ProviderGroupSet" json:"provider_group_set"`
}

func (o *AddGroupSetDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_AddGroupSetDependencyOperation {
	if o == nil {
		return &xxx_AddGroupSetDependencyOperation{}
	}
	return &xxx_AddGroupSetDependencyOperation{
		DependentGroupSet: o.DependentGroupSet,
		ProviderGroupSet:  o.ProviderGroupSet,
	}
}

func (o *AddGroupSetDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_AddGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.DependentGroupSet = op.DependentGroupSet
	o.ProviderGroupSet = op.ProviderGroupSet
}
func (o *AddGroupSetDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddGroupSetDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddGroupSetDependencyResponse structure represents the ApiAddGroupSetDependency operation response
type AddGroupSetDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddGroupSetDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddGroupSetDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_AddGroupSetDependencyOperation {
	if o == nil {
		return &xxx_AddGroupSetDependencyOperation{}
	}
	return &xxx_AddGroupSetDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddGroupSetDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_AddGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddGroupSetDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddGroupSetDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddGroupToGroupSetDependencyOperation structure represents the ApiAddGroupToGroupSetDependency operation
type xxx_AddGroupToGroupSetDependencyOperation struct {
	DependentGroup   *Group    `idl:"name:DependentGroup" json:"dependent_group"`
	ProviderGroupSet *GroupSet `idl:"name:ProviderGroupSet" json:"provider_group_set"`
	RPCStatus        uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return           uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) OpNum() int { return 172 }

func (o *xxx_AddGroupToGroupSetDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiAddGroupToGroupSetDependency"
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// DependentGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.DependentGroup != nil {
			if err := o.DependentGroup.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ProviderGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.ProviderGroupSet != nil {
			if err := o.ProviderGroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// DependentGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.DependentGroup == nil {
			o.DependentGroup = &Group{}
		}
		if err := o.DependentGroup.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ProviderGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.ProviderGroupSet == nil {
			o.ProviderGroupSet = &GroupSet{}
		}
		if err := o.ProviderGroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddGroupToGroupSetDependencyRequest structure represents the ApiAddGroupToGroupSetDependency operation request
type AddGroupToGroupSetDependencyRequest struct {
	DependentGroup   *Group    `idl:"name:DependentGroup" json:"dependent_group"`
	ProviderGroupSet *GroupSet `idl:"name:ProviderGroupSet" json:"provider_group_set"`
}

func (o *AddGroupToGroupSetDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetDependencyOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetDependencyOperation{}
	}
	return &xxx_AddGroupToGroupSetDependencyOperation{
		DependentGroup:   o.DependentGroup,
		ProviderGroupSet: o.ProviderGroupSet,
	}
}

func (o *AddGroupToGroupSetDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.DependentGroup = op.DependentGroup
	o.ProviderGroupSet = op.ProviderGroupSet
}
func (o *AddGroupToGroupSetDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddGroupToGroupSetDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddGroupToGroupSetDependencyResponse structure represents the ApiAddGroupToGroupSetDependency operation response
type AddGroupToGroupSetDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddGroupToGroupSetDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddGroupToGroupSetDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetDependencyOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetDependencyOperation{}
	}
	return &xxx_AddGroupToGroupSetDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddGroupToGroupSetDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddGroupToGroupSetDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddGroupToGroupSetDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NodeGroupSetControlOperation structure represents the ApiNodeGroupSetControl operation
type xxx_NodeGroupSetControlOperation struct {
	GroupSet       *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	Node           *Node     `idl:"name:hNode" json:"node"`
	ControlCode    uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte    `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32    `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32    `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_NodeGroupSetControlOperation) OpNum() int { return 173 }

func (o *xxx_NodeGroupSetControlOperation) OpName() string {
	return "/clusapi3/v3/ApiNodeGroupSetControl"
}

func (o *xxx_NodeGroupSetControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if o.OutBufferSize > uint32(2147483647) {
		return fmt.Errorf("OutBufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupSetControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node != nil {
			if err := o.Node.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Node{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{range=(0,2147483647), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupSetControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hNode {in} (1:{context_handle, alias=HNODE_RPC, names=ndr_context_handle}(struct))
	{
		if o.Node == nil {
			o.Node = &Node{}
		}
		if err := o.Node.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{range=(0,2147483647), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupSetControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupSetControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NodeGroupSetControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NodeGroupSetControlRequest structure represents the ApiNodeGroupSetControl operation request
type NodeGroupSetControlRequest struct {
	GroupSet      *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	Node          *Node     `idl:"name:hNode" json:"node"`
	ControlCode   uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *NodeGroupSetControlRequest) xxx_ToOp(ctx context.Context) *xxx_NodeGroupSetControlOperation {
	if o == nil {
		return &xxx_NodeGroupSetControlOperation{}
	}
	return &xxx_NodeGroupSetControlOperation{
		GroupSet:      o.GroupSet,
		Node:          o.Node,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *NodeGroupSetControlRequest) xxx_FromOp(ctx context.Context, op *xxx_NodeGroupSetControlOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.Node = op.Node
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *NodeGroupSetControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NodeGroupSetControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeGroupSetControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NodeGroupSetControlResponse structure represents the ApiNodeGroupSetControl operation response
type NodeGroupSetControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiNodeGroupSetControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NodeGroupSetControlResponse) xxx_ToOp(ctx context.Context) *xxx_NodeGroupSetControlOperation {
	if o == nil {
		return &xxx_NodeGroupSetControlOperation{}
	}
	return &xxx_NodeGroupSetControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *NodeGroupSetControlResponse) xxx_FromOp(ctx context.Context, op *xxx_NodeGroupSetControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *NodeGroupSetControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NodeGroupSetControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NodeGroupSetControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GroupSetControlOperation structure represents the ApiGroupSetControl operation
type xxx_GroupSetControlOperation struct {
	GroupSet       *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	ControlCode    uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer       []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize   uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBuffer      []byte    `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	OutBufferSize  uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
	BytesReturned  uint32    `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32    `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GroupSetControlOperation) OpNum() int { return 174 }

func (o *xxx_GroupSetControlOperation) OpName() string { return "/clusapi3/v3/ApiGroupSetControl" }

func (o *xxx_GroupSetControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.InBuffer != nil && o.InBufferSize == 0 {
		o.InBufferSize = uint32(len(o.InBuffer))
	}
	if o.OutBufferSize > uint32(2147483647) {
		return fmt.Errorf("OutBufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupSetControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		if o.InBuffer != nil || o.InBufferSize > 0 {
			_ptr_lpInBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.InBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.InBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.InBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.InBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.InBuffer, _ptr_lpInBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{range=(0,2147483647), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupSetControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControlCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ControlCode); err != nil {
			return err
		}
	}
	// lpInBuffer {in} (1:{pointer=unique}*(1))(2:{alias=UCHAR}[dim:0,size_is=nInBufferSize](uchar))
	{
		_ptr_lpInBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.InBuffer", sizeInfo[0])
			}
			o.InBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.InBuffer {
				i1 := i1
				if err := w.ReadData(&o.InBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpInBuffer := func(ptr interface{}) { o.InBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.InBuffer, _s_lpInBuffer, _ptr_lpInBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nInBufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InBufferSize); err != nil {
			return err
		}
	}
	// nOutBufferSize {in} (1:{range=(0,2147483647), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupSetControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.OutBuffer != nil && o.BytesReturned == 0 {
		o.BytesReturned = uint32(len(o.OutBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupSetControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		dimSize1 := uint64(o.OutBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := uint64(o.BytesReturned)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		for i1 := range o.OutBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GroupSetControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpOutBuffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=nOutBufferSize,length_is=lpBytesReturned](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutBuffer", sizeInfo[0])
		}
		o.OutBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// lpBytesReturned {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesReturned); err != nil {
			return err
		}
	}
	// lpcbRequired {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GroupSetControlRequest structure represents the ApiGroupSetControl operation request
type GroupSetControlRequest struct {
	GroupSet      *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	ControlCode   uint32    `idl:"name:dwControlCode" json:"control_code"`
	InBuffer      []byte    `idl:"name:lpInBuffer;size_is:(nInBufferSize);pointer:unique" json:"in_buffer"`
	InBufferSize  uint32    `idl:"name:nInBufferSize" json:"in_buffer_size"`
	OutBufferSize uint32    `idl:"name:nOutBufferSize" json:"out_buffer_size"`
}

func (o *GroupSetControlRequest) xxx_ToOp(ctx context.Context) *xxx_GroupSetControlOperation {
	if o == nil {
		return &xxx_GroupSetControlOperation{}
	}
	return &xxx_GroupSetControlOperation{
		GroupSet:      o.GroupSet,
		ControlCode:   o.ControlCode,
		InBuffer:      o.InBuffer,
		InBufferSize:  o.InBufferSize,
		OutBufferSize: o.OutBufferSize,
	}
}

func (o *GroupSetControlRequest) xxx_FromOp(ctx context.Context, op *xxx_GroupSetControlOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.ControlCode = op.ControlCode
	o.InBuffer = op.InBuffer
	o.InBufferSize = op.InBufferSize
	o.OutBufferSize = op.OutBufferSize
}
func (o *GroupSetControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GroupSetControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GroupSetControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GroupSetControlResponse structure represents the ApiGroupSetControl operation response
type GroupSetControlResponse struct {
	OutBuffer      []byte `idl:"name:lpOutBuffer;size_is:(nOutBufferSize);length_is:(lpBytesReturned)" json:"out_buffer"`
	BytesReturned  uint32 `idl:"name:lpBytesReturned" json:"bytes_returned"`
	RequiredLength uint32 `idl:"name:lpcbRequired" json:"required_length"`
	RPCStatus      uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiGroupSetControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GroupSetControlResponse) xxx_ToOp(ctx context.Context) *xxx_GroupSetControlOperation {
	if o == nil {
		return &xxx_GroupSetControlOperation{}
	}
	return &xxx_GroupSetControlOperation{
		OutBuffer:      o.OutBuffer,
		BytesReturned:  o.BytesReturned,
		RequiredLength: o.RequiredLength,
		RPCStatus:      o.RPCStatus,
		Return:         o.Return,
	}
}

func (o *GroupSetControlResponse) xxx_FromOp(ctx context.Context, op *xxx_GroupSetControlOperation) {
	if o == nil {
		return
	}
	o.OutBuffer = op.OutBuffer
	o.BytesReturned = op.BytesReturned
	o.RequiredLength = op.RequiredLength
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *GroupSetControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GroupSetControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GroupSetControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGroupDependencyExpressionOperation structure represents the ApiSetGroupDependencyExpression operation
type xxx_SetGroupDependencyExpressionOperation struct {
	Group                *Group `idl:"name:hGroup" json:"group"`
	DependencyExpression string `idl:"name:lpszDependencyExpression" json:"dependency_expression"`
	RPCStatus            uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return               uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGroupDependencyExpressionOperation) OpNum() int { return 175 }

func (o *xxx_SetGroupDependencyExpressionOperation) OpName() string {
	return "/clusapi3/v3/ApiSetGroupDependencyExpression"
}

func (o *xxx_SetGroupDependencyExpressionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupDependencyExpressionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszDependencyExpression {in} (1:{alias=LPCWSTR}*(1)[dim:0,string](wchar))
	{
		if err := ndr.WriteUTF16String(ctx, w, o.DependencyExpression); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupDependencyExpressionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszDependencyExpression {in} (1:{alias=LPCWSTR,pointer=ref}*(1)[dim:0,string](wchar))
	{
		if err := ndr.ReadUTF16String(ctx, w, &o.DependencyExpression); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupDependencyExpressionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupDependencyExpressionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupDependencyExpressionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGroupDependencyExpressionRequest structure represents the ApiSetGroupDependencyExpression operation request
type SetGroupDependencyExpressionRequest struct {
	Group                *Group `idl:"name:hGroup" json:"group"`
	DependencyExpression string `idl:"name:lpszDependencyExpression" json:"dependency_expression"`
}

func (o *SetGroupDependencyExpressionRequest) xxx_ToOp(ctx context.Context) *xxx_SetGroupDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetGroupDependencyExpressionOperation{}
	}
	return &xxx_SetGroupDependencyExpressionOperation{
		Group:                o.Group,
		DependencyExpression: o.DependencyExpression,
	}
}

func (o *SetGroupDependencyExpressionRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGroupDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.DependencyExpression = op.DependencyExpression
}
func (o *SetGroupDependencyExpressionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetGroupDependencyExpressionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGroupDependencyExpressionResponse structure represents the ApiSetGroupDependencyExpression operation response
type SetGroupDependencyExpressionResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetGroupDependencyExpression return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGroupDependencyExpressionResponse) xxx_ToOp(ctx context.Context) *xxx_SetGroupDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetGroupDependencyExpressionOperation{}
	}
	return &xxx_SetGroupDependencyExpressionOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetGroupDependencyExpressionResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGroupDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetGroupDependencyExpressionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetGroupDependencyExpressionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveClusterGroupDependencyOperation structure represents the ApiRemoveClusterGroupDependency operation
type xxx_RemoveClusterGroupDependencyOperation struct {
	Group      *Group `idl:"name:hGroup" json:"group"`
	DepdendsOn *Group `idl:"name:hDependsOn" json:"depdends_on"`
	RPCStatus  uint32 `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveClusterGroupDependencyOperation) OpNum() int { return 176 }

func (o *xxx_RemoveClusterGroupDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveClusterGroupDependency"
}

func (o *xxx_RemoveClusterGroupDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn != nil {
			if err := o.DepdendsOn.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn == nil {
			o.DepdendsOn = &Group{}
		}
		if err := o.DepdendsOn.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveClusterGroupDependencyRequest structure represents the ApiRemoveClusterGroupDependency operation request
type RemoveClusterGroupDependencyRequest struct {
	Group      *Group `idl:"name:hGroup" json:"group"`
	DepdendsOn *Group `idl:"name:hDependsOn" json:"depdends_on"`
}

func (o *RemoveClusterGroupDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveClusterGroupDependencyOperation {
	if o == nil {
		return &xxx_RemoveClusterGroupDependencyOperation{}
	}
	return &xxx_RemoveClusterGroupDependencyOperation{
		Group:      o.Group,
		DepdendsOn: o.DepdendsOn,
	}
}

func (o *RemoveClusterGroupDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveClusterGroupDependencyOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.DepdendsOn = op.DepdendsOn
}
func (o *RemoveClusterGroupDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveClusterGroupDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveClusterGroupDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveClusterGroupDependencyResponse structure represents the ApiRemoveClusterGroupDependency operation response
type RemoveClusterGroupDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveClusterGroupDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveClusterGroupDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveClusterGroupDependencyOperation {
	if o == nil {
		return &xxx_RemoveClusterGroupDependencyOperation{}
	}
	return &xxx_RemoveClusterGroupDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveClusterGroupDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveClusterGroupDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveClusterGroupDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveClusterGroupDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveClusterGroupDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGroupSetDependencyExpressionOperation structure represents the ApiSetGroupSetDependencyExpression operation
type xxx_SetGroupSetDependencyExpressionOperation struct {
	GroupSet             *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	DependencyExpression string    `idl:"name:lpszDependencyExpression" json:"dependency_expression"`
	RPCStatus            uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return               uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) OpNum() int { return 177 }

func (o *xxx_SetGroupSetDependencyExpressionOperation) OpName() string {
	return "/clusapi3/v3/ApiSetGroupSetDependencyExpression"
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszDependencyExpression {in} (1:{alias=LPCWSTR}*(1)[dim:0,string](wchar))
	{
		if err := ndr.WriteUTF16String(ctx, w, o.DependencyExpression); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszDependencyExpression {in} (1:{alias=LPCWSTR,pointer=ref}*(1)[dim:0,string](wchar))
	{
		if err := ndr.ReadUTF16String(ctx, w, &o.DependencyExpression); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGroupSetDependencyExpressionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGroupSetDependencyExpressionRequest structure represents the ApiSetGroupSetDependencyExpression operation request
type SetGroupSetDependencyExpressionRequest struct {
	GroupSet             *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	DependencyExpression string    `idl:"name:lpszDependencyExpression" json:"dependency_expression"`
}

func (o *SetGroupSetDependencyExpressionRequest) xxx_ToOp(ctx context.Context) *xxx_SetGroupSetDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetGroupSetDependencyExpressionOperation{}
	}
	return &xxx_SetGroupSetDependencyExpressionOperation{
		GroupSet:             o.GroupSet,
		DependencyExpression: o.DependencyExpression,
	}
}

func (o *SetGroupSetDependencyExpressionRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGroupSetDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.DependencyExpression = op.DependencyExpression
}
func (o *SetGroupSetDependencyExpressionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetGroupSetDependencyExpressionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupSetDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGroupSetDependencyExpressionResponse structure represents the ApiSetGroupSetDependencyExpression operation response
type SetGroupSetDependencyExpressionResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiSetGroupSetDependencyExpression return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGroupSetDependencyExpressionResponse) xxx_ToOp(ctx context.Context) *xxx_SetGroupSetDependencyExpressionOperation {
	if o == nil {
		return &xxx_SetGroupSetDependencyExpressionOperation{}
	}
	return &xxx_SetGroupSetDependencyExpressionOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *SetGroupSetDependencyExpressionResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGroupSetDependencyExpressionOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *SetGroupSetDependencyExpressionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetGroupSetDependencyExpressionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGroupSetDependencyExpressionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveGroupSetDependencyOperation structure represents the ApiRemoveGroupSetDependency operation
type xxx_RemoveGroupSetDependencyOperation struct {
	GroupSet   *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	DepdendsOn *GroupSet `idl:"name:hDependsOn" json:"depdends_on"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveGroupSetDependencyOperation) OpNum() int { return 178 }

func (o *xxx_RemoveGroupSetDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveGroupSetDependency"
}

func (o *xxx_RemoveGroupSetDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupSetDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn != nil {
			if err := o.DepdendsOn.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveGroupSetDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn == nil {
			o.DepdendsOn = &GroupSet{}
		}
		if err := o.DepdendsOn.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupSetDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupSetDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveGroupSetDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveGroupSetDependencyRequest structure represents the ApiRemoveGroupSetDependency operation request
type RemoveGroupSetDependencyRequest struct {
	GroupSet   *GroupSet `idl:"name:hGroupSet" json:"group_set"`
	DepdendsOn *GroupSet `idl:"name:hDependsOn" json:"depdends_on"`
}

func (o *RemoveGroupSetDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveGroupSetDependencyOperation {
	if o == nil {
		return &xxx_RemoveGroupSetDependencyOperation{}
	}
	return &xxx_RemoveGroupSetDependencyOperation{
		GroupSet:   o.GroupSet,
		DepdendsOn: o.DepdendsOn,
	}
}

func (o *RemoveGroupSetDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.DepdendsOn = op.DepdendsOn
}
func (o *RemoveGroupSetDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveGroupSetDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveGroupSetDependencyResponse structure represents the ApiRemoveGroupSetDependency operation response
type RemoveGroupSetDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveGroupSetDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveGroupSetDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveGroupSetDependencyOperation {
	if o == nil {
		return &xxx_RemoveGroupSetDependencyOperation{}
	}
	return &xxx_RemoveGroupSetDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveGroupSetDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveGroupSetDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveGroupSetDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveClusterGroupToGroupSetDependencyOperation structure represents the ApiRemoveClusterGroupToGroupSetDependency operation
type xxx_RemoveClusterGroupToGroupSetDependencyOperation struct {
	Group      *Group    `idl:"name:hGroup" json:"group"`
	DepdendsOn *GroupSet `idl:"name:hDependsOn" json:"depdends_on"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) OpNum() int { return 179 }

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) OpName() string {
	return "/clusapi3/v3/ApiRemoveClusterGroupToGroupSetDependency"
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn != nil {
			if err := o.DepdendsOn.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hDependsOn {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.DepdendsOn == nil {
			o.DepdendsOn = &GroupSet{}
		}
		if err := o.DepdendsOn.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveClusterGroupToGroupSetDependencyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveClusterGroupToGroupSetDependencyRequest structure represents the ApiRemoveClusterGroupToGroupSetDependency operation request
type RemoveClusterGroupToGroupSetDependencyRequest struct {
	Group      *Group    `idl:"name:hGroup" json:"group"`
	DepdendsOn *GroupSet `idl:"name:hDependsOn" json:"depdends_on"`
}

func (o *RemoveClusterGroupToGroupSetDependencyRequest) xxx_ToOp(ctx context.Context) *xxx_RemoveClusterGroupToGroupSetDependencyOperation {
	if o == nil {
		return &xxx_RemoveClusterGroupToGroupSetDependencyOperation{}
	}
	return &xxx_RemoveClusterGroupToGroupSetDependencyOperation{
		Group:      o.Group,
		DepdendsOn: o.DepdendsOn,
	}
}

func (o *RemoveClusterGroupToGroupSetDependencyRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveClusterGroupToGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
	o.DepdendsOn = op.DepdendsOn
}
func (o *RemoveClusterGroupToGroupSetDependencyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *RemoveClusterGroupToGroupSetDependencyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveClusterGroupToGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveClusterGroupToGroupSetDependencyResponse structure represents the ApiRemoveClusterGroupToGroupSetDependency operation response
type RemoveClusterGroupToGroupSetDependencyResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiRemoveClusterGroupToGroupSetDependency return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveClusterGroupToGroupSetDependencyResponse) xxx_ToOp(ctx context.Context) *xxx_RemoveClusterGroupToGroupSetDependencyOperation {
	if o == nil {
		return &xxx_RemoveClusterGroupToGroupSetDependencyOperation{}
	}
	return &xxx_RemoveClusterGroupToGroupSetDependencyOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *RemoveClusterGroupToGroupSetDependencyResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveClusterGroupToGroupSetDependencyOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *RemoveClusterGroupToGroupSetDependencyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *RemoveClusterGroupToGroupSetDependencyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveClusterGroupToGroupSetDependencyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateGroupSetEnumOperation structure represents the ApiCreateGroupSetEnum operation
type xxx_CreateGroupSetEnumOperation struct {
	Cluster    *Cluster  `idl:"name:hCluster" json:"cluster"`
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateGroupSetEnumOperation) OpNum() int { return 180 }

func (o *xxx_CreateGroupSetEnumOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateGroupSetEnum"
}

func (o *xxx_CreateGroupSetEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateGroupSetEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateGroupSetEnumRequest structure represents the ApiCreateGroupSetEnum operation request
type CreateGroupSetEnumRequest struct {
	Cluster *Cluster `idl:"name:hCluster" json:"cluster"`
}

func (o *CreateGroupSetEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateGroupSetEnumOperation {
	if o == nil {
		return &xxx_CreateGroupSetEnumOperation{}
	}
	return &xxx_CreateGroupSetEnumOperation{
		Cluster: o.Cluster,
	}
}

func (o *CreateGroupSetEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupSetEnumOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
}
func (o *CreateGroupSetEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateGroupSetEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupSetEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateGroupSetEnumResponse structure represents the ApiCreateGroupSetEnum operation response
type CreateGroupSetEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateGroupSetEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateGroupSetEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateGroupSetEnumOperation {
	if o == nil {
		return &xxx_CreateGroupSetEnumOperation{}
	}
	return &xxx_CreateGroupSetEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateGroupSetEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateGroupSetEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateGroupSetEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateGroupSetEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateGroupSetEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateNetInterfaceEnumOperation structure represents the ApiCreateNetInterfaceEnum operation
type xxx_CreateNetInterfaceEnumOperation struct {
	Cluster     *Cluster  `idl:"name:hCluster" json:"cluster"`
	NodeName    string    `idl:"name:lpszNodeName" json:"node_name"`
	NetworkName string    `idl:"name:lpszNetworkName" json:"network_name"`
	ReturnEnum  *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus   uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return      uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateNetInterfaceEnumOperation) OpNum() int { return 181 }

func (o *xxx_CreateNetInterfaceEnumOperation) OpName() string {
	return "/clusapi3/v3/ApiCreateNetInterfaceEnum"
}

func (o *xxx_CreateNetInterfaceEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetInterfaceEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster != nil {
			if err := o.Cluster.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Cluster{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpszNodeName {in} (1:{alias=LPCWSTR}*(1)[dim:0,string](wchar))
	{
		if err := ndr.WriteUTF16String(ctx, w, o.NodeName); err != nil {
			return err
		}
	}
	// lpszNetworkName {in} (1:{alias=LPCWSTR}*(1)[dim:0,string](wchar))
	{
		if err := ndr.WriteUTF16String(ctx, w, o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetInterfaceEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCluster {in} (1:{context_handle, alias=HCLUSTER_RPC, names=ndr_context_handle}(struct))
	{
		if o.Cluster == nil {
			o.Cluster = &Cluster{}
		}
		if err := o.Cluster.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpszNodeName {in} (1:{alias=LPCWSTR,pointer=ref}*(1)[dim:0,string](wchar))
	{
		if err := ndr.ReadUTF16String(ctx, w, &o.NodeName); err != nil {
			return err
		}
	}
	// lpszNetworkName {in} (1:{alias=LPCWSTR,pointer=ref}*(1)[dim:0,string](wchar))
	{
		if err := ndr.ReadUTF16String(ctx, w, &o.NetworkName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetInterfaceEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetInterfaceEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		if o.ReturnEnum != nil {
			_ptr_ReturnEnum := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnEnum != nil {
					if err := o.ReturnEnum.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EnumList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnEnum, _ptr_ReturnEnum); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateNetInterfaceEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnEnum {out} (1:{pointer=ref}*(2))(2:{alias=PENUM_LIST,pointer=ref}*(1))(3:{alias=ENUM_LIST}(struct))
	{
		_ptr_ReturnEnum := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnEnum == nil {
				o.ReturnEnum = &EnumList{}
			}
			if err := o.ReturnEnum.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnEnum := func(ptr interface{}) { o.ReturnEnum = *ptr.(**EnumList) }
		if err := w.ReadPointer(&o.ReturnEnum, _s_ReturnEnum, _ptr_ReturnEnum); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateNetInterfaceEnumRequest structure represents the ApiCreateNetInterfaceEnum operation request
type CreateNetInterfaceEnumRequest struct {
	Cluster     *Cluster `idl:"name:hCluster" json:"cluster"`
	NodeName    string   `idl:"name:lpszNodeName" json:"node_name"`
	NetworkName string   `idl:"name:lpszNetworkName" json:"network_name"`
}

func (o *CreateNetInterfaceEnumRequest) xxx_ToOp(ctx context.Context) *xxx_CreateNetInterfaceEnumOperation {
	if o == nil {
		return &xxx_CreateNetInterfaceEnumOperation{}
	}
	return &xxx_CreateNetInterfaceEnumOperation{
		Cluster:     o.Cluster,
		NodeName:    o.NodeName,
		NetworkName: o.NetworkName,
	}
}

func (o *CreateNetInterfaceEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateNetInterfaceEnumOperation) {
	if o == nil {
		return
	}
	o.Cluster = op.Cluster
	o.NodeName = op.NodeName
	o.NetworkName = op.NetworkName
}
func (o *CreateNetInterfaceEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateNetInterfaceEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNetInterfaceEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateNetInterfaceEnumResponse structure represents the ApiCreateNetInterfaceEnum operation response
type CreateNetInterfaceEnumResponse struct {
	ReturnEnum *EnumList `idl:"name:ReturnEnum" json:"return_enum"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiCreateNetInterfaceEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateNetInterfaceEnumResponse) xxx_ToOp(ctx context.Context) *xxx_CreateNetInterfaceEnumOperation {
	if o == nil {
		return &xxx_CreateNetInterfaceEnumOperation{}
	}
	return &xxx_CreateNetInterfaceEnumOperation{
		ReturnEnum: o.ReturnEnum,
		RPCStatus:  o.RPCStatus,
		Return:     o.Return,
	}
}

func (o *CreateNetInterfaceEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateNetInterfaceEnumOperation) {
	if o == nil {
		return
	}
	o.ReturnEnum = op.ReturnEnum
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *CreateNetInterfaceEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateNetInterfaceEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateNetInterfaceEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeCSVStateExOperation structure represents the ApiChangeCsvStateEx operation
type xxx_ChangeCSVStateExOperation struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	State      uint32    `idl:"name:dwState" json:"state"`
	VolumeName string    `idl:"name:lpszVolumeName;string" json:"volume_name"`
	RPCStatus  uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeCSVStateExOperation) OpNum() int { return 182 }

func (o *xxx_ChangeCSVStateExOperation) OpName() string { return "/clusapi3/v3/ApiChangeCsvStateEx" }

func (o *xxx_ChangeCSVStateExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	// lpszVolumeName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.VolumeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	// lpszVolumeName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.VolumeName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeCSVStateExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeCSVStateExRequest structure represents the ApiChangeCsvStateEx operation request
type ChangeCSVStateExRequest struct {
	Resource   *Resource `idl:"name:hResource" json:"resource"`
	State      uint32    `idl:"name:dwState" json:"state"`
	VolumeName string    `idl:"name:lpszVolumeName;string" json:"volume_name"`
}

func (o *ChangeCSVStateExRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeCSVStateExOperation {
	if o == nil {
		return &xxx_ChangeCSVStateExOperation{}
	}
	return &xxx_ChangeCSVStateExOperation{
		Resource:   o.Resource,
		State:      o.State,
		VolumeName: o.VolumeName,
	}
}

func (o *ChangeCSVStateExRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeCSVStateExOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.State = op.State
	o.VolumeName = op.VolumeName
}
func (o *ChangeCSVStateExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeCSVStateExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeCSVStateExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeCSVStateExResponse structure represents the ApiChangeCsvStateEx operation response
type ChangeCSVStateExResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiChangeCsvStateEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeCSVStateExResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeCSVStateExOperation {
	if o == nil {
		return &xxx_ChangeCSVStateExOperation{}
	}
	return &xxx_ChangeCSVStateExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ChangeCSVStateExResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeCSVStateExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ChangeCSVStateExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeCSVStateExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeCSVStateExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddGroupToGroupSetExOperation structure represents the ApiAddGroupToGroupSetEx operation
type xxx_AddGroupToGroupSetExOperation struct {
	GroupSet     *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group        *Group    `idl:"name:Group" json:"group"`
	FaultDomain  uint32    `idl:"name:FaultDomain" json:"fault_domain"`
	UpdateDomain uint32    `idl:"name:UpdateDomain" json:"update_domain"`
	UseDomains   bool      `idl:"name:UseDomains" json:"use_domains"`
	_            uint32    `idl:"name:Reserved"`
	RPCStatus    uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return       uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddGroupToGroupSetExOperation) OpNum() int { return 183 }

func (o *xxx_AddGroupToGroupSetExOperation) OpName() string {
	return "/clusapi3/v3/ApiAddGroupToGroupSetEx"
}

func (o *xxx_AddGroupToGroupSetExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet != nil {
			if err := o.GroupSet.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&GroupSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// FaultDomain {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FaultDomain); err != nil {
			return err
		}
	}
	// UpdateDomain {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.UpdateDomain); err != nil {
			return err
		}
	}
	// UseDomains {in} (1:{alias=BOOL}(int32))
	{
		if !o.UseDomains {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// Reserved {in} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// GroupSet {in} (1:{context_handle, alias=HGROUPSET_RPC, names=ndr_context_handle}(struct))
	{
		if o.GroupSet == nil {
			o.GroupSet = &GroupSet{}
		}
		if err := o.GroupSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Group {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// FaultDomain {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FaultDomain); err != nil {
			return err
		}
	}
	// UpdateDomain {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.UpdateDomain); err != nil {
			return err
		}
	}
	// UseDomains {in} (1:{alias=BOOL}(int32))
	{
		var _bUseDomains int32
		if err := w.ReadData(&_bUseDomains); err != nil {
			return err
		}
		o.UseDomains = _bUseDomains != 0
	}
	// Reserved {in} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		var _Reserved uint32
		if err := w.ReadData(&_Reserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddGroupToGroupSetExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddGroupToGroupSetExRequest structure represents the ApiAddGroupToGroupSetEx operation request
type AddGroupToGroupSetExRequest struct {
	GroupSet     *GroupSet `idl:"name:GroupSet" json:"group_set"`
	Group        *Group    `idl:"name:Group" json:"group"`
	FaultDomain  uint32    `idl:"name:FaultDomain" json:"fault_domain"`
	UpdateDomain uint32    `idl:"name:UpdateDomain" json:"update_domain"`
	UseDomains   bool      `idl:"name:UseDomains" json:"use_domains"`
}

func (o *AddGroupToGroupSetExRequest) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetExOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetExOperation{}
	}
	return &xxx_AddGroupToGroupSetExOperation{
		GroupSet:     o.GroupSet,
		Group:        o.Group,
		FaultDomain:  o.FaultDomain,
		UpdateDomain: o.UpdateDomain,
		UseDomains:   o.UseDomains,
	}
}

func (o *AddGroupToGroupSetExRequest) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetExOperation) {
	if o == nil {
		return
	}
	o.GroupSet = op.GroupSet
	o.Group = op.Group
	o.FaultDomain = op.FaultDomain
	o.UpdateDomain = op.UpdateDomain
	o.UseDomains = op.UseDomains
}
func (o *AddGroupToGroupSetExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *AddGroupToGroupSetExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddGroupToGroupSetExResponse structure represents the ApiAddGroupToGroupSetEx operation response
type AddGroupToGroupSetExResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiAddGroupToGroupSetEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddGroupToGroupSetExResponse) xxx_ToOp(ctx context.Context) *xxx_AddGroupToGroupSetExOperation {
	if o == nil {
		return &xxx_AddGroupToGroupSetExOperation{}
	}
	return &xxx_AddGroupToGroupSetExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *AddGroupToGroupSetExResponse) xxx_FromOp(ctx context.Context, op *xxx_AddGroupToGroupSetExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *AddGroupToGroupSetExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *AddGroupToGroupSetExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddGroupToGroupSetExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeResourceGroupExOperation structure represents the ApiChangeResourceGroupEx operation
type xxx_ChangeResourceGroupExOperation struct {
	Resource  *Resource `idl:"name:hResource" json:"resource"`
	Group     *Group    `idl:"name:hGroup" json:"group"`
	Flags     uint64    `idl:"name:flags" json:"flags"`
	RPCStatus uint32    `idl:"name:rpc_status" json:"rpc_status"`
	Return    uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeResourceGroupExOperation) OpNum() int { return 184 }

func (o *xxx_ChangeResourceGroupExOperation) OpName() string {
	return "/clusapi3/v3/ApiChangeResourceGroupEx"
}

func (o *xxx_ChangeResourceGroupExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource != nil {
			if err := o.Resource.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Resource{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Group{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// flags {in} (1:{alias=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hResource {in} (1:{context_handle, alias=HRES_RPC, names=ndr_context_handle}(struct))
	{
		if o.Resource == nil {
			o.Resource = &Resource{}
		}
		if err := o.Resource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// hGroup {in} (1:{context_handle, alias=HGROUP_RPC, names=ndr_context_handle}(struct))
	{
		if o.Group == nil {
			o.Group = &Group{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// flags {in} (1:{alias=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.WriteData(o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeResourceGroupExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// rpc_status {out} (1:{pointer=ref}*(1)(error_status_t))
	{
		if err := w.ReadData(&o.RPCStatus); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeResourceGroupExRequest structure represents the ApiChangeResourceGroupEx operation request
type ChangeResourceGroupExRequest struct {
	Resource *Resource `idl:"name:hResource" json:"resource"`
	Group    *Group    `idl:"name:hGroup" json:"group"`
	Flags    uint64    `idl:"name:flags" json:"flags"`
}

func (o *ChangeResourceGroupExRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeResourceGroupExOperation {
	if o == nil {
		return &xxx_ChangeResourceGroupExOperation{}
	}
	return &xxx_ChangeResourceGroupExOperation{
		Resource: o.Resource,
		Group:    o.Group,
		Flags:    o.Flags,
	}
}

func (o *ChangeResourceGroupExRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeResourceGroupExOperation) {
	if o == nil {
		return
	}
	o.Resource = op.Resource
	o.Group = op.Group
	o.Flags = op.Flags
}
func (o *ChangeResourceGroupExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeResourceGroupExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeResourceGroupExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeResourceGroupExResponse structure represents the ApiChangeResourceGroupEx operation response
type ChangeResourceGroupExResponse struct {
	RPCStatus uint32 `idl:"name:rpc_status" json:"rpc_status"`
	// Return: The ApiChangeResourceGroupEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeResourceGroupExResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeResourceGroupExOperation {
	if o == nil {
		return &xxx_ChangeResourceGroupExOperation{}
	}
	return &xxx_ChangeResourceGroupExOperation{
		RPCStatus: o.RPCStatus,
		Return:    o.Return,
	}
}

func (o *ChangeResourceGroupExResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeResourceGroupExOperation) {
	if o == nil {
		return
	}
	o.RPCStatus = op.RPCStatus
	o.Return = op.Return
}
func (o *ChangeResourceGroupExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeResourceGroupExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeResourceGroupExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
