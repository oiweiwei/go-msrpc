package svcctl

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcetypes "github.com/oiweiwei/go-msrpc/msrpc/dcetypes"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dcetypes.GoPackage
	_ = dtyp.GoPackage
)

var (
	// import guard
	GoPackage = "scmr"
)

var (
	// Syntax UUID
	SvcctlSyntaxUUID = &uuid.UUID{TimeLow: 0x367abb81, TimeMid: 0x9844, TimeHiAndVersion: 0x35f1, ClockSeqHiAndReserved: 0xad, ClockSeqLow: 0x32, Node: [6]uint8{0x98, 0xf0, 0x38, 0x0, 0x10, 0x3}}
	// Syntax ID
	SvcctlSyntaxV2_0 = &dcerpc.SyntaxID{IfUUID: SvcctlSyntaxUUID, IfVersionMajor: 2, IfVersionMinor: 0}
)

// svcctl interface.
type SvcctlClient interface {

	// The RCloseServiceHandle method is called by the client. In response, the server releases
	// the handle to the specified service or the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns the following error code.
	//
	//	+------------------------+----------------------------------------------------------------------------------+
	//	|         RETURN         |                                                                                  |
	//	|       VALUE/CODE       |                                   DESCRIPTION                                    |
	//	|                        |                                                                                  |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE | The handle is no longer valid.                                                   |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| 0xFFFF75FD             | The operation completed successfully. Additionally, the passed handle was the    |
	//	|                        | last one created for the associated service record that was previously used in a |
	//	|                        | successful call to the RNotifyServiceStatusChange (section 3.1.4.43) method.     |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| 0xFFFF75FE             | The operation completed successfully. Additionally, the passed handle was        |
	//	|                        | previously used in a successful call to the RNotifyServiceStatusChange method.   |
	//	+------------------------+----------------------------------------------------------------------------------+
	CloseService(context.Context, *CloseServiceRequest, ...dcerpc.CallOption) (*CloseServiceResponse, error)

	// The RControlService method receives a control code for a specific service handle,
	// as specified by the client.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                 | The required access right had not been granted to the caller when the RPC        |
	//	|                                       | context handle to the service record was created.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1051 ERROR_DEPENDENT_SERVICES_RUNNING | The service cannot be stopped because other running services are dependent on    |
	//	|                                       | it.                                                                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                | The handle is no longer valid.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER            | The requested control code is undefined                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1052 ERROR_INVALID_SERVICE_CONTROL    | The requested control code is not valid, or it is unacceptable to the service.   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1053 ERROR_SERVICE_REQUEST_TIMEOUT    | The process for the service was started, but it did not respond within an        |
	//	|                                       | implementation-specific time-out.<35>                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1061 ERROR_SERVICE_CANNOT_ACCEPT_CTRL | The requested control code cannot be sent to the service because the             |
	//	|                                       | ServiceStatus.dwCurrentState in the service record is SERVICE_START_PENDING or   |
	//	|                                       | SERVICE_STOP_PENDING.                                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1062 ERROR_SERVICE_NOT_ACTIVE         | The service has not been started, or the ServiceStatus.dwCurrentState in the     |
	//	|                                       | service record is SERVICE_STOPPED.                                               |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS       | The system is shutting down.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	ControlService(context.Context, *ControlServiceRequest, ...dcerpc.CallOption) (*ControlServiceResponse, error)

	// The RDeleteService method marks the specified service for deletion from the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The DELETE access right had not been granted to the caller when the RPC context  |
	//	|                                      | handle to the service record was created.                                        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle is no longer valid.                                                   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The RDeleteService has already been called for the service record identified by  |
	//	|                                      | the hService parameter.                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	DeleteService(context.Context, *DeleteServiceRequest, ...dcerpc.CallOption) (*DeleteServiceResponse, error)

	// The RLockServiceDatabase method acquires a lock on an SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED              | The SC_MANAGER_LOCK access rights had not been granted to the caller when the    |
	//	|                                    | RPC context handle was created.                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE             | The handle is no longer valid.                                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1055 ERROR_SERVICE_DATABASE_LOCKED | The service database is locked.                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	LockServiceDatabase(context.Context, *LockServiceDatabaseRequest, ...dcerpc.CallOption) (*LockServiceDatabaseResponse, error)

	// The RQueryServiceObjectSecurity method returns a copy of the SECURITY_DESCRIPTOR
	// structure associated with a service object.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|            RETURN             |                                                                                  |
	//	|          VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED         | The required access rights had not been granted to the caller when the RPC       |
	//	|                               | context handle was created.                                                      |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE        | The handle is no longer valid.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER    | A parameter that was specified is invalid.                                       |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER | The data area passed to a system call is too small.                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//
	// The client MAY provide a combination of one or more SECURITY_INFORMATION bit flags
	// for dwSecurityInformation.
	//
	// If SACL_SECURITY_INFORMATION is specified for the dwSecurityInformation parameter,
	// then an ACCESS_SYSTEM_SECURITY right MUST have been granted to the caller when hService
	// was created. (See AS in ACCESS_MASK in [MS-DTYP] 2.4.3.)
	//
	// If DACL_SECURITY_INFORMATION, LABEL_SECURITY_INFORMATION, OWNER_SECURITY_INFORMATION,
	// or GROUP_SECURITY_INFORMATION is specified for the dwSecurityInformation parameter,
	// then a READ_CONTROL right MUST have been granted to the caller when hService was
	// created. (See RC in ACCESS_MASK in [MS-DTYP] 2.4.3.)
	QueryServiceObjectSecurity(context.Context, *QueryServiceObjectSecurityRequest, ...dcerpc.CallOption) (*QueryServiceObjectSecurityResponse, error)

	// The RSetServiceObjectSecurity method sets the SECURITY_DESCRIPTOR structure associated
	// with a service object.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The required access rights had not been granted to the caller when the RPC       |
	//	|                                      | context handle was created.                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle is no longer valid.                                                   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The RDeleteService method has been called with an RPC context handle identifying |
	//	|                                      | the same service record as the hService parameter for this call.                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// The client MAY provide a combination of one or more SECURITY_INFORMATION bit flags
	// for dwSecurityInformation.
	//
	// If SACL_SECURITY_INFORMATION is specified via dwSecurityInformation, then an ACCESS_SYSTEM_SECURITY
	// right MUSThave been granted to the caller when hService was created. (See WD in ACCESS_MASK
	// in [MS-DTYP] 2.4.3.
	//
	// If LABEL_SECURITY_INFORMATION or OWNER_SECURITY_INFORMATION or GROUP_SECURITY_INFORMATION
	// is specified via dwSecurityInformation, then a WRITE_OWNER right MUST have been granted
	// to the caller when hService was created. (See WO in ACCESS_MASK in [MS-DTYP] 2.4.3.)
	//
	// If DACL_SECURITY_INFORMATION is specified via dwSecurityInformation, then a WRITE_DAC
	// right MUST have been granted to the caller when hService was created. (See WD in
	// ACCESS_MASK in [MS-DTYP] 2.4.3.)
	SetServiceObjectSecurity(context.Context, *SetServiceObjectSecurityRequest, ...dcerpc.CallOption) (*SetServiceObjectSecurityResponse, error)

	// The RQueryServiceStatus method returns the current status of the specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_STATUS access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle was created.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 3 ERROR_PATH_NOT_FOUND          | The ImagePath of the service record identified by the hService parameter does    |
	//	|                                 | not exist.                                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// If the type of the service record is SERVICE_KERNEL_DRIVER or SERVICE_FILESYSTEM_DRIVER,
	// the SCM queries the current status of the driver from the operating system and set
	// the ServiceStatus.dwCurrentState of the service record to SERVICE_RUNNING if driver
	// is loaded and to SERVICE_STOPPED if it is not.
	QueryServiceStatus(context.Context, *QueryServiceStatusRequest, ...dcerpc.CallOption) (*QueryServiceStatusResponse, error)

	// The RSetServiceStatus method updates the SCM status information for the calling service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------+----------------------------------------------------------------------------------+
	//	|         RETURN         |                                                                                  |
	//	|       VALUE/CODE       |                                   DESCRIPTION                                    |
	//	|                        |                                                                                  |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE | Either the handle is no longer valid or the SERVICE_SET_STATUS access rights had |
	//	|                        | not been granted to the caller when the RPC context handle was created.          |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA  | The data provided in the lpServiceStatus parameter is invalid.                   |
	//	+------------------------+----------------------------------------------------------------------------------+
	SetServiceStatus(context.Context, *SetServiceStatusRequest, ...dcerpc.CallOption) (*SetServiceStatusResponse, error)

	// The RUnlockServiceDatabase method releases a lock on a service database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns the following error code.
	//
	//	+---------------------------------+----------------------------------------------+
	//	|             RETURN              |                                              |
	//	|           VALUE/CODE            |                 DESCRIPTION                  |
	//	|                                 |                                              |
	//	+---------------------------------+----------------------------------------------+
	//	+---------------------------------+----------------------------------------------+
	//	| 1071 ERROR_INVALID_SERVICE_LOCK | The specified RPC context handle is invalid. |
	//	+---------------------------------+----------------------------------------------+
	UnlockServiceDatabase(context.Context, *UnlockServiceDatabaseRequest, ...dcerpc.CallOption) (*UnlockServiceDatabaseResponse, error)

	// The RNotifyBootConfigStatus method reports the boot status to the SCM.
	//
	// Return Values: The method returns ERROR_SUCCESS (0x00000000) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN              |                                                                                  |
	//	|            VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                  |                                                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED            | The caller does not have the SC_MANAGER_MODIFY_BOOT_CONFIG access rights granted |
	//	|                                  | in the SCM Security Descriptor.                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| 1074 ERROR_ALREADY_RUNNING_LKG   | The system is currently running with the last-known-good configuration.          |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| 1076 ERROR_BOOT_ALREADY_ACCEPTED | The BootAccepted field of the SCM on the target machine indicated that a         |
	//	|                                  | successful call to RNotifyBootConfigStatus has already been made.                |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	NotifyBootConfigStatus(context.Context, *NotifyBootConfigStatusRequest, ...dcerpc.CallOption) (*NotifyBootConfigStatusResponse, error)

	// Opnum10NotUsedOnWire operation.
	// Opnum10NotUsedOnWire

	// The RChangeServiceConfigW method changes a service's configuration parameters in
	// the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SERVICE_CHANGE_CONFIG access right had not been granted to the caller when   |
	//	|                                      | the RPC context handle to the service record was created.                        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The lpDisplayName matches either the ServiceName or the DisplayName of another   |
	//	|                                      | service record in the service control manager database.                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The RDeleteService has been called for the service record identified by the      |
	//	|                                      | hService parameter.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	ChangeServiceConfigW(context.Context, *ChangeServiceConfigWRequest, ...dcerpc.CallOption) (*ChangeServiceConfigWResponse, error)

	// The RCreateServiceW method creates the service record in the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SC_MANAGER_CREATE_SERVICE access right had not been granted to the caller    |
	//	|                                      | when the RPC context handle was created.                                         |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA                | The data is invalid.                                                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME               | The specified service name is invalid.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The service record with a specified name already exists and RDeleteService has   |
	//	|                                      | been called for it.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1073 ERROR_SERVICE_EXISTS            | The service record with the ServiceName matching the specified lpServiceName     |
	//	|                                      | already exists.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The service record with the same DisplayName or the same ServiceName as the      |
	//	|                                      | passed in lpDisplayName already exists in the service control manager database.  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	CreateServiceW(context.Context, *CreateServiceWRequest, ...dcerpc.CallOption) (*CreateServiceWResponse, error)

	// The REnumDependentServicesW method returns the ServiceName, DisplayName, and ServiceStatus
	// values of service records that are listed as dependents of a specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_ENUMERATE_DEPENDENT access right had not been granted to the caller  |
	//	|                                 | when the RPC context handle to the service record was created.                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER      | A parameter that was specified is invalid.                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA             | More data is available.                                                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	EnumDependentServicesW(context.Context, *EnumDependentServicesWRequest, ...dcerpc.CallOption) (*EnumDependentServicesWResponse, error)

	// The REnumServicesStatusW method enumerates service records in the specified SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	|           RETURN           |                                                                                  |
	//	|         VALUE/CODE         |                                   DESCRIPTION                                    |
	//	|                            |                                                                                  |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED      | The SM_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                            | when the RPC context handle to the service record was created.                   |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE     | The handle is no longer valid.                                                   |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER | A parameter that was specified is invalid.                                       |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA        | More data is available.                                                          |
	//	+----------------------------+----------------------------------------------------------------------------------+
	EnumServicesStatusW(context.Context, *EnumServicesStatusWRequest, ...dcerpc.CallOption) (*EnumServicesStatusWResponse, error)

	// The ROpenSCManagerW method establishes a connection to server and opens the SCM database
	// on the specified server.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED              | The client does not have the required access rights to open the SCM              |
	//	|                                    | database on the server or the desired access is not granted to it in the SCM     |
	//	|                                    | SecurityDescriptor.                                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME             | The specified service name is invalid.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1065 ERROR_DATABASE_DOES_NOT_EXIST | The database specified does not exist.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS    | The system is shutting down.                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	OpenSCMW(context.Context, *OpenSCMWRequest, ...dcerpc.CallOption) (*OpenSCMWResponse, error)

	// The ROpenServiceW method creates an RPC context handle to an existing service record.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED             | The access specified by the dwDesiredAccess parameter cannot be granted to the   |
	//	|                                   | caller.                                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE            | The handle is no longer valid.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The specified service name is invalid.                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with a specified DisplayName does not exist in the SCM        |
	//	|                                   | database.                                                                        |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS   | The system is shutting down.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	OpenServiceW(context.Context, *OpenServiceWRequest, ...dcerpc.CallOption) (*OpenServiceWResponse, error)

	// The RQueryServiceConfigW method returns the configuration parameters of the specified
	// service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_CONFIG access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle was created.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER   | The data area passed to a system call is too small.                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	QueryServiceConfigW(context.Context, *QueryServiceConfigWRequest, ...dcerpc.CallOption) (*QueryServiceConfigWResponse, error)

	// The RQueryServiceLockStatusW method returns the lock status of the specified SCM
	// database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|            RETURN             |                                                                                  |
	//	|          VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED         | The SC_MANAGER_QUERY_LOCK_STATUS access right had not been granted to the caller |
	//	|                               | when the RPC context handle was created.                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE        | The handle is no longer valid.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER | The data area passed to a system call is too small.                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	QueryServiceLockStatusW(context.Context, *QueryServiceLockStatusWRequest, ...dcerpc.CallOption) (*QueryServiceLockStatusWResponse, error)

	// The RStartServiceW method starts a specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.<41>
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 2 ERROR_FILE_NOT_FOUND                | The system cannot find the file specified.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 3 ERROR_PATH_NOT_FOUND                | The system cannot find the path specified.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                 | The SERVICE_START access right had not been granted to the caller when the RPC   |
	//	|                                       | context handle to the service record was created.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                | The handle is no longer valid.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER            | A parameter that was specified is invalid.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1053 ERROR_SERVICE_REQUEST_TIMEOUT    | The process for the service was started, but it did not respond within an        |
	//	|                                       | implementation-specific time-out.<42>                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1054 ERROR_SERVICE_NO_THREAD          | A thread could not be created for the service.                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1055 ERROR_SERVICE_DATABASE_LOCKED    | The service database is locked by the call to the BlockServiceDatabase           |
	//	|                                       | method.<43>                                                                      |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1056 ERROR_SERVICE_ALREADY_RUNNING    | The ServiceStatus.dwCurrentState in the service record is not set to             |
	//	|                                       | SERVICE_STOPPED.                                                                 |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1058 ERROR_SERVICE_DISABLED           | The service cannot be started because the Start field in the service record is   |
	//	|                                       | set to SERVICE_DISABLED.                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1068 ERROR_SERVICE_DEPENDENCY_FAIL    | The specified service depends on another service that has failed to start.       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1069 ERROR_SERVICE_LOGON_FAILED       | The service did not start due to a logon failure.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE  | The RDeleteService method has been called for the service record identified by   |
	//	|                                       | the hService parameter.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1075 ERROR_SERVICE_DEPENDENCY_DELETED | The specified service depends on a service that does not exist or has been       |
	//	|                                       | marked for deletion.                                                             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS       | The system is shutting down.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	StartServiceW(context.Context, *StartServiceWRequest, ...dcerpc.CallOption) (*StartServiceWResponse, error)

	// The RGetServiceDisplayNameW method returns the display name of the specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER     | The display name does not fit in the buffer.                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The specified service name is invalid.                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with the specified ServiceName does not exist in the SCM      |
	//	|                                   | database identified by the hSCManager parameter.                                 |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	GetServiceDisplayNameW(context.Context, *GetServiceDisplayNameWRequest, ...dcerpc.CallOption) (*GetServiceDisplayNameWResponse, error)

	// The RGetServiceKeyNameW method returns the ServiceName of the service record with
	// the specified DisplayName.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The name specified in the lpDisplayName parameter is invalid or set to NULL.     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with the DisplayName matching the value specified in the      |
	//	|                                   | lpDisplayName parameter does not exist in the SCM database identified by the     |
	//	|                                   | hSCManager parameter.                                                            |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	GetServiceKeyNameW(context.Context, *GetServiceKeyNameWRequest, ...dcerpc.CallOption) (*GetServiceKeyNameWResponse, error)

	// Opnum22NotUsedOnWire operation.
	// Opnum22NotUsedOnWire

	// The RChangeServiceConfigA method changes a service's configuration parameters in
	// the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SERVICE_CHANGE_CONFIG access right had not been granted to the caller when   |
	//	|                                      | the RPC context handle to the service record was created.                        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The lpDisplayName matches either the ServiceName or the DisplayName of another   |
	//	|                                      | service record in the service control manager database.                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The RDeleteService has been called for the service record identified by the      |
	//	|                                      | hService parameter.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	ChangeServiceConfigA(context.Context, *ChangeServiceConfigARequest, ...dcerpc.CallOption) (*ChangeServiceConfigAResponse, error)

	// The RCreateServiceA method creates the service record in the SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SC_MANAGER_CREATE_SERVICE access right had not been granted to the caller    |
	//	|                                      | when the RPC context handle was created.                                         |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA                | The data is invalid.                                                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME               | The specified service name is invalid.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The service record with a specified name already exists, and RDeleteService has  |
	//	|                                      | been called for it.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1073 ERROR_SERVICE_EXISTS            | The service record with the ServiceName matching the specified lpServiceName     |
	//	|                                      | already exists.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The service record with the same DisplayName or the same ServiceName as the      |
	//	|                                      | passed-in lpDisplayName already exists in the service control manager database.  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	CreateServiceA(context.Context, *CreateServiceARequest, ...dcerpc.CallOption) (*CreateServiceAResponse, error)

	// The REnumDependentServicesA method returns the ServiceName, DisplayName, and ServiceStatus
	// of each service record that depends on the specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_ENUMERATE_DEPENDENT access right had not been granted to the caller  |
	//	|                                 | when the RPC context handle to the service record was created.                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER      | A parameter that was specified is invalid.                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA             | More data is available.                                                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	EnumDependentServicesA(context.Context, *EnumDependentServicesARequest, ...dcerpc.CallOption) (*EnumDependentServicesAResponse, error)

	// The REnumServicesStatusA method enumerates service records in the specified SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	|           RETURN           |                                                                                  |
	//	|         VALUE/CODE         |                                   DESCRIPTION                                    |
	//	|                            |                                                                                  |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED      | The SC_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                            | when the RPC context handle to the service record was created.                   |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE     | The handle is no longer valid.                                                   |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER | A parameter that was specified is invalid.                                       |
	//	+----------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA        | More data is available.                                                          |
	//	+----------------------------+----------------------------------------------------------------------------------+
	EnumServicesStatusA(context.Context, *EnumServicesStatusARequest, ...dcerpc.CallOption) (*EnumServicesStatusAResponse, error)

	// The ROpenSCManagerA method opens a connection to the SCM from the client and then
	// opens the specified SCM database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED              | The SC_MANAGER_CONNECT access right or the desired access is not granted to the  |
	//	|                                    | caller in the SCM SecurityDescriptor.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME             | The specified service name is invalid.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1065 ERROR_DATABASE_DOES_NOT_EXIST | The database specified does not exist.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS    | The system is shutting down.                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	OpenSCMA(context.Context, *OpenSCMARequest, ...dcerpc.CallOption) (*OpenSCMAResponse, error)

	// The ROpenServiceA method creates an RPC context handle to an existing service record.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED             | The access specified by the dwDesiredAccess parameter cannot be granted to the   |
	//	|                                   | caller.                                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE            | The handle is no longer valid.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The specified service name is invalid.                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with a specified DisplayName does not exist in the SCM        |
	//	|                                   | database.                                                                        |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS   | The system is shutting down.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	OpenServiceA(context.Context, *OpenServiceARequest, ...dcerpc.CallOption) (*OpenServiceAResponse, error)

	// The RQueryServiceConfigA method returns the configuration parameters of the specified
	// service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_CONFIG access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle was created.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER   | The data area passed to a system call is too small.                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	QueryServiceConfigA(context.Context, *QueryServiceConfigARequest, ...dcerpc.CallOption) (*QueryServiceConfigAResponse, error)

	// The RQueryServiceLockStatusA method returns the lock status of the specified SCM
	// database.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|            RETURN             |                                                                                  |
	//	|          VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED         | The SC_MANAGER_QUERY_LOCK_STATUS access right had not been granted to the caller |
	//	|                               | when the RPC context handle was created.                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE        | The handle is no longer valid.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER | The data area passed to a system call is too small.                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	QueryServiceLockStatusA(context.Context, *QueryServiceLockStatusARequest, ...dcerpc.CallOption) (*QueryServiceLockStatusAResponse, error)

	// The RStartServiceA method starts a specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.<46>
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 2 ERROR_FILE_NOT_FOUND                | The system cannot find the file specified.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 3 ERROR_PATH_NOT_FOUND                | The system cannot find the path specified.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                 | The SERVICE_START access right had not been granted to the caller when the RPC   |
	//	|                                       | context handle to the service was created.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                | The handle is no longer valid.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER            | A parameter that was specified is invalid.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1053 ERROR_SERVICE_REQUEST_TIMEOUT    | The process for the service was started, but it did not respond within an        |
	//	|                                       | implementation-specific time-out.<47>                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1054 ERROR_SERVICE_NO_THREAD          | A thread could not be created for the service.                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1055 ERROR_SERVICE_DATABASE_LOCKED    | The service database is locked by the call to the RLockServiceDatabase (section  |
	//	|                                       | 3.1.4.4) method.<48>                                                             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1056 ERROR_SERVICE_ALREADY_RUNNING    | The ServiceStatus.dwCurrentState in the service record is not set to             |
	//	|                                       | SERVICE_STOPPED.                                                                 |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1058 ERROR_SERVICE_DISABLED           | The service cannot be started because the Start field in the service record is   |
	//	|                                       | set to SERVICE_DISABLED.                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1068 ERROR_SERVICE_DEPENDENCY_FAIL    | The specified service depends on another service that has failed to start.       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1069 ERROR_SERVICE_LOGON_FAILED       | The service did not start due to a logon failure.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE  | The RDeleteService method has been called for the service record identified by   |
	//	|                                       | the hService parameter.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1075 ERROR_SERVICE_DEPENDENCY_DELETED | The specified service depends on a service that does not exist or has been       |
	//	|                                       | marked for deletion.                                                             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS       | The system is shutting down.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	StartServiceA(context.Context, *StartServiceARequest, ...dcerpc.CallOption) (*StartServiceAResponse, error)

	// The RGetServiceDisplayNameA method returns the display name of the specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER     | The display name does not fit in the buffer.                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The specified service name is invalid.                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with the specified ServiceName does not exist in the SCM      |
	//	|                                   | database identified by the hSCManager parameter.                                 |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	GetServiceDisplayNameA(context.Context, *GetServiceDisplayNameARequest, ...dcerpc.CallOption) (*GetServiceDisplayNameAResponse, error)

	// The RGetServiceKeyNameA method returns the ServiceName of the service record with
	// the specified DisplayName.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER     | The data area passed to a system call is too small.                              |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME            | The name specified in lpDisplayName is invalid or set to NULL.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The service record with the DisplayName matching the specified lpDisplayName     |
	//	|                                   | does not exist in the SCM database identified by the hSCManager parameter.       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	GetServiceKeyNameA(context.Context, *GetServiceKeyNameARequest, ...dcerpc.CallOption) (*GetServiceKeyNameAResponse, error)

	// Opnum34NotUsedOnWire operation.
	// Opnum34NotUsedOnWire

	// The REnumServiceGroupW method returns the members of a service group.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED             | The SC_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                                   | when the RPC context handle was created.                                         |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE            | The handle is no longer valid.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER        | A parameter that was specified is invalid.                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA               | More data is available.                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The group specified by pszGroupName does not exist in the SCM GroupList.         |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS   | The system is shutting down.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	EnumServiceGroupW(context.Context, *EnumServiceGroupWRequest, ...dcerpc.CallOption) (*EnumServiceGroupWResponse, error)

	// The RChangeServiceConfig2A method SHOULD<51> change the optional configuration parameters
	// of a service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise
	// it returns one of the following error codes.<52>
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                   | The SERVICE_CHANGE_CONFIG access right had not been granted to the caller when   |
	//	|                                         | the RPC context handle to the service record was created.                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                  | The handle is no longer valid.                                                   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER              | A parameter that was specified is invalid.                                       |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE    | The RDeleteService has been called for the service record identified by the      |
	//	|                                         | hService parameter.                                                              |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1080 ERROR_CANNOT_DETECT_DRIVER_FAILURE | SERVICE_CONFIG_FAILURE_ACTIONS cannot be used as a dwInfoLevel in the Info       |
	//	|                                         | parameter for service records with a Type value defined for drivers.             |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS         | The system is shutting down.                                                     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	ChangeServiceConfig2A(context.Context, *ChangeServiceConfig2ARequest, ...dcerpc.CallOption) (*ChangeServiceConfig2AResponse, error)

	// The RChangeServiceConfig2W <53> method changes the optional configuration parameters
	// of a service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise
	// it returns one of the following error codes.<54>
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                   | The SERVICE_CHANGE_CONFIG access right had not been granted to the caller when   |
	//	|                                         | the RPC context handle to the service record was created.                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                  | The handle is no longer valid.                                                   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER              | A parameter that was specified is invalid.                                       |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE    | The RDeleteService has been called for the service record identified by the      |
	//	|                                         | hService parameter.                                                              |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1080 ERROR_CANNOT_DETECT_DRIVER_FAILURE | SERVICE_CONFIG_FAILURE_ACTIONS cannot be used as a dwInfoLevel in the Info       |
	//	|                                         | parameter for service records with a Type value defined for drivers.             |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS         | The system is shutting down.                                                     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	ChangeServiceConfig2W(context.Context, *ChangeServiceConfig2WRequest, ...dcerpc.CallOption) (*ChangeServiceConfig2WResponse, error)

	// The RQueryServiceConfig2A <55> method returns the optional configuration parameters
	// of the specified service based on the specified information level.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_CONFIG access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle to the service record was created.                        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER      | A parameter that was specified is invalid.                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER   | The data area passed to a system call is too small.                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL         | The dwInfoLevel parameter contains an unsupported value.                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	QueryServiceConfig2A(context.Context, *QueryServiceConfig2ARequest, ...dcerpc.CallOption) (*QueryServiceConfig2AResponse, error)

	// The RQueryServiceConfig2W <64> method returns the optional configuration parameters
	// of the specified service based on the specified information level.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED        | The SERVICE_QUERY_CONFIG access right had not been granted to the caller when    |
	//	|                                       | the RPC context handle to the service record was created.                        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE       | The handle is no longer valid.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000087 ERROR_INVALID_PARAMETER    | A parameter that was specified is invalid.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000122 ERROR_INSUFFICIENT_BUFFER  | The data area passed to a system call is too small.                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000124 ERROR_INVALID_LEVEL        | The dwInfoLevel parameter contains an unsupported value.                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	QueryServiceConfig2W(context.Context, *QueryServiceConfig2WRequest, ...dcerpc.CallOption) (*QueryServiceConfig2WResponse, error)

	// The RQueryServiceStatusEx method returns the current status of the specified service,
	// based on the specified information level.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_STATUS access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle to the service record was created.                        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER      | A parameter that was specified is invalid.                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 122 ERROR_INSUFFICIENT_BUFFER   | The data area passed to a system call is too small.                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL         | The InfoLevel parameter contains an unsupported value.                           |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	QueryServiceStatusEx(context.Context, *QueryServiceStatusExRequest, ...dcerpc.CallOption) (*QueryServiceStatusExResponse, error)

	// The REnumServicesStatusExA method enumerates services in the specified SCM database,
	// based on the specified information level.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED             | The SC_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                                   | when the RPC context handle to the SCM was created.                              |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE            | The handle is no longer valid.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER        | A parameter that was specified is invalid.                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL           | The InfoLevel parameter contains an unsupported value.                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA               | More data is available.                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The group specified by the pszGroupName parameter does not exist in the SCM      |
	//	|                                   | GroupList.                                                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS   | The system is shutting down.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	EnumServicesStatusExA(context.Context, *EnumServicesStatusExARequest, ...dcerpc.CallOption) (*EnumServicesStatusExAResponse, error)

	// The REnumServicesStatusExW method enumerates services in the specified SCM database,
	// based on the specified information level.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) (ERROR_SUCCESS) on success;
	// otherwise, it returns one of the following error codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED             | The SC_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                                   | when the RPC context handle to the SCM was created.                              |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE            | The handle is no longer valid.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER        | A parameter that was specified is invalid.                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL           | The InfoLevel parameter contains an unsupported value.                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 234 ERROR_MORE_DATA               | More data is available.                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1060 ERROR_SERVICE_DOES_NOT_EXIST | The group specified by the pszGroupName parameter does not exist in the SCM      |
	//	|                                   | GroupList.                                                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS   | The system is shutting down.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	EnumServicesStatusExW(context.Context, *EnumServicesStatusExWRequest, ...dcerpc.CallOption) (*EnumServicesStatusExWResponse, error)

	// Opnum43NotUsedOnWire operation.
	// Opnum43NotUsedOnWire

	// The RCreateServiceWOW64A method creates the service record for a 32-bit service on
	// a 64-bit system with the path to the file image automatically adjusted to point to
	// a 32-bit file location on the system.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SC_MANAGER_CREATE_SERVICE access right had not been granted to the caller    |
	//	|                                      | when the RPC context handle to the SCM was created.                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA                | The data is invalid.                                                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME               | The specified service name is invalid.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The service record with a specified name already exists and RDeleteService has   |
	//	|                                      | been called for it.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1073 ERROR_SERVICE_EXISTS            | The service record with the ServiceName matching the specified lpServiceName     |
	//	|                                      | already exists.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The service record with the same DisplayName or the same ServiceName as the      |
	//	|                                      | passed-in lpDisplayName already exists in the SCM database.                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	CreateServiceWOW64A(context.Context, *CreateServiceWOW64ARequest, ...dcerpc.CallOption) (*CreateServiceWOW64AResponse, error)

	// The RCreateServiceWOW64W method creates the service record for a 32-bit service on
	// a 64-bit system with the path to the file image automatically adjusted to point to
	// a 32-bit file location on the system.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SC_MANAGER_CREATE_SERVICE access right had not been granted to the caller    |
	//	|                                      | when the RPC context handle to the SCM was created.                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA                | The data is invalid.                                                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME               | The specified service name is invalid.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The service record with a specified name already exists, and RDeleteService has  |
	//	|                                      | been called for it.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1073 ERROR_SERVICE_EXISTS            | The service record with the ServiceName matching the specified lpServiceName     |
	//	|                                      | already exists.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The service record with the same DisplayName or the same ServiceName as the      |
	//	|                                      | passed-in lpDisplayName already exists in the service control manager database.  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	CreateServiceWOW64W(context.Context, *CreateServiceWOW64WRequest, ...dcerpc.CallOption) (*CreateServiceWOW64WResponse, error)

	// Opnum46NotUsedOnWire operation.
	// Opnum46NotUsedOnWire

	// The RNotifyServiceStatusChange method<74> allows the client to register for notifications
	// and check, via RGetNotifyResults (section 3.1.4.44), when the specified service of
	// type SERVICE_WIN32_OWN_PROCESS or SERVICE_WIN32_SHARE_PROCESS is created or deleted
	// or when its status changes.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                    | The SC_MANAGER_ENUMERATE_SERVICE access right had not been granted to the caller |
	//	|                                          | when the RPC context handle to the SCM was created, or the SERVICE_QUERY_STATUS  |
	//	|                                          | access right had not been granted to the caller when the RPC context handle to   |
	//	|                                          | the service record was created.                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                   | The handle is no longer valid or is not supported for the specified              |
	//	|                                          | notification.                                                                    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 50 ERROR_NOT_SUPPORTED                   | The request is not supported.                                                    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER               | A parameter that was specified is invalid.                                       |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL                  | The system call level is not correct.                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE     | The RDeleteService has been called for the service record identified by the      |
	//	|                                          | hService parameter.                                                              |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS          | The system is shutting down.                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 1242 ERROR_ALREADY_REGISTERED            | A notification status handle has already been created for the service handle     |
	//	|                                          | passed in the hService parameter.                                                |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 1294 ERROR_SERVICE_NOTIFY_CLIENT_LAGGING | The service notification client is lagging too far behind the current state of   |
	//	|                                          | services in the machine.                                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	NotifyServiceStatusChange(context.Context, *NotifyServiceStatusChangeRequest, ...dcerpc.CallOption) (*NotifyServiceStatusChangeResponse, error)

	// The RGetNotifyResults method<75> returns notification information when the specified
	// status change that was previously requested by the client via RNotifyServiceStatusChange
	// (section 3.1.4.43) occurs on a specified service.
	//
	// The client MUST make one call to RGetNotifyResults for each call to RNotifyServiceStatusChange.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+--------------------------------+
	//	|             RETURN              |                                |
	//	|           VALUE/CODE            |          DESCRIPTION           |
	//	|                                 |                                |
	//	+---------------------------------+--------------------------------+
	//	+---------------------------------+--------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid. |
	//	+---------------------------------+--------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.   |
	//	+---------------------------------+--------------------------------+
	//	| 1235 ERROR_REQUEST_ABORTED      | The request was aborted.       |
	//	+---------------------------------+--------------------------------+
	GetNotifyResults(context.Context, *GetNotifyResultsRequest, ...dcerpc.CallOption) (*GetNotifyResultsResponse, error)

	// The RCloseNotifyHandle method<77> unregisters the client from receiving future notifications
	// via the RGetNotifyResults (section 3.1.4.44) method from the server for specified
	// status changes on a specified service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns the following error code.
	//
	//	+------------------------+--------------------------------+
	//	|         RETURN         |                                |
	//	|       VALUE/CODE       |          DESCRIPTION           |
	//	|                        |                                |
	//	+------------------------+--------------------------------+
	//	+------------------------+--------------------------------+
	//	| 6 ERROR_INVALID_HANDLE | The handle is no longer valid. |
	//	+------------------------+--------------------------------+
	CloseNotify(context.Context, *CloseNotifyRequest, ...dcerpc.CallOption) (*CloseNotifyResponse, error)

	// The RControlServiceExA method<78> receives a control code for a specific service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                 | The required access right had not been granted to the caller when the RPC        |
	//	|                                       | context handle to the service record was created.                                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE                | The handle is no longer valid.                                                   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER            | The requested control code is undefined.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL               | The dwInfoLevel parameter contains an unsupported value.                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1051 ERROR_DEPENDENT_SERVICES_RUNNING | The service cannot be stopped because other running services are dependent on    |
	//	|                                       | it.                                                                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1052 ERROR_INVALID_SERVICE_CONTROL    | The requested control code is not valid, or it is unacceptable to the service.   |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1053 ERROR_SERVICE_REQUEST_TIMEOUT    | The process for the service was started, but it did not respond within an        |
	//	|                                       | implementation-specific time-out.<79>                                            |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1061 ERROR_SERVICE_CANNOT_ACCEPT_CTRL | The requested control code cannot be sent to the service because the state of    |
	//	|                                       | the service is SERVICE_START_PENDING or SERVICE_STOP_PENDING.                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1062 ERROR_SERVICE_NOT_ACTIVE         | The service has not been started, or the ServiceStatus.dwCurrentState in the     |
	//	|                                       | service record is SERVICE_STOPPED.                                               |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS       | The system is shutting down.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	ControlServiceExA(context.Context, *ControlServiceExARequest, ...dcerpc.CallOption) (*ControlServiceExAResponse, error)

	// The RControlServiceExW method<80> receives a control code for a specific service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	|                   RETURN                    |                                                                                  |
	//	|                 VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                             |                                                                                  |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED              | The required access right had not been granted to the caller when the RPC        |
	//	|                                             | context handle to the service record was created.                                |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000006 ERROR_INVALID_HANDLE             | The handle is no longer valid.                                                   |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000087 ERROR_INVALID_PARAMETER          | The requested control code is undefined.                                         |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000124 ERROR_INVALID_LEVEL              | The dwInfoLevel parameter contains an unsupported level.                         |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001051 ERROR_DEPENDENT_SERVICES_RUNNING | The service cannot be stopped because other running services are dependent on    |
	//	|                                             | it.                                                                              |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001052 ERROR_INVALID_SERVICE_CONTROL    | The requested control code is not valid, or it is unacceptable to the service.   |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001053 ERROR_SERVICE_REQUEST_TIMEOUT    | The process for the service was started, but it did not respond within an        |
	//	|                                             | implementation-specific timeout.<81>                                             |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001061 ERROR_SERVICE_CANNOT_ACCEPT_CTRL | The requested control code cannot be sent to the service because the state of    |
	//	|                                             | the service is SERVICE_START_PENDING or SERVICE_STOP_PENDING.                    |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00001062 ERROR_SERVICE_NOT_ACTIVE         | The service has not been started, or the ServiceStatus.dwCurrentState in the     |
	//	|                                             | service record is SERVICE_STOPPED.                                               |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS             | The system is shutting down.                                                     |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	ControlServiceExW(context.Context, *ControlServiceExWRequest, ...dcerpc.CallOption) (*ControlServiceExWResponse, error)

	// Opnum52NotUsedOnWire operation.
	// Opnum52NotUsedOnWire

	// Opnum53NotUsedOnWire operation.
	// Opnum53NotUsedOnWire

	// Opnum54NotUsedOnWire operation.
	// Opnum54NotUsedOnWire

	// Opnum55NotUsedOnWire operation.
	// Opnum55NotUsedOnWire

	// The RQueryServiceConfigEx  method SHOULD<82> query the optional configuration parameters
	// of a service.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED           | The SERVICE_QUERY_CONFIG access right had not been granted to the caller when    |
	//	|                                 | the RPC context handle was created.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE          | The handle is no longer valid.                                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 124 ERROR_INVALID_LEVEL         | The dwInfoLevel parameter contains an unsupported value.                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS | The system is shutting down.                                                     |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	QueryServiceConfigEx(context.Context, *QueryServiceConfigExRequest, ...dcerpc.CallOption) (*QueryServiceConfigExResponse, error)

	// Opnum57NotUsedOnWire operation.
	// Opnum57NotUsedOnWire

	// Opnum58NotUsedOnWire operation.
	// Opnum58NotUsedOnWire

	// Opnum59NotUsedOnWire operation.
	// Opnum59NotUsedOnWire

	// The RCreateWowService method creates a service whose binary is compiled for a specified
	// computer architecture.<83> The path to the file image is automatically adjusted to
	// point to the correct WoW-redirected location.
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED                | The SC_MANAGER_CREATE_SERVICE access right had not been granted to the caller    |
	//	|                                      | when the RPC context handle to the SCM was created.                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 6 ERROR_INVALID_HANDLE               | The handle specified is invalid.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 13 ERROR_INVALID_DATA                | The data is invalid.                                                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 50 ERROR_NOT_SUPPORTED               | dwServiceWowType was an architecture that is not supported.                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 87 ERROR_INVALID_PARAMETER           | A parameter that was specified is invalid.                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME               | The specified service name is invalid.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1057 ERROR_INVALID_SERVICE_ACCOUNT   | The user account name specified in the lpServiceStartName parameter does not     |
	//	|                                      | exist.                                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1059 ERROR_CIRCULAR_DEPENDENCY       | A circular service dependency was specified.                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1072 ERROR_SERVICE_MARKED_FOR_DELETE | The service record with a specified name already exists, and RDeleteService has  |
	//	|                                      | been called for it.                                                              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1073 ERROR_SERVICE_EXISTS            | The service record with the ServiceName matching the specified lpServiceName     |
	//	|                                      | already exists.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1078 ERROR_DUPLICATE_SERVICE_NAME    | The service record with the same DisplayName or the same ServiceName as the      |
	//	|                                      | passed-in lpDisplayName already exists in the service control manager database.  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS      | The system is shutting down.                                                     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	CreateWOWService(context.Context, *CreateWOWServiceRequest, ...dcerpc.CallOption) (*CreateWOWServiceResponse, error)

	// The ROpenSCManager2 method establishes a connection to server and opens the SCM database
	// on the specified server.<87>
	//
	// Return Values: The method returns 0x00000000 (ERROR_SUCCESS) on success; otherwise,
	// it returns one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 5 ERROR_ACCESS_DENIED              | The client does not have the required access rights to open the SCM              |
	//	|                                    | database on the server or the desired access is not granted to it in the SCM     |
	//	|                                    | SecurityDescriptor.                                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 123 ERROR_INVALID_NAME             | The specified service name is invalid.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1065 ERROR_DATABASE_DOES_NOT_EXIST | The database specified does not exist.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 1115 ERROR_SHUTDOWN_IN_PROGRESS    | The system is shutting down.                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	OpenSCM2(context.Context, *OpenSCM2Request, ...dcerpc.CallOption) (*OpenSCM2Response, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error
}

// MaxServiceNameLength represents the MAX_SERVICE_NAME_LENGTH RPC constant
const MaxServiceNameLength = 0x00000100

// MaxDependSize represents the SC_MAX_DEPEND_SIZE RPC constant
const MaxDependSize = 0x1000

// MaxNameLength represents the SC_MAX_NAME_LENGTH RPC constant
const MaxNameLength = 0x0101

// MaxPathLength represents the SC_MAX_PATH_LENGTH RPC constant
const MaxPathLength = 0x8000

// MaxPwdSize represents the SC_MAX_PWD_SIZE RPC constant
const MaxPwdSize = 0x0202

// MaxComputerNameLength represents the SC_MAX_COMPUTER_NAME_LENGTH RPC constant
const MaxComputerNameLength = 0x0400

// MaxAccountNameLength represents the SC_MAX_ACCOUNT_NAME_LENGTH RPC constant
const MaxAccountNameLength = 0x0800

// MaxCommentLength represents the SC_MAX_COMMENT_LENGTH RPC constant
const MaxCommentLength = 0x0080

// MaxArgumentLength represents the SC_MAX_ARGUMENT_LENGTH RPC constant
const MaxArgumentLength = 0x0400

// MaxArguments represents the SC_MAX_ARGUMENTS RPC constant
const MaxArguments = 0x0400

// Handle structure represents SC_RPC_HANDLE RPC structure.
type Handle dcetypes.ContextHandle

func (o *Handle) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Handle) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Handle) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Handle) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Lock structure represents SC_RPC_LOCK RPC structure.
type Lock dcetypes.ContextHandle

func (o *Lock) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Lock) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Lock) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Lock) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Notify structure represents SC_NOTIFY_RPC_HANDLE RPC structure.
type Notify dcetypes.ContextHandle

func (o *Notify) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Notify) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Notify) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Notify) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// String structure represents STRING_PTRSA RPC structure.
//
// The STRING_PTRSA structure defines a pointer to an ANSI character string.
type String struct {
	// StringPtr:  Pointer to an ANSI character string.
	StringPointer string `idl:"name:StringPtr;string" json:"string_pointer"`
}

func (o *String) xxx_PreparePayload(ctx context.Context) error {
	if len(o.StringPointer) > int(1024) {
		return fmt.Errorf("StringPointer is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *String) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.StringPointer != "" {
		_ptr_StringPtr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.StringPointer); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.StringPointer, _ptr_StringPtr); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *String) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_StringPtr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.StringPointer); err != nil {
			return err
		}
		return nil
	})
	_s_StringPtr := func(ptr interface{}) { o.StringPointer = *ptr.(*string) }
	if err := w.ReadPointer(&o.StringPointer, _s_StringPtr, _ptr_StringPtr); err != nil {
		return err
	}
	return nil
}

// UnicodeString structure represents STRING_PTRSW RPC structure.
//
// The STRING_PTRSW structure defines a pointer to a Unicode character string.
type UnicodeString struct {
	// StringPtr:  A pointer to a Unicode character string.
	StringPointer string `idl:"name:StringPtr;string" json:"string_pointer"`
}

func (o *UnicodeString) xxx_PreparePayload(ctx context.Context) error {
	if len(o.StringPointer) > int(1024) {
		return fmt.Errorf("StringPointer is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UnicodeString) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.StringPointer != "" {
		_ptr_StringPtr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.StringPointer); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.StringPointer, _ptr_StringPtr); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *UnicodeString) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_StringPtr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.StringPointer); err != nil {
			return err
		}
		return nil
	})
	_s_StringPtr := func(ptr interface{}) { o.StringPointer = *ptr.(*string) }
	if err := w.ReadPointer(&o.StringPointer, _s_StringPtr, _ptr_StringPtr); err != nil {
		return err
	}
	return nil
}

// ServiceStatus structure represents SERVICE_STATUS RPC structure.
//
// The SERVICE_STATUS structure defines information about a service.
type ServiceStatus struct {
	// dwServiceType:  The type of service.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | A service that runs in its own process.                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | A service that shares a process with other services.                             |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwCurrentState:  The current state of the service.
	//
	//	+------------+--------------------------+
	//	|            |                          |
	//	|   VALUE    |         MEANING          |
	//	|            |                          |
	//	+------------+--------------------------+
	//	+------------+--------------------------+
	//	| 0x00000005 | SERVICE_CONTINUE_PENDING |
	//	+------------+--------------------------+
	//	| 0x00000006 | SERVICE_PAUSE_PENDING    |
	//	+------------+--------------------------+
	//	| 0x00000007 | SERVICE_PAUSED           |
	//	+------------+--------------------------+
	//	| 0x00000004 | SERVICE_RUNNING          |
	//	+------------+--------------------------+
	//	| 0x00000002 | SERVICE_START_PENDING    |
	//	+------------+--------------------------+
	//	| 0x00000003 | SERVICE_STOP_PENDING     |
	//	+------------+--------------------------+
	//	| 0x00000001 | SERVICE_STOPPED          |
	//	+------------+--------------------------+
	CurrentState uint32 `idl:"name:dwCurrentState" json:"current_state"`
	// dwControlsAccepted:  The control codes that the service accepts and processes in
	// its handler function. One or more of the following values can be set. By default,
	// all services accept the SERVICE_CONTROL_INTERROGATE value. A value of zero indicates
	// that no controls are accepted.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 | SERVICE_ACCEPT_PARAMCHANGE Service can reread its startup parameters without     |
	//	|            | being stopped and restarted. This control code allows the service to receive     |
	//	|            | SERVICE_CONTROL_PARAMCHANGE notifications.                                       |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 | SERVICE_ACCEPT_PAUSE_CONTINUE Service can be paused and continued. This          |
	//	|            | control code allows the service to receive SERVICE_CONTROL_PAUSE and             |
	//	|            | SERVICE_CONTROL_CONTINUE notifications.                                          |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 | SERVICE_ACCEPT_SHUTDOWN Service is notified when system shutdown occurs.         |
	//	|            | This control code enables the service to receive SERVICE_CONTROL_SHUTDOWN        |
	//	|            | notifications from the server.                                                   |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | SERVICE_ACCEPT_STOP Service can be stopped. This control code allows the service |
	//	|            | to receive SERVICE_CONTROL_STOP notifications.                                   |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000020 | SERVICE_ACCEPT_HARDWAREPROFILECHANGE Service is notified when the computer's     |
	//	|            | hardware profile changes.                                                        |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000040 | SERVICE_ACCEPT_POWEREVENT Service is notified when the computer's power status   |
	//	|            | changes.                                                                         |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000080 | SERVICE_ACCEPT_SESSIONCHANGE Service is notified when the computer's session     |
	//	|            | status changes.                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000100 | SERVICE_ACCEPT_PRESHUTDOWN<17> The service can perform preshutdown tasks.        |
	//	|            | SERVICE_ACCEPT_PRESHUTDOWN is sent before sending SERVICE_CONTROL_SHUTDOWN to    |
	//	|            | give more time to services that need extra time before shutdown occurs.          |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000200 | SERVICE_ACCEPT_TIMECHANGE<18> Service is notified when the system time changes.  |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000400 | SERVICE_ACCEPT_TRIGGEREVENT<19> Service is notified when an event for which the  |
	//	|            | service has registered occurs.                                                   |
	//	+------------+----------------------------------------------------------------------------------+
	ControlsAccepted uint32 `idl:"name:dwControlsAccepted" json:"controls_accepted"`
	// dwWin32ExitCode:  An error code that the service uses to report an error that occurs
	// when it is starting or stopping. To return an error code specific to the service,
	// the service MUST set this value to ERROR_SERVICE_SPECIFIC_ERROR to indicate that
	// the dwServiceSpecificExitCode member contains the error code. The service sets this
	// value to NO_ERROR when it is running and on normal termination.
	Win32ExitCode uint32 `idl:"name:dwWin32ExitCode" json:"win32_exit_code"`
	// dwServiceSpecificExitCode:  A service-specific error code that the service returns
	// when an error occurs while it is starting or stopping. The client SHOULD<20> ignore
	// this value unless the dwWin32ExitCode member is set to ERROR_SERVICE_SPECIFIC_ERROR.
	ServiceSpecificExitCode uint32 `idl:"name:dwServiceSpecificExitCode" json:"service_specific_exit_code"`
	// dwCheckPoint:  A value that the service increments periodically to report its progress
	// during a lengthy start, stop, pause, or continue operation. This value is zero when
	// the service state is SERVICE_PAUSED, SERVICE_RUNNING, or SERVICE_STOPPED.
	CheckPoint uint32 `idl:"name:dwCheckPoint" json:"check_point"`
	// dwWaitHint:  An estimate of the amount of time, in milliseconds, that the service
	// expects a pending start, stop, pause, or continue operation to take before the service
	// makes its next status update. Before the specified amount of time has elapsed, the
	// service makes its next call to the SetServiceStatus function with either an incremented
	// dwCheckPoint value or a change in dwCurrentState. If the time specified by dwWaitHint
	// passes, and dwCheckPoint has not been incremented or dwCurrentState has not changed,
	// the server can assume that an error has occurred and the service can be stopped.
	// However, if the service shares a process with other services, the server cannot terminate
	// the service application because it would have to terminate the other services sharing
	// the process as well.
	WaitHint uint32 `idl:"name:dwWaitHint" json:"wait_hint"`
}

func (o *ServiceStatus) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceStatus) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentState); err != nil {
		return err
	}
	if err := w.WriteData(o.ControlsAccepted); err != nil {
		return err
	}
	if err := w.WriteData(o.Win32ExitCode); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceSpecificExitCode); err != nil {
		return err
	}
	if err := w.WriteData(o.CheckPoint); err != nil {
		return err
	}
	if err := w.WriteData(o.WaitHint); err != nil {
		return err
	}
	return nil
}
func (o *ServiceStatus) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentState); err != nil {
		return err
	}
	if err := w.ReadData(&o.ControlsAccepted); err != nil {
		return err
	}
	if err := w.ReadData(&o.Win32ExitCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceSpecificExitCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.CheckPoint); err != nil {
		return err
	}
	if err := w.ReadData(&o.WaitHint); err != nil {
		return err
	}
	return nil
}

// ServiceStatusProcess structure represents SERVICE_STATUS_PROCESS RPC structure.
//
// The SERVICE_STATUS_PROCESS structure contains information about a service that is
// used by the RQueryServiceStatusEx method.
type ServiceStatusProcess struct {
	// dwServiceType:  The type of service. This MUST be one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | A service that runs in its own process.                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | A service that shares a process with other services.                             |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwCurrentState:  The current state of the service. This MUST be one of the following
	// values.
	//
	//	+------------+--------------------------+
	//	|            |                          |
	//	|   VALUE    |         MEANING          |
	//	|            |                          |
	//	+------------+--------------------------+
	//	+------------+--------------------------+
	//	| 0x00000005 | SERVICE_CONTINUE_PENDING |
	//	+------------+--------------------------+
	//	| 0x00000006 | SERVICE_PAUSE_PENDING    |
	//	+------------+--------------------------+
	//	| 0x00000007 | SERVICE_PAUSED           |
	//	+------------+--------------------------+
	//	| 0x00000004 | SERVICE_RUNNING          |
	//	+------------+--------------------------+
	//	| 0x00000002 | SERVICE_START_PENDING    |
	//	+------------+--------------------------+
	//	| 0x00000003 | SERVICE_STOP_PENDING     |
	//	+------------+--------------------------+
	//	| 0x00000001 | SERVICE_STOPPED          |
	//	+------------+--------------------------+
	CurrentState uint32 `idl:"name:dwCurrentState" json:"current_state"`
	// dwControlsAccepted:  The control codes that the service accepts and processes in
	// its handler function. This bit mask MUST be set to zero or more of the following
	// values. The value of dwControlsAccepted is 0x00000000 if the service type is SERVICE_KERNEL_DRIVER
	// or SERVICE_FILE_SYSTEM_DRIVER.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 | SERVICE_ACCEPT_PARAMCHANGE Service can reread its startup parameters without     |
	//	|            | being stopped and restarted.                                                     |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 | SERVICE_ACCEPT_PAUSE_CONTINUE Service can be paused and continued.               |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 | SERVICE_ACCEPT_SHUTDOWN Service is notified when system shutdown occurs.         |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | SERVICE_ACCEPT_STOP Service can be stopped.                                      |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000020 | SERVICE_ACCEPT_HARDWAREPROFILECHANGE Service is notified when the computer       |
	//	|            | hardware profile changes.                                                        |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000040 | SERVICE_ACCEPT_POWEREVENT Service is notified when the computer power status     |
	//	|            | changes.                                                                         |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000080 | SERVICE_ACCEPT_SESSIONCHANGE Service is notified when the computer session       |
	//	|            | status changes.                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000100 | SERVICE_ACCEPT_PRESHUTDOWN<22> The service can perform preshutdown tasks.        |
	//	|            | SERVICE_ACCEPT_PRESHUTDOWN is sent before sending SERVICE_CONTROL_SHUTDOWN to    |
	//	|            | give more time to services that need extra time before shutdown occurs.          |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000200 | SERVICE_ACCEPT_TIMECHANGE<23> Service is notified when the system time changes.  |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000400 | SERVICE_ACCEPT_TRIGGEREVENT<24> Service is notified when an event for which the  |
	//	|            | service has registered occurs.                                                   |
	//	+------------+----------------------------------------------------------------------------------+
	ControlsAccepted uint32 `idl:"name:dwControlsAccepted" json:"controls_accepted"`
	// dwWin32ExitCode:  An error code that the service uses to report an error that occurs
	// when it is starting or stopping.
	Win32ExitCode uint32 `idl:"name:dwWin32ExitCode" json:"win32_exit_code"`
	// dwServiceSpecificExitCode:  A service-specific error code that the service returns
	// when an error occurs while it is starting or stopping.
	ServiceSpecificExitCode uint32 `idl:"name:dwServiceSpecificExitCode" json:"service_specific_exit_code"`
	// dwCheckPoint:  A value that the service increments periodically to report its progress
	// during a lengthy start, stop, pause, or continue operation.
	CheckPoint uint32 `idl:"name:dwCheckPoint" json:"check_point"`
	// dwWaitHint:  An estimate of the amount of time, in milliseconds, that the service
	// expects a pending start, stop, pause, or continue operation to take before the service
	// makes its next status update.
	WaitHint uint32 `idl:"name:dwWaitHint" json:"wait_hint"`
	// dwProcessId:  A process identifier of the service. A value of 0 indicates that the
	// service is not started.
	ProcessID uint32 `idl:"name:dwProcessId" json:"process_id"`
	// dwServiceFlags:  The bit flags that describe the process in which the service is
	// running. This MUST be one of the following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 | Service is either running in a process that is not a system process, or the      |
	//	|            | service is not running at all. In a nonsystem process, dwProcessId is nonzero.   |
	//	|            | If the service is not running, dwProcessId is 0.                                 |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | Service runs in a system process that MUST always be running.                    |
	//	+------------+----------------------------------------------------------------------------------+
	ServiceFlags uint32 `idl:"name:dwServiceFlags" json:"service_flags"`
}

func (o *ServiceStatusProcess) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceStatusProcess) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentState); err != nil {
		return err
	}
	if err := w.WriteData(o.ControlsAccepted); err != nil {
		return err
	}
	if err := w.WriteData(o.Win32ExitCode); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceSpecificExitCode); err != nil {
		return err
	}
	if err := w.WriteData(o.CheckPoint); err != nil {
		return err
	}
	if err := w.WriteData(o.WaitHint); err != nil {
		return err
	}
	if err := w.WriteData(o.ProcessID); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceFlags); err != nil {
		return err
	}
	return nil
}
func (o *ServiceStatusProcess) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentState); err != nil {
		return err
	}
	if err := w.ReadData(&o.ControlsAccepted); err != nil {
		return err
	}
	if err := w.ReadData(&o.Win32ExitCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceSpecificExitCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.CheckPoint); err != nil {
		return err
	}
	if err := w.ReadData(&o.WaitHint); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProcessID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceFlags); err != nil {
		return err
	}
	return nil
}

// QueryServiceConfigW structure represents QUERY_SERVICE_CONFIGW RPC structure.
//
// The QUERY_SERVICE_CONFIGW structure defines configuration information about an installed
// service. String values are stored in Unicode.
type QueryServiceConfigW struct {
	// dwServiceType:  The type of service. This member MUST be one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | A service that runs in its own process.                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | A service that shares a process with other services.                             |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType:  Defines when to start the service. This member MUST be one of the following
	// values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | A service started automatically by the SCM during system startup.                |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | A service that cannot be started. Attempts to start the service result in the    |
	//	|                                 | error code ERROR_SERVICE_DISABLED.                                               |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl:  The severity of the error if this service fails to start during
	// startup and the action the SCM takes if failure occurs.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error in the event log and continues the startup operation.     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error in the event log. If the last-known good configuration    |
	//	|                                   | is being started, the startup operation continues. Otherwise, the system is      |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error in the event log if possible. If the last-known     |
	//	|                                   | good configuration is being started, the startup operation fails. Otherwise, the |
	//	|                                   | system is restarted with the last-known good configuration.                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName:  A pointer to a null-terminated string that contains the fully
	// qualified path to the service binary file. The path MAY include arguments. If the
	// path contains a space, it MUST be quoted so that it is correctly interpreted. For
	// example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup:  A pointer to a null-terminated string that names the service group
	// for load ordering of which this service is a member. If the pointer is NULL or if
	// it points to an empty string, the service does not belong to a group.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string" json:"load_order_group"`
	// dwTagId:  A unique tag value for this service in the service group. A value of 0
	// indicates that the service has not been assigned a tag.
	TagID uint32 `idl:"name:dwTagId" json:"tag_id"`
	// lpDependencies:  A pointer to an array of null-separated names of services or service
	// groups that MUST start before this service. The array is doubly null-terminated.
	// Service group names are prefixed with a "+" character (to distinguish them from service
	// names). If the pointer is NULL or if it points to an empty string, the service has
	// no dependencies. Cyclic dependency between services is not allowed. The character
	// set is Unicode. Dependency on a service means that this service can only run if the
	// service it depends on is running. Dependency on a group means that this service can
	// run if at least one member of the group is running after an attempt to start all
	// members of the group.
	Dependencies string `idl:"name:lpDependencies;string" json:"dependencies"`
	// lpServiceStartName:  A pointer to a null-terminated string that contains the service
	// start (key) name.
	ServiceStartName string `idl:"name:lpServiceStartName;string" json:"service_start_name"`
	// lpDisplayName:  A pointer to a null-terminated string that contains the service display
	// name.
	DisplayName string `idl:"name:lpDisplayName;string" json:"display_name"`
}

func (o *QueryServiceConfigW) xxx_PreparePayload(ctx context.Context) error {
	if len(o.BinaryPathName) > int(8192) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(8192) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if len(o.Dependencies) > int(8192) {
		return fmt.Errorf("Dependencies is out of range")
	}
	if len(o.ServiceStartName) > int(8192) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if len(o.DisplayName) > int(8192) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceConfigW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	if err := w.WriteData(o.StartType); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorControl); err != nil {
		return err
	}
	if o.BinaryPathName != "" {
		_ptr_lpBinaryPathName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.BinaryPathName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.BinaryPathName, _ptr_lpBinaryPathName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.LoadOrderGroup != "" {
		_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TagID); err != nil {
		return err
	}
	if o.Dependencies != "" {
		_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Dependencies); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStartName != "" {
		_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceConfigW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.StartType); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorControl); err != nil {
		return err
	}
	_ptr_lpBinaryPathName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
		return nil
	})
	_s_lpBinaryPathName := func(ptr interface{}) { o.BinaryPathName = *ptr.(*string) }
	if err := w.ReadPointer(&o.BinaryPathName, _s_lpBinaryPathName, _ptr_lpBinaryPathName); err != nil {
		return err
	}
	_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.LoadOrderGroup); err != nil {
			return err
		}
		return nil
	})
	_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
	if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
		return err
	}
	if err := w.ReadData(&o.TagID); err != nil {
		return err
	}
	_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Dependencies); err != nil {
			return err
		}
		return nil
	})
	_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*string) }
	if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
		return err
	}
	_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceStartName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	return nil
}

// QueryServiceLockStatusW structure represents QUERY_SERVICE_LOCK_STATUSW RPC structure.
//
// The QUERY_SERVICE_LOCK_STATUSW structure defines information about the lock status
// of an SCM database. String values are stored in Unicode.
type QueryServiceLockStatusW struct {
	// fIsLocked:  The lock status of the database. If this member is nonzero, the database
	// is locked. If it is 0, the database is unlocked.
	IsLocked uint32 `idl:"name:fIsLocked" json:"is_locked"`
	// lpLockOwner:  A pointer to a null-terminated string that contains the name of the
	// user that acquired the lock.
	LockOwner string `idl:"name:lpLockOwner;string" json:"lock_owner"`
	// dwLockDuration:  The elapsed time, in seconds, since the lock was first acquired.
	LockDuration uint32 `idl:"name:dwLockDuration" json:"lock_duration"`
}

func (o *QueryServiceLockStatusW) xxx_PreparePayload(ctx context.Context) error {
	if len(o.LockOwner) > int(8192) {
		return fmt.Errorf("LockOwner is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceLockStatusW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IsLocked); err != nil {
		return err
	}
	if o.LockOwner != "" {
		_ptr_lpLockOwner := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.LockOwner); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LockOwner, _ptr_lpLockOwner); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LockDuration); err != nil {
		return err
	}
	return nil
}
func (o *QueryServiceLockStatusW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IsLocked); err != nil {
		return err
	}
	_ptr_lpLockOwner := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.LockOwner); err != nil {
			return err
		}
		return nil
	})
	_s_lpLockOwner := func(ptr interface{}) { o.LockOwner = *ptr.(*string) }
	if err := w.ReadPointer(&o.LockOwner, _s_lpLockOwner, _ptr_lpLockOwner); err != nil {
		return err
	}
	if err := w.ReadData(&o.LockDuration); err != nil {
		return err
	}
	return nil
}

// QueryServiceConfigA structure represents QUERY_SERVICE_CONFIGA RPC structure.
//
// The QUERY_SERVICE_CONFIGA structure defines configuration information about an installed
// service. String values are stored in ANSI.
type QueryServiceConfigA struct {
	// dwServiceType:  The type of service. This member MUST be one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | A service that runs in its own process.                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | A service that shares a process with other services.                             |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType:  Defines when to start the service. This member MUST be one of the following
	// values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | A service started automatically by the SCM during system startup.                |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | A service that cannot be started. Attempts to start the service result in the    |
	//	|                                 | error code ERROR_SERVICE_DISABLED.                                               |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl:  The severity of the error if this service fails to start during
	// startup, and the action that the SCM takes if failure occurs.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error in the event log and continues the startup operation.     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error in the event log. If the last-known good configuration    |
	//	|                                   | is being started, the startup operation continues. Otherwise, the system is      |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error in the event log if possible. If the last-known     |
	//	|                                   | good configuration is being started, the startup operation fails. Otherwise, the |
	//	|                                   | system is restarted with the last-known good configuration.                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName:  A pointer to a null-terminated string that contains the fully
	// qualified path to the service binary file. The path MAY include arguments. If the
	// path contains a space, it MUST be quoted so that it is correctly interpreted. For
	// example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup:  A pointer to a null-terminated string that names the service group
	// for load-ordering of which this service is a member. If the pointer is NULL or if
	// it points to an empty string, the service does not belong to a group.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string" json:"load_order_group"`
	// dwTagId:  A unique tag value for this service within the service group specified
	// by the lpLoadOrderGroup parameter. A value of 0 indicates that the service has not
	// been assigned a tag.
	TagID uint32 `idl:"name:dwTagId" json:"tag_id"`
	// lpDependencies:  A pointer to an array of null-separated names of services or names
	// of service groups that MUST start before this service. The array is doubly null-terminated.
	// Service group names are prefixed with a "+" character (to distinguish them from service
	// names). If the pointer is NULL or if it points to an empty string, the service has
	// no dependencies. Cyclic dependency between services is not allowed. The character
	// set is ANSI. Dependency on a service means that this service can only run if the
	// service it depends on is running. Dependency on a group means that this service can
	// run if at least one member of the group is running after an attempt to start all
	// members of the group.
	Dependencies string `idl:"name:lpDependencies;string" json:"dependencies"`
	// lpServiceStartName:  A pointer to a null-terminated string that contains the service
	// name.
	ServiceStartName string `idl:"name:lpServiceStartName;string" json:"service_start_name"`
	// lpDisplayName:  A pointer to a null-terminated string that contains the service display
	// name.
	DisplayName string `idl:"name:lpDisplayName;string" json:"display_name"`
}

func (o *QueryServiceConfigA) xxx_PreparePayload(ctx context.Context) error {
	if len(o.BinaryPathName) > int(8192) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(8192) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if len(o.Dependencies) > int(8192) {
		return fmt.Errorf("Dependencies is out of range")
	}
	if len(o.ServiceStartName) > int(8192) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if len(o.DisplayName) > int(8192) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceConfigA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	if err := w.WriteData(o.StartType); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorControl); err != nil {
		return err
	}
	if o.BinaryPathName != "" {
		_ptr_lpBinaryPathName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.BinaryPathName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.BinaryPathName, _ptr_lpBinaryPathName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.LoadOrderGroup != "" {
		_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TagID); err != nil {
		return err
	}
	if o.Dependencies != "" {
		_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.Dependencies); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStartName != "" {
		_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceConfigA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.StartType); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorControl); err != nil {
		return err
	}
	_ptr_lpBinaryPathName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
		return nil
	})
	_s_lpBinaryPathName := func(ptr interface{}) { o.BinaryPathName = *ptr.(*string) }
	if err := w.ReadPointer(&o.BinaryPathName, _s_lpBinaryPathName, _ptr_lpBinaryPathName); err != nil {
		return err
	}
	_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.LoadOrderGroup); err != nil {
			return err
		}
		return nil
	})
	_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
	if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
		return err
	}
	if err := w.ReadData(&o.TagID); err != nil {
		return err
	}
	_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.Dependencies); err != nil {
			return err
		}
		return nil
	})
	_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*string) }
	if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
		return err
	}
	_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.ServiceStartName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	return nil
}

// QueryServiceLockStatusA structure represents QUERY_SERVICE_LOCK_STATUSA RPC structure.
//
// The QUERY_SERVICE_LOCK_STATUSA structure defines information about the lock status
// of an SCM database. String values are stored in ANSI.
type QueryServiceLockStatusA struct {
	// fIsLocked:  The lock status of the database. If this member is nonzero, the database
	// is locked. If it is 0, the database is unlocked.
	IsLocked uint32 `idl:"name:fIsLocked" json:"is_locked"`
	// lpLockOwner:  A pointer to a null-terminated string that contains the name of the
	// user that acquired the lock.
	LockOwner string `idl:"name:lpLockOwner;string" json:"lock_owner"`
	// dwLockDuration:  The elapsed time, in seconds, since the lock was first acquired.
	LockDuration uint32 `idl:"name:dwLockDuration" json:"lock_duration"`
}

func (o *QueryServiceLockStatusA) xxx_PreparePayload(ctx context.Context) error {
	if len(o.LockOwner) > int(8192) {
		return fmt.Errorf("LockOwner is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *QueryServiceLockStatusA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IsLocked); err != nil {
		return err
	}
	if o.LockOwner != "" {
		_ptr_lpLockOwner := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.LockOwner); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LockOwner, _ptr_lpLockOwner); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LockDuration); err != nil {
		return err
	}
	return nil
}
func (o *QueryServiceLockStatusA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IsLocked); err != nil {
		return err
	}
	_ptr_lpLockOwner := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.LockOwner); err != nil {
			return err
		}
		return nil
	})
	_s_lpLockOwner := func(ptr interface{}) { o.LockOwner = *ptr.(*string) }
	if err := w.ReadPointer(&o.LockOwner, _s_lpLockOwner, _ptr_lpLockOwner); err != nil {
		return err
	}
	if err := w.ReadData(&o.LockDuration); err != nil {
		return err
	}
	return nil
}

// ServiceDescriptionA structure represents SERVICE_DESCRIPTIONA RPC structure.
//
// The SERVICE_DESCRIPTIONA structure contains the description of the service. String
// values are in ANSI.
type ServiceDescriptionA struct {
	// lpDescription:  A pointer to a string that contains the description of the service
	// in ANSI.
	Description string `idl:"name:lpDescription;string" json:"description"`
}

func (o *ServiceDescriptionA) xxx_PreparePayload(ctx context.Context) error {
	if len(o.Description) > int(8192) {
		return fmt.Errorf("Description is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDescriptionA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Description != "" {
		_ptr_lpDescription := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.Description); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Description, _ptr_lpDescription); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDescriptionA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_lpDescription := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.Description); err != nil {
			return err
		}
		return nil
	})
	_s_lpDescription := func(ptr interface{}) { o.Description = *ptr.(*string) }
	if err := w.ReadPointer(&o.Description, _s_lpDescription, _ptr_lpDescription); err != nil {
		return err
	}
	return nil
}

// ActionType type represents SC_ACTION_TYPE RPC enumeration.
//
// The SC_ACTION_TYPE enumeration specifies action levels for the Type member of the
// SC_ACTION structure.
type ActionType uint32

var (
	// SC_ACTION_NONE:  No action.
	ActionTypeNone ActionType = 0
	// SC_ACTION_RESTART:  Restart the service.
	ActionTypeRestart ActionType = 1
	// SC_ACTION_REBOOT:  Reboot the computer.
	ActionTypeReboot ActionType = 2
	// SC_ACTION_RUN_COMMAND:  Run a command.
	ActionTypeRunCommand ActionType = 3
)

func (o ActionType) String() string {
	switch o {
	case ActionTypeNone:
		return "ActionTypeNone"
	case ActionTypeRestart:
		return "ActionTypeRestart"
	case ActionTypeReboot:
		return "ActionTypeReboot"
	case ActionTypeRunCommand:
		return "ActionTypeRunCommand"
	}
	return "Invalid"
}

// Action structure represents SC_ACTION RPC structure.
//
// The SC_ACTION structure defines an action that the SCM can perform.
type Action struct {
	// Type:  The action to be performed. This member MUST be one of the values from the
	// SC_ACTION_TYPE (section 2.2.18) enumeration.
	Type ActionType `idl:"name:Type" json:"type"`
	// Delay:  The time, in milliseconds, to wait before performing the specified action.
	Delay uint32 `idl:"name:Delay" json:"delay"`
}

func (o *Action) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Action) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(uint32(o.Type)); err != nil {
		return err
	}
	if err := w.WriteData(o.Delay); err != nil {
		return err
	}
	return nil
}
func (o *Action) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData((*uint32)(&o.Type)); err != nil {
		return err
	}
	if err := w.ReadData(&o.Delay); err != nil {
		return err
	}
	return nil
}

// ServiceFailureActionsA structure represents SERVICE_FAILURE_ACTIONSA RPC structure.
//
// The SERVICE_FAILURE_ACTIONSA structure defines the action that the service controller
// takes on each failure of a service. String values are stored in ANSI.
type ServiceFailureActionsA struct {
	// dwResetPeriod:  The time, in seconds, after which to reset the failure count to zero
	// if there are no failures.
	ResetPeriod uint32 `idl:"name:dwResetPeriod" json:"reset_period"`
	// lpRebootMsg:  The buffer that contains the message to be broadcast to server users
	// before rebooting in response to the SC_ACTION_REBOOT service controller action.
	RebootMessage string `idl:"name:lpRebootMsg;string" json:"reboot_message"`
	// lpCommand:  The buffer that contains the command line of the process for the process
	// creation function to execute in response to the SC_ACTION_RUN_COMMAND service controller
	// action.
	Command string `idl:"name:lpCommand;string" json:"command"`
	// cActions:  The number of elements in the lpsaActions array.
	ActionsCount uint32 `idl:"name:cActions" json:"actions_count"`
	// lpsaActions:  A pointer to an array of SC_ACTION (section 2.2.19) structures.
	Actions []*Action `idl:"name:lpsaActions;size_is:(cActions)" json:"actions"`
}

func (o *ServiceFailureActionsA) xxx_PreparePayload(ctx context.Context) error {
	if o.Actions != nil && o.ActionsCount == 0 {
		o.ActionsCount = uint32(len(o.Actions))
	}
	if len(o.RebootMessage) > int(8192) {
		return fmt.Errorf("RebootMessage is out of range")
	}
	if len(o.Command) > int(8192) {
		return fmt.Errorf("Command is out of range")
	}
	if o.ActionsCount > uint32(1024) {
		return fmt.Errorf("ActionsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ResetPeriod); err != nil {
		return err
	}
	if o.RebootMessage != "" {
		_ptr_lpRebootMsg := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.RebootMessage); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.RebootMessage, _ptr_lpRebootMsg); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Command != "" {
		_ptr_lpCommand := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.Command); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Command, _ptr_lpCommand); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ActionsCount); err != nil {
		return err
	}
	if o.Actions != nil || o.ActionsCount > 0 {
		_ptr_lpsaActions := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ActionsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Actions {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Actions[i1] != nil {
					if err := o.Actions[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Action{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Actions); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&Action{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Actions, _ptr_lpsaActions); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResetPeriod); err != nil {
		return err
	}
	_ptr_lpRebootMsg := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.RebootMessage); err != nil {
			return err
		}
		return nil
	})
	_s_lpRebootMsg := func(ptr interface{}) { o.RebootMessage = *ptr.(*string) }
	if err := w.ReadPointer(&o.RebootMessage, _s_lpRebootMsg, _ptr_lpRebootMsg); err != nil {
		return err
	}
	_ptr_lpCommand := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.Command); err != nil {
			return err
		}
		return nil
	})
	_s_lpCommand := func(ptr interface{}) { o.Command = *ptr.(*string) }
	if err := w.ReadPointer(&o.Command, _s_lpCommand, _ptr_lpCommand); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActionsCount); err != nil {
		return err
	}
	_ptr_lpsaActions := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ActionsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ActionsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Actions", sizeInfo[0])
		}
		o.Actions = make([]*Action, sizeInfo[0])
		for i1 := range o.Actions {
			i1 := i1
			if o.Actions[i1] == nil {
				o.Actions[i1] = &Action{}
			}
			if err := o.Actions[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_lpsaActions := func(ptr interface{}) { o.Actions = *ptr.(*[]*Action) }
	if err := w.ReadPointer(&o.Actions, _s_lpsaActions, _ptr_lpsaActions); err != nil {
		return err
	}
	return nil
}

// ServiceDelayedAutoStartInfo structure represents SERVICE_DELAYED_AUTO_START_INFO RPC structure.
//
// The SERVICE_DELAYED_AUTO_START_INFO structure<11> defines the delayed autostart setting
// of an autostart service.
type ServiceDelayedAutoStartInfo struct {
	// fDelayedAutostart:  A Boolean value that specifies whether to delay the start of
	// the service. If this value is TRUE, the service is started after other autostart
	// services are started plus a short delay of approximately two minutes. Otherwise,
	// the service is started during the system boot. This setting is ignored unless the
	// service is an autostart service.
	//
	// If the service has other services that it is dependent on, as specified via the lpDependencies
	// member of the QUERY_SERVICE_CONFIGA structure (section 2.2.14) and the QUERY_SERVICE_CONFIGW
	// structure (section 2.2.15), then those services are started before this service.
	DelayedAutoStart bool `idl:"name:fDelayedAutostart" json:"delayed_auto_start"`
}

func (o *ServiceDelayedAutoStartInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDelayedAutoStartInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.DelayedAutoStart {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDelayedAutoStartInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bDelayedAutoStart int32
	if err := w.ReadData(&_bDelayedAutoStart); err != nil {
		return err
	}
	o.DelayedAutoStart = _bDelayedAutoStart != 0
	return nil
}

// ServiceFailureActionsFlag structure represents SERVICE_FAILURE_ACTIONS_FLAG RPC structure.
//
// The SERVICE_FAILURE_ACTIONS_FLAG structure<12> defines the failure action setting
// of a service. This setting determines when failure actions are to be executed.
type ServiceFailureActionsFlag struct {
	// fFailureActionsOnNonCrashFailures:  If this member is TRUE and the service has configured
	// failure actions, the failure actions are queued if the service process terminates
	// without reporting a status of SERVICE_STOPPED or if it enters the SERVICE_STOPPED
	// state but the dwWin32ExitCode member of the SERVICE_STATUS (section 2.2.47) structure
	// is not ERROR_SUCCESS.
	//
	// If this member is FALSE and the service has configured failure actions, the failure
	// actions are queued only if the service terminates without reporting a status of SERVICE_STOPPED.
	FailureActionsOnNonCrashFailures bool `idl:"name:fFailureActionsOnNonCrashFailures" json:"failure_actions_on_non_crash_failures"`
}

func (o *ServiceFailureActionsFlag) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsFlag) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.FailureActionsOnNonCrashFailures {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsFlag) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bFailureActionsOnNonCrashFailures int32
	if err := w.ReadData(&_bFailureActionsOnNonCrashFailures); err != nil {
		return err
	}
	o.FailureActionsOnNonCrashFailures = _bFailureActionsOnNonCrashFailures != 0
	return nil
}

// ServiceSIDInfo structure represents SERVICE_SID_INFO RPC structure.
//
// The SERVICE_SID_INFO structure<16> defines the type of service security identifier
// (SID) associated with a service.
type ServiceSIDInfo struct {
	// dwServiceSidType:  The type of service SID. This MUST be one of the following values.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                          |                                                                                  |
	//	|                  VALUE                   |                                     MEANING                                      |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SID_TYPE_NONE 0x00000000         | No service SID.                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SID_TYPE_RESTRICTED 0x00000003   | This type includes SERVICE_SID_TYPE_UNRESTRICTED. The service SID is also added  |
	//	|                                          | to the restricted SID list of the process token. Three additional SIDs are added |
	//	|                                          | to the restricted SID list: 1. World SID S-1-1-0. 2. Service logon SID. 3. One   |
	//	|                                          | access control entry (ACE) that allows GENERIC_ALL access for the service logon  |
	//	|                                          | SID is also added to the service process token object. If multiple services are  |
	//	|                                          | hosted in the same process and one service has SERVICE_SID_TYPE_RESTRICTED, all  |
	//	|                                          | services MUST have SERVICE_SID_TYPE_RESTRICTED.                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SID_TYPE_UNRESTRICTED 0x00000001 | When the service process is created, the service SID is added to the service     |
	//	|                                          | process token with the following attributes: SE_GROUP_ENABLED_BY_DEFAULT |       |
	//	|                                          | SE_GROUP_OWNER.                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	ServiceSIDType uint32 `idl:"name:dwServiceSidType" json:"service_sid_type"`
}

func (o *ServiceSIDInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceSIDInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceSIDType); err != nil {
		return err
	}
	return nil
}
func (o *ServiceSIDInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceSIDType); err != nil {
		return err
	}
	return nil
}

// ServicePreshutdownInfo structure represents SERVICE_PRESHUTDOWN_INFO RPC structure.
//
// The SERVICE_PRESHUTDOWN_INFO structure<15> defines the time-out value in milliseconds.
type ServicePreshutdownInfo struct {
	// dwPreshutdownTimeout:  Time, in milliseconds, that the SCM waits for the service
	// to enter the SERVICE_STOPPED state after sending the SERVICE_CONTROL_PRESHUTDOWN
	// message.
	PreshutdownTimeout uint32 `idl:"name:dwPreshutdownTimeout" json:"preshutdown_timeout"`
}

func (o *ServicePreshutdownInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServicePreshutdownInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PreshutdownTimeout); err != nil {
		return err
	}
	return nil
}
func (o *ServicePreshutdownInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PreshutdownTimeout); err != nil {
		return err
	}
	return nil
}

// ServiceDescriptionW structure represents SERVICE_DESCRIPTIONW RPC structure.
//
// The SERVICE_DESCRIPTIONW structure contains the description of the service. String
// values are in Unicode.
type ServiceDescriptionW struct {
	// lpDescription:  A pointer to a string that contains the description of the service
	// in Unicode.
	Description string `idl:"name:lpDescription;string" json:"description"`
}

func (o *ServiceDescriptionW) xxx_PreparePayload(ctx context.Context) error {
	if len(o.Description) > int(8192) {
		return fmt.Errorf("Description is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDescriptionW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Description != "" {
		_ptr_lpDescription := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Description); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Description, _ptr_lpDescription); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDescriptionW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_lpDescription := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Description); err != nil {
			return err
		}
		return nil
	})
	_s_lpDescription := func(ptr interface{}) { o.Description = *ptr.(*string) }
	if err := w.ReadPointer(&o.Description, _s_lpDescription, _ptr_lpDescription); err != nil {
		return err
	}
	return nil
}

// ServiceFailureActionsW structure represents SERVICE_FAILURE_ACTIONSW RPC structure.
//
// The SERVICE_FAILURE_ACTIONSW structure defines the action that the service controller
// takes on each failure of a service. String values are stored in Unicode.
type ServiceFailureActionsW struct {
	// dwResetPeriod:  The time, in seconds, after which to reset the failure count to zero
	// if there are no failures.
	ResetPeriod uint32 `idl:"name:dwResetPeriod" json:"reset_period"`
	// lpRebootMsg:  The buffer that contains the message to be broadcast to server users
	// before rebooting in response to the SC_ACTION_REBOOT service controller action.
	RebootMessage string `idl:"name:lpRebootMsg;string" json:"reboot_message"`
	// lpCommand:  The buffer that contains the command line of the process for the process
	// creation function to execute in response to the SC_ACTION_RUN_COMMAND service controller
	// action.
	Command string `idl:"name:lpCommand;string" json:"command"`
	// cActions:  The number of elements in the lpsaActions array.
	ActionsCount uint32 `idl:"name:cActions" json:"actions_count"`
	// lpsaActions:  A pointer to an array of SC_ACTION (section 2.2.19) structures.
	Actions []*Action `idl:"name:lpsaActions;size_is:(cActions)" json:"actions"`
}

func (o *ServiceFailureActionsW) xxx_PreparePayload(ctx context.Context) error {
	if o.Actions != nil && o.ActionsCount == 0 {
		o.ActionsCount = uint32(len(o.Actions))
	}
	if len(o.RebootMessage) > int(8192) {
		return fmt.Errorf("RebootMessage is out of range")
	}
	if len(o.Command) > int(8192) {
		return fmt.Errorf("Command is out of range")
	}
	if o.ActionsCount > uint32(1024) {
		return fmt.Errorf("ActionsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ResetPeriod); err != nil {
		return err
	}
	if o.RebootMessage != "" {
		_ptr_lpRebootMsg := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.RebootMessage); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.RebootMessage, _ptr_lpRebootMsg); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Command != "" {
		_ptr_lpCommand := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Command); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Command, _ptr_lpCommand); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ActionsCount); err != nil {
		return err
	}
	if o.Actions != nil || o.ActionsCount > 0 {
		_ptr_lpsaActions := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ActionsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Actions {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Actions[i1] != nil {
					if err := o.Actions[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Action{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Actions); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&Action{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Actions, _ptr_lpsaActions); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResetPeriod); err != nil {
		return err
	}
	_ptr_lpRebootMsg := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.RebootMessage); err != nil {
			return err
		}
		return nil
	})
	_s_lpRebootMsg := func(ptr interface{}) { o.RebootMessage = *ptr.(*string) }
	if err := w.ReadPointer(&o.RebootMessage, _s_lpRebootMsg, _ptr_lpRebootMsg); err != nil {
		return err
	}
	_ptr_lpCommand := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Command); err != nil {
			return err
		}
		return nil
	})
	_s_lpCommand := func(ptr interface{}) { o.Command = *ptr.(*string) }
	if err := w.ReadPointer(&o.Command, _s_lpCommand, _ptr_lpCommand); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActionsCount); err != nil {
		return err
	}
	_ptr_lpsaActions := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ActionsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ActionsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Actions", sizeInfo[0])
		}
		o.Actions = make([]*Action, sizeInfo[0])
		for i1 := range o.Actions {
			i1 := i1
			if o.Actions[i1] == nil {
				o.Actions[i1] = &Action{}
			}
			if err := o.Actions[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_lpsaActions := func(ptr interface{}) { o.Actions = *ptr.(*[]*Action) }
	if err := w.ReadPointer(&o.Actions, _s_lpsaActions, _ptr_lpsaActions); err != nil {
		return err
	}
	return nil
}

// StatusType type represents SC_STATUS_TYPE RPC enumeration.
//
// The SC_STATUS_TYPE enumeration specifies the information level for the RQueryServiceStatusEx
// method.
type StatusType uint32

var (
	// SC_STATUS_PROCESS_INFO:  The information level
	StatusTypeProcessInfo StatusType = 0
)

func (o StatusType) String() string {
	switch o {
	case StatusTypeProcessInfo:
		return "StatusTypeProcessInfo"
	}
	return "Invalid"
}

// EnumType type represents SC_ENUM_TYPE RPC enumeration.
//
// The SC_ENUM_TYPE enumeration specifies information levels for the REnumServicesStatusExA
// and REnumServicesStatusExW methods.
type EnumType uint32

var (
	// SC_ENUM_PROCESS_INFO:  Information level.
	EnumTypeProcessInfo EnumType = 0
)

func (o EnumType) String() string {
	switch o {
	case EnumTypeProcessInfo:
		return "EnumTypeProcessInfo"
	}
	return "Invalid"
}

// ServicePreferredNodeInfo structure represents SERVICE_PREFERRED_NODE_INFO RPC structure.
type ServicePreferredNodeInfo struct {
	// usPreferredNode:  The preferred node number.
	PreferredNode uint16 `idl:"name:usPreferredNode" json:"preferred_node"`
	// fDelete:  If the preferred NUMA node information of the service can be deleted, set
	// to 1; otherwise set to 0.
	Delete bool `idl:"name:fDelete" json:"delete"`
}

func (o *ServicePreferredNodeInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServicePreferredNodeInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.PreferredNode); err != nil {
		return err
	}
	if err := w.WriteData(o.Delete); err != nil {
		return err
	}
	return nil
}
func (o *ServicePreferredNodeInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.PreferredNode); err != nil {
		return err
	}
	if err := w.ReadData(&o.Delete); err != nil {
		return err
	}
	return nil
}

// ServiceTriggerSpecificDataItem structure represents SERVICE_TRIGGER_SPECIFIC_DATA_ITEM RPC structure.
//
// The SERVICE_TRIGGER_SPECIFIC_DATA_ITEM <25> structure contains information about
// one trigger data item of a service.
type ServiceTriggerSpecificDataItem struct {
	// dwDataType:  The type of trigger data. This MUST be one of the following values.
	//
	//	+------------+----------------------------------+
	//	|            |                                  |
	//	|   VALUE    |             MEANING              |
	//	|            |                                  |
	//	+------------+----------------------------------+
	//	+------------+----------------------------------+
	//	| 0x00000001 | SERVICE_TRIGGER_DATA_TYPE_BINARY |
	//	+------------+----------------------------------+
	//	| 0x00000002 | SERVICE_TRIGGER_DATA_TYPE_STRING |
	//	+------------+----------------------------------+
	DataType uint32 `idl:"name:dwDataType" json:"data_type"`
	// cbData:  Size in bytes of the data in pData.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pData:  Trigger data. When dwDataType is set equal to 0x00000002 (SERVICE_TRIGGER_DATA_TYPE_STRING),
	// the encoding is Unicode string and includes a terminating null character. This string
	// can contain data in the format of a sequence of null-terminated strings, terminated
	// by an empty string (\0).
	Data []byte `idl:"name:pData;size_is:(cbData)" json:"data"`
}

func (o *ServiceTriggerSpecificDataItem) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if o.DataLength > uint32(1024) {
		return fmt.Errorf("DataLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceTriggerSpecificDataItem) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DataType); err != nil {
		return err
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.Data != nil || o.DataLength > 0 {
		_ptr_pData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_pData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceTriggerSpecificDataItem) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataType); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_pData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Data, _s_pData, _ptr_pData); err != nil {
		return err
	}
	return nil
}

// ServiceTrigger structure represents SERVICE_TRIGGER RPC structure.
//
// The SERVICE_TRIGGER <26> structure contains information about one trigger of a service.
type ServiceTrigger struct {
	// dwTriggerType:  The type of trigger. This MUST be one of the following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL The event is triggered when        |
	//	|            | a device of the specified device interface class arrives or is present when      |
	//	|            | the system starts. This trigger event is commonly used to start a service.       |
	//	|            | Interface arrival occurs when a device belonging to a device interface class     |
	//	|            | has been inserted. The pTriggerSubtype member specifies the device interface     |
	//	|            | class GUID, as defined in [MS-DTYP] section 2.3.4. These GUIDs are defined       |
	//	|            | in device-specific header files provided with the Windows Driver Kit (WDK)       |
	//	|            | [MSDN-WinDriverKit]. The pDataItems member specifies one or more hardware        |
	//	|            | ID and compatible ID strings for the device interface class. Strings MUST        |
	//	|            | be Unicode. If more than one string is specified, the event is triggered         |
	//	|            | if any one of the strings matches. For example, the Wpdbusenum service           |
	//	|            | is started when a device of device interface class GUID_DEVINTERFACE_DISK        |
	//	|            | {53f56307-b6bf-11d0-94f2-00a0c91efb8b} and a hardware ID string of               |
	//	|            | "USBSTOR\GenDisk" arrives.                                                       |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 | SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY The event is triggered when         |
	//	|            | the first IP address on the TCP/IP networking stack becomes available            |
	//	|            | or the last IP address on the stack becomes unavailable. This trigger            |
	//	|            | event can be used to start or stop a service. The pTriggerSubtype                |
	//	|            | member specifies NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID or                |
	//	|            | NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID. The pDataItems member is not used. |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000003 | SERVICE_TRIGGER_TYPE_DOMAIN_JOIN The event is triggered when the computer joins  |
	//	|            | or leaves a domain. This trigger event can be used to start or stop a service.   |
	//	|            | The pTriggerSubtype member specifies DOMAIN_JOIN_GUID or DOMAIN_LEAVE_GUID. The  |
	//	|            | pDataItems member is not used.                                                   |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 | SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT The event is triggered when a firewall  |
	//	|            | port is opened or approximately 60 seconds after the firewall port is closed.    |
	//	|            | This trigger event can be used to start or stop a service. The pTriggerSubtype   |
	//	|            | member specifies FIREWALL_PORT_OPEN_GUID or FIREWALL_PORT_CLOSE_GUID. The        |
	//	|            | pDataItems member specifies the port, the protocol, and optionally the           |
	//	|            | executable path and user information (SID string or name) of the service         |
	//	|            | listening on the event. The "RPC" token can be used in place of the port to      |
	//	|            | specify any listening socket used by RPC. The "system" token can be used in      |
	//	|            | place of the executable path to specify ports created by and listened on by the  |
	//	|            | Windows kernel. The event is triggered only if all strings match. For example,   |
	//	|            | if MyService hosted inside Svchost.exe is to be trigger-started when port UDP    |
	//	|            | 5001 opens, the trigger-specific data would be the Unicode representation of     |
	//	|            | "5001\0UDP\0%systemroot%\system32\svchost.exe\0MyService\0\0".                   |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 | SERVICE_TRIGGER_TYPE_GROUP_POLICY The event is triggered when a machine policy   |
	//	|            | or user policy change occurs. This trigger event is commonly used to start a     |
	//	|            | service. The pTriggerSubtype member specifies MACHINE_POLICY_PRESENT_GUID or     |
	//	|            | USER_POLICY_PRESENT_GUID. The pDataItems member is not used.                     |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000020 | SERVICE_TRIGGER_TYPE_CUSTOM The event is a custom event generated by an Event    |
	//	|            | Tracing for Windows (ETW) provider. This trigger event can be used to start or   |
	//	|            | stop a service. The pTriggerSubtype member specifies the event provider's GUID.  |
	//	|            | The pDataItems member specifies trigger-specific data defined by the provider.   |
	//	+------------+----------------------------------------------------------------------------------+
	TriggerType uint32 `idl:"name:dwTriggerType" json:"trigger_type"`
	// dwAction:  The type of action to be taken on the trigger arrival. This MUST be one
	// of the following values.
	//
	//	+------------+--------------------------------------+
	//	|            |                                      |
	//	|   VALUE    |               MEANING                |
	//	|            |                                      |
	//	+------------+--------------------------------------+
	//	+------------+--------------------------------------+
	//	| 0x00000001 | SERVICE_TRIGGER_ACTION_SERVICE_START |
	//	+------------+--------------------------------------+
	//	| 0x00000002 | SERVICE_TRIGGER_ACTION_SERVICE_STOP  |
	//	+------------+--------------------------------------+
	Action uint32 `idl:"name:dwAction" json:"action"`
	// pTriggerSubtype:  Points to a GUID that identifies the trigger event subtype. The
	// value of this member depends on the value of the dwTriggerType member.
	//
	// If dwTriggerType is SERVICE_TRIGGER_TYPE_CUSTOM, pTriggerSubtype is the GUID that
	// identifies the custom event provider.
	//
	// If dwTriggerType is SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL, pTriggerSubtype
	// is the GUID that identifies the device interface class.
	//
	// For other trigger event types, pTriggerSubtype can be one of the following values.
	//
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                                                  |                                                                                  |
	//	|                                      VALUE                                       |                                     MEANING                                      |
	//	|                                                                                  |                                                                                  |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DOMAIN_JOIN_GUID 1ce20aba-9851-4421-9430-1ddeb766e809                            | The event is triggered when the computer joins a domain. The dwTriggerType       |
	//	|                                                                                  | member MUST be SERVICE_TRIGGER_TYPE_DOMAIN_JOIN.                                 |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DOMAIN_LEAVE_GUID ddaf516e-58c2-4866-9574-c3b615d42ea1                           | The event is triggered when the computer leaves a domain. The dwTriggerType      |
	//	|                                                                                  | member MUST be SERVICE_TRIGGER_TYPE_DOMAIN_JOIN.                                 |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FIREWALL_PORT_OPEN_GUID b7569e07-8421-4ee0-ad10-86915afdad09                     | The event is triggered when the specified firewall port is opened. The           |
	//	|                                                                                  | dwTriggerType member MUST be SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT.           |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FIREWALL_PORT_CLOSE_GUID a144ed38-8e12-4de4-9d96-e64740b1a524                    | The event is triggered approximately 60 seconds after the                        |
	//	|                                                                                  | specified firewall port is closed. The dwTriggerType member MUST be              |
	//	|                                                                                  | SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT.                                        |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MACHINE_POLICY_PRESENT_GUID 659FCAE6-5BDB-4DA9-B1FF-CA2A178D46E0                 | The event is triggered when the machine policy has changed. The dwTriggerType    |
	//	|                                                                                  | member MUST be SERVICE_TRIGGER_TYPE_GROUP_POLICY.                                |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID                                    | The event is triggered when the first IP address on the TCP/IP                   |
	//	| 4f27f2de-14e2-430b-a549-7cd48cbc8245                                             | networking stack becomes available. The dwTriggerType member MUST be             |
	//	|                                                                                  | SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY.                                    |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID                                     | The event is triggered when the last IP address on the TCP/IP                    |
	//	| cc4ba62a-162e-4648-847a-b6bdf993e335                                             | networking stack becomes unavailable. The dwTriggerType member MUST be           |
	//	|                                                                                  | SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY.                                    |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| USER_POLICY_PRESENT_GUID 54FB46C8-F089-464C-B1FD-59D1B62C3B50                    | The event is triggered when the user policy has changed. The dwTriggerType       |
	//	|                                                                                  | member MUST be SERVICE_TRIGGER_TYPE_GROUP_POLICY.                                |
	//	+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	TriggerSubtype *dtyp.GUID `idl:"name:pTriggerSubtype" json:"trigger_subtype"`
	// cDataItems:  Number of data items in the pDataItems array.
	DataItemsCount uint32 `idl:"name:cDataItems" json:"data_items_count"`
	// pDataItems:  Array of SERVICE_TRIGGER_SPECIFIC_DATA_ITEM structures.
	DataItems []*ServiceTriggerSpecificDataItem `idl:"name:pDataItems;size_is:(cDataItems)" json:"data_items"`
}

func (o *ServiceTrigger) xxx_PreparePayload(ctx context.Context) error {
	if o.DataItems != nil && o.DataItemsCount == 0 {
		o.DataItemsCount = uint32(len(o.DataItems))
	}
	if o.DataItemsCount > uint32(64) {
		return fmt.Errorf("DataItemsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceTrigger) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.TriggerType); err != nil {
		return err
	}
	if err := w.WriteData(o.Action); err != nil {
		return err
	}
	if o.TriggerSubtype != nil {
		_ptr_pTriggerSubtype := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.TriggerSubtype != nil {
				if err := o.TriggerSubtype.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TriggerSubtype, _ptr_pTriggerSubtype); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DataItemsCount); err != nil {
		return err
	}
	if o.DataItems != nil || o.DataItemsCount > 0 {
		_ptr_pDataItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.DataItems {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.DataItems[i1] != nil {
					if err := o.DataItems[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServiceTriggerSpecificDataItem{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.DataItems); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServiceTriggerSpecificDataItem{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DataItems, _ptr_pDataItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceTrigger) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.TriggerType); err != nil {
		return err
	}
	if err := w.ReadData(&o.Action); err != nil {
		return err
	}
	_ptr_pTriggerSubtype := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.TriggerSubtype == nil {
			o.TriggerSubtype = &dtyp.GUID{}
		}
		if err := o.TriggerSubtype.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pTriggerSubtype := func(ptr interface{}) { o.TriggerSubtype = *ptr.(**dtyp.GUID) }
	if err := w.ReadPointer(&o.TriggerSubtype, _s_pTriggerSubtype, _ptr_pTriggerSubtype); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataItemsCount); err != nil {
		return err
	}
	_ptr_pDataItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DataItems", sizeInfo[0])
		}
		o.DataItems = make([]*ServiceTriggerSpecificDataItem, sizeInfo[0])
		for i1 := range o.DataItems {
			i1 := i1
			if o.DataItems[i1] == nil {
				o.DataItems[i1] = &ServiceTriggerSpecificDataItem{}
			}
			if err := o.DataItems[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pDataItems := func(ptr interface{}) { o.DataItems = *ptr.(*[]*ServiceTriggerSpecificDataItem) }
	if err := w.ReadPointer(&o.DataItems, _s_pDataItems, _ptr_pDataItems); err != nil {
		return err
	}
	return nil
}

// ServiceTriggerInfo structure represents SERVICE_TRIGGER_INFO RPC structure.
//
// The SERVICE_TRIGGER_INFO <27> structure contains trigger information about a service.
type ServiceTriggerInfo struct {
	// cTriggers:  Number of items in the pTriggers array.
	TriggersCount uint32 `idl:"name:cTriggers" json:"triggers_count"`
	// pTriggers:  Array of triggers each element of type SERVICE_TRIGGER.
	Triggers []*ServiceTrigger `idl:"name:pTriggers;size_is:(cTriggers)" json:"triggers"`
	// pReserved:  Reserved, MUST be NULL.
	_ uint8 `idl:"name:pReserved"`
}

func (o *ServiceTriggerInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.Triggers != nil && o.TriggersCount == 0 {
		o.TriggersCount = uint32(len(o.Triggers))
	}
	if o.TriggersCount > uint32(64) {
		return fmt.Errorf("TriggersCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceTriggerInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.TriggersCount); err != nil {
		return err
	}
	if o.Triggers != nil || o.TriggersCount > 0 {
		_ptr_pTriggers := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TriggersCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Triggers {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Triggers[i1] != nil {
					if err := o.Triggers[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServiceTrigger{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Triggers); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServiceTrigger{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Triggers, _ptr_pTriggers); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved pReserved
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	return nil
}
func (o *ServiceTriggerInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.TriggersCount); err != nil {
		return err
	}
	_ptr_pTriggers := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TriggersCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TriggersCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Triggers", sizeInfo[0])
		}
		o.Triggers = make([]*ServiceTrigger, sizeInfo[0])
		for i1 := range o.Triggers {
			i1 := i1
			if o.Triggers[i1] == nil {
				o.Triggers[i1] = &ServiceTrigger{}
			}
			if err := o.Triggers[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pTriggers := func(ptr interface{}) { o.Triggers = *ptr.(*[]*ServiceTrigger) }
	if err := w.ReadPointer(&o.Triggers, _s_pTriggers, _ptr_pTriggers); err != nil {
		return err
	}
	// reserved pReserved
	var _pReserved uint8
	_ptr_pReserved := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := w.ReadData(&_pReserved); err != nil {
			return err
		}
		return nil
	})
	_s_pReserved := func(ptr interface{}) { _pReserved = *ptr.(*uint8) }
	if err := w.ReadPointer(&_pReserved, _s_pReserved, _ptr_pReserved); err != nil {
		return err
	}
	return nil
}

// EnumServiceStatusA structure represents ENUM_SERVICE_STATUSA RPC structure.
//
// The ENUM_SERVICE_STATUSA structure defines the name and status of a service in an
// SCM database and returns information about the service. String values are stored
// in ANSI.
type EnumServiceStatusA struct {
	// lpServiceName:  A pointer to a null-terminated string that names a service in an
	// SCM database.
	ServiceName string `idl:"name:lpServiceName" json:"service_name"`
	// lpDisplayName:  A pointer to a null-terminated string that user interface programs
	// use to identify the service.
	DisplayName string `idl:"name:lpDisplayName" json:"display_name"`
	// ServiceStatus:  A SERVICE_STATUS (section 2.2.47) structure that contains status
	// information.
	ServiceStatus *ServiceStatus `idl:"name:ServiceStatus" json:"service_status"`
}

func (o *EnumServiceStatusA) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ServiceName != "" {
		_ptr_lpServiceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharString(ctx, w, o.ServiceName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceName, _ptr_lpServiceName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharString(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatus{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpServiceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceName := func(ptr interface{}) { o.ServiceName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceName, _s_lpServiceName, _ptr_lpServiceName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatus{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// EnumServiceStatusW structure represents ENUM_SERVICE_STATUSW RPC structure.
//
// The ENUM_SERVICE_STATUSW structure defines the name and status of a service in an
// SCM database and returns information about the service. String values are stored
// in Unicode.
type EnumServiceStatusW struct {
	// lpServiceName:  A pointer to a null-terminated string that names a service in an
	// SCM database.
	ServiceName string `idl:"name:lpServiceName" json:"service_name"`
	// lpDisplayName:  A pointer to a null-terminated string that user interface programs
	// use to identify the service.
	DisplayName string `idl:"name:lpDisplayName" json:"display_name"`
	// ServiceStatus:  A SERVICE_STATUS (section 2.2.47) structure that contains status
	// information.
	ServiceStatus *ServiceStatus `idl:"name:ServiceStatus" json:"service_status"`
}

func (o *EnumServiceStatusW) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ServiceName != "" {
		_ptr_lpServiceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.ServiceName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceName, _ptr_lpServiceName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatus{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpServiceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.ServiceName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceName := func(ptr interface{}) { o.ServiceName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceName, _s_lpServiceName, _ptr_lpServiceName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatus{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// EnumServiceStatusProcessA structure represents ENUM_SERVICE_STATUS_PROCESSA RPC structure.
//
// The ENUM_SERVICE_STATUS_PROCESSA structure contains information used by the REnumServicesStatusExA
// method to return the name of a service in an SCM database. The structure also returns
// information about the service. String values are stored in ANSI.
type EnumServiceStatusProcessA struct {
	// lpServiceName:  A pointer to a null-terminated string that names a service in an
	// SCM database.
	ServiceName string `idl:"name:lpServiceName" json:"service_name"`
	// lpDisplayName:  A pointer to a null-terminated string that contains the display name
	// of the service.
	DisplayName string `idl:"name:lpDisplayName" json:"display_name"`
	// ServiceStatusProcess:  A SERVICE_STATUS_PROCESS (section 2.2.49) structure that contains
	// status information for the lpServiceName service.
	ServiceStatusProcess *ServiceStatusProcess `idl:"name:ServiceStatusProcess" json:"service_status_process"`
}

func (o *EnumServiceStatusProcessA) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusProcessA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ServiceName != "" {
		_ptr_lpServiceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharString(ctx, w, o.ServiceName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceName, _ptr_lpServiceName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharString(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStatusProcess != nil {
		if err := o.ServiceStatusProcess.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusProcessA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpServiceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceName := func(ptr interface{}) { o.ServiceName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceName, _s_lpServiceName, _ptr_lpServiceName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	if o.ServiceStatusProcess == nil {
		o.ServiceStatusProcess = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatusProcess.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// EnumServiceStatusProcessW structure represents ENUM_SERVICE_STATUS_PROCESSW RPC structure.
//
// The ENUM_SERVICE_STATUS_PROCESSW structure contains information used by the REnumServicesStatusExW
// method to return the name of a service in an SCM database. The structure also returns
// information about the service. String values are stored in Unicode.
type EnumServiceStatusProcessW struct {
	// lpServiceName:  A pointer to a null-terminated string that names a service in an
	// SCM database.
	ServiceName string `idl:"name:lpServiceName" json:"service_name"`
	// lpDisplayName:  A pointer to a null-terminated string that contains the display name
	// of the service.
	DisplayName string `idl:"name:lpDisplayName" json:"display_name"`
	// ServiceStatusProcess:  A SERVICE_STATUS_PROCESS (section 2.2.49) structure that contains
	// status information for the lpServiceName service.
	ServiceStatusProcess *ServiceStatusProcess `idl:"name:ServiceStatusProcess" json:"service_status_process"`
}

func (o *EnumServiceStatusProcessW) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusProcessW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ServiceName != "" {
		_ptr_lpServiceName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.ServiceName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceName, _ptr_lpServiceName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DisplayName != "" {
		_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServiceStatusProcess != nil {
		if err := o.ServiceStatusProcess.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EnumServiceStatusProcessW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpServiceName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.ServiceName); err != nil {
			return err
		}
		return nil
	})
	_s_lpServiceName := func(ptr interface{}) { o.ServiceName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceName, _s_lpServiceName, _ptr_lpServiceName); err != nil {
		return err
	}
	_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.DisplayName); err != nil {
			return err
		}
		return nil
	})
	_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
		return err
	}
	if o.ServiceStatusProcess == nil {
		o.ServiceStatusProcess = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatusProcess.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServiceDescriptionWOW64 structure represents SERVICE_DESCRIPTION_WOW64 RPC structure.
//
// The SERVICE_DESCRIPTION_WOW64 structure defines the offset at which SERVICE_DESRIPTIONW
// is present.
type ServiceDescriptionWOW64 struct {
	// dwDescriptionOffset:  A pointer to the offset for the SERVICE_DESCRIPTIONW (section
	// 2.2.35) structure, which contains the service description in Unicode.
	DescriptionOffset uint32 `idl:"name:dwDescriptionOffset" json:"description_offset"`
}

func (o *ServiceDescriptionWOW64) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceDescriptionWOW64) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DescriptionOffset); err != nil {
		return err
	}
	return nil
}
func (o *ServiceDescriptionWOW64) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DescriptionOffset); err != nil {
		return err
	}
	return nil
}

// ServiceFailureActionsWOW64 structure represents SERVICE_FAILURE_ACTIONS_WOW64 RPC structure.
//
// The SERVICE_FAILURE_ACTIONS_WOW64 structure defines the action that the service controller
// takes on each failure of a service.
type ServiceFailureActionsWOW64 struct {
	// dwResetPeriod:  The time, in seconds, after which to reset the failure count to zero
	// if there are no failures.
	ResetPeriod uint32 `idl:"name:dwResetPeriod" json:"reset_period"`
	// dwRebootMsgOffset:  The offset for the buffer containing the message that is broadcast
	// in response to the SC_ACTION_REBOOT service controller action (section 2.2.18) to
	// all server users prior to a server reboot.
	RebootMessageOffset uint32 `idl:"name:dwRebootMsgOffset" json:"reboot_message_offset"`
	// dwCommandOffset:  The offset for the buffer that contains the Unicode command line
	// of the process that the process creation function executes in response to the SC_ACTION_RUN_COMMAND
	// service controller action (section 2.2.18).
	CommandOffset uint32 `idl:"name:dwCommandOffset" json:"command_offset"`
	// cActions:  The number of SC_ACTION (section 2.2.19) structures in the array that
	// is offset by the value of dwsaActionsOffset.
	ActionsCount uint32 `idl:"name:cActions" json:"actions_count"`
	// dwsaActionsOffset:  The offset for the buffer that contains an array of SC_ACTION
	// structures.
	ActionsOffset uint32 `idl:"name:dwsaActionsOffset" json:"actions_offset"`
}

func (o *ServiceFailureActionsWOW64) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceFailureActionsWOW64) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ResetPeriod); err != nil {
		return err
	}
	if err := w.WriteData(o.RebootMessageOffset); err != nil {
		return err
	}
	if err := w.WriteData(o.CommandOffset); err != nil {
		return err
	}
	if err := w.WriteData(o.ActionsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ActionsOffset); err != nil {
		return err
	}
	return nil
}
func (o *ServiceFailureActionsWOW64) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResetPeriod); err != nil {
		return err
	}
	if err := w.ReadData(&o.RebootMessageOffset); err != nil {
		return err
	}
	if err := w.ReadData(&o.CommandOffset); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActionsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActionsOffset); err != nil {
		return err
	}
	return nil
}

// ServiceRequiredPrivilegesInfoWOW64 structure represents SERVICE_REQUIRED_PRIVILEGES_INFO_WOW64 RPC structure.
//
// The SERVICE_REQUIRED_PRIVILEGES_INFO_WOW64 structure defines the offset at which
// the SERVICE_RPC_REQUIRED_PRIVILEGES_INFO (section 2.2.48) structure is present.
type ServiceRequiredPrivilegesInfoWOW64 struct {
	// dwRequiredPrivilegesOffset:  Offset of the SERVICE_RPC_REQUIRED_PRIVILEGES_INFO structure.
	RequiredPrivilegesOffset uint32 `idl:"name:dwRequiredPrivilegesOffset" json:"required_privileges_offset"`
}

func (o *ServiceRequiredPrivilegesInfoWOW64) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceRequiredPrivilegesInfoWOW64) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RequiredPrivilegesOffset); err != nil {
		return err
	}
	return nil
}
func (o *ServiceRequiredPrivilegesInfoWOW64) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequiredPrivilegesOffset); err != nil {
		return err
	}
	return nil
}

// RequiredPrivilegesInfo structure represents SERVICE_RPC_REQUIRED_PRIVILEGES_INFO RPC structure.
//
// The SERVICE_RPC_REQUIRED_PRIVILEGES_INFO structure<21> defines the required privileges
// for a service.
type RequiredPrivilegesInfo struct {
	// cbRequiredPrivileges:  Size, in bytes, of the pRequiredPrivileges buffer.
	RequiredPrivilegesLength uint32 `idl:"name:cbRequiredPrivileges" json:"required_privileges_length"`
	// pRequiredPrivileges:  Buffer that contains the required privileges of a service in
	// the format of a sequence of null-terminated strings, terminated by an empty string
	// (\0). The privilege constants are detailed in [MS-LSAD] section 3.1.1.2.1.
	RequiredPrivileges []byte `idl:"name:pRequiredPrivileges;size_is:(cbRequiredPrivileges)" json:"required_privileges"`
}

func (o *RequiredPrivilegesInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.RequiredPrivileges != nil && o.RequiredPrivilegesLength == 0 {
		o.RequiredPrivilegesLength = uint32(len(o.RequiredPrivileges))
	}
	if o.RequiredPrivilegesLength > uint32(4096) {
		return fmt.Errorf("RequiredPrivilegesLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *RequiredPrivilegesInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.RequiredPrivilegesLength); err != nil {
		return err
	}
	if o.RequiredPrivileges != nil || o.RequiredPrivilegesLength > 0 {
		_ptr_pRequiredPrivileges := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.RequiredPrivilegesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.RequiredPrivileges {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.RequiredPrivileges[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.RequiredPrivileges); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.RequiredPrivileges, _ptr_pRequiredPrivileges); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *RequiredPrivilegesInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequiredPrivilegesLength); err != nil {
		return err
	}
	_ptr_pRequiredPrivileges := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.RequiredPrivilegesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.RequiredPrivilegesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.RequiredPrivileges", sizeInfo[0])
		}
		o.RequiredPrivileges = make([]byte, sizeInfo[0])
		for i1 := range o.RequiredPrivileges {
			i1 := i1
			if err := w.ReadData(&o.RequiredPrivileges[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pRequiredPrivileges := func(ptr interface{}) { o.RequiredPrivileges = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.RequiredPrivileges, _s_pRequiredPrivileges, _ptr_pRequiredPrivileges); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA structure represents SC_RPC_CONFIG_INFOA RPC structure.
//
// The SC_RPC_CONFIG_INFOA structure defines the service configuration based on a supplied
// level. String values are stored in ANSI.
type ConfigInfoA struct {
	// dwInfoLevel:  A DWORD value that indicates the type of configuration information
	// in the included data.
	InfoLevel   uint32                   `idl:"name:dwInfoLevel" json:"info_level"`
	ConfigInfoA *ConfigInfoA_ConfigInfoA `idl:"name:ConfigInfoA;switch_is:dwInfoLevel" json:"config_info_a"`
}

func (o *ConfigInfoA) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoLevel); err != nil {
		return err
	}
	_swConfigInfoA := uint32(o.InfoLevel)
	if o.ConfigInfoA != nil {
		if err := o.ConfigInfoA.MarshalUnionNDR(ctx, w, _swConfigInfoA); err != nil {
			return err
		}
	} else {
		if err := (&ConfigInfoA_ConfigInfoA{}).MarshalUnionNDR(ctx, w, _swConfigInfoA); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoLevel); err != nil {
		return err
	}
	if o.ConfigInfoA == nil {
		o.ConfigInfoA = &ConfigInfoA_ConfigInfoA{}
	}
	_swConfigInfoA := uint32(o.InfoLevel)
	if err := o.ConfigInfoA.UnmarshalUnionNDR(ctx, w, _swConfigInfoA); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_ConfigInfoA structure represents SC_RPC_CONFIG_INFOA union anonymous member.
//
// The SC_RPC_CONFIG_INFOA structure defines the service configuration based on a supplied
// level. String values are stored in ANSI.
type ConfigInfoA_ConfigInfoA struct {
	// Types that are assignable to Value
	//
	// *ConfigInfoA_Description
	// *ConfigInfoA_FailureActions
	// *ConfigInfoA_DelayedAutoStart
	// *ConfigInfoA_FailureActionsFlag
	// *ConfigInfoA_SIDInfo
	// *ConfigInfoA_RequiredPrivileges
	// *ConfigInfoA_Preshutdown
	// *ConfigInfoA_TriggerInfo
	// *ConfigInfoA_PreferredNode
	Value is_ConfigInfoA_ConfigInfoA `json:"value"`
}

func (o *ConfigInfoA_ConfigInfoA) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ConfigInfoA_Description:
		if value != nil {
			return value.Description
		}
	case *ConfigInfoA_FailureActions:
		if value != nil {
			return value.FailureActions
		}
	case *ConfigInfoA_DelayedAutoStart:
		if value != nil {
			return value.DelayedAutoStart
		}
	case *ConfigInfoA_FailureActionsFlag:
		if value != nil {
			return value.FailureActionsFlag
		}
	case *ConfigInfoA_SIDInfo:
		if value != nil {
			return value.SIDInfo
		}
	case *ConfigInfoA_RequiredPrivileges:
		if value != nil {
			return value.RequiredPrivileges
		}
	case *ConfigInfoA_Preshutdown:
		if value != nil {
			return value.Preshutdown
		}
	case *ConfigInfoA_TriggerInfo:
		if value != nil {
			return value.TriggerInfo
		}
	case *ConfigInfoA_PreferredNode:
		if value != nil {
			return value.PreferredNode
		}
	}
	return nil
}

type is_ConfigInfoA_ConfigInfoA interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ConfigInfoA_ConfigInfoA()
}

func (o *ConfigInfoA_ConfigInfoA) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ConfigInfoA_Description:
		return uint32(1)
	case *ConfigInfoA_FailureActions:
		return uint32(2)
	case *ConfigInfoA_DelayedAutoStart:
		return uint32(3)
	case *ConfigInfoA_FailureActionsFlag:
		return uint32(4)
	case *ConfigInfoA_SIDInfo:
		return uint32(5)
	case *ConfigInfoA_RequiredPrivileges:
		return uint32(6)
	case *ConfigInfoA_Preshutdown:
		return uint32(7)
	case *ConfigInfoA_TriggerInfo:
		return uint32(8)
	case *ConfigInfoA_PreferredNode:
		return uint32(9)
	}
	return uint32(0)
}

func (o *ConfigInfoA_ConfigInfoA) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ConfigInfoA_Description)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_Description{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ConfigInfoA_FailureActions)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_FailureActions{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*ConfigInfoA_DelayedAutoStart)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_DelayedAutoStart{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*ConfigInfoA_FailureActionsFlag)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_FailureActionsFlag{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*ConfigInfoA_SIDInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_SIDInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*ConfigInfoA_RequiredPrivileges)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_RequiredPrivileges{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*ConfigInfoA_Preshutdown)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_Preshutdown{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*ConfigInfoA_TriggerInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_TriggerInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(9):
		_o, _ := o.Value.(*ConfigInfoA_PreferredNode)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA_PreferredNode{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ConfigInfoA_ConfigInfoA) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ConfigInfoA_Description{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ConfigInfoA_FailureActions{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &ConfigInfoA_DelayedAutoStart{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &ConfigInfoA_FailureActionsFlag{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &ConfigInfoA_SIDInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &ConfigInfoA_RequiredPrivileges{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &ConfigInfoA_Preshutdown{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &ConfigInfoA_TriggerInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(9):
		o.Value = &ConfigInfoA_PreferredNode{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ConfigInfoA_Description structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 1
type ConfigInfoA_Description struct {
	// psd:  A structure that contains a description of the service, as specified in section
	// 2.2.34.
	//
	// The following structures SHOULD<2> be available:
	Description *ServiceDescriptionA `idl:"name:psd" json:"description"`
}

func (*ConfigInfoA_Description) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_Description) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Description != nil {
		_ptr_psd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Description != nil {
				if err := o.Description.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceDescriptionA{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Description, _ptr_psd); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_Description) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Description == nil {
			o.Description = &ServiceDescriptionA{}
		}
		if err := o.Description.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psd := func(ptr interface{}) { o.Description = *ptr.(**ServiceDescriptionA) }
	if err := w.ReadPointer(&o.Description, _s_psd, _ptr_psd); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_FailureActions structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 2
type ConfigInfoA_FailureActions struct {
	// psfa:  A structure that contains a list of failure actions, as specified in section
	// 2.2.39.
	FailureActions *ServiceFailureActionsA `idl:"name:psfa" json:"failure_actions"`
}

func (*ConfigInfoA_FailureActions) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_FailureActions) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FailureActions != nil {
		_ptr_psfa := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FailureActions != nil {
				if err := o.FailureActions.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceFailureActionsA{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FailureActions, _ptr_psfa); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_FailureActions) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psfa := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FailureActions == nil {
			o.FailureActions = &ServiceFailureActionsA{}
		}
		if err := o.FailureActions.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psfa := func(ptr interface{}) { o.FailureActions = *ptr.(**ServiceFailureActionsA) }
	if err := w.ReadPointer(&o.FailureActions, _s_psfa, _ptr_psfa); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_DelayedAutoStart structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 3
type ConfigInfoA_DelayedAutoStart struct {
	// psda:  A structure that defines whether or not the service is part of the delayed
	// start group, as specified in section 2.2.33.
	DelayedAutoStart *ServiceDelayedAutoStartInfo `idl:"name:psda" json:"delayed_auto_start"`
}

func (*ConfigInfoA_DelayedAutoStart) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_DelayedAutoStart) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DelayedAutoStart != nil {
		_ptr_psda := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DelayedAutoStart != nil {
				if err := o.DelayedAutoStart.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceDelayedAutoStartInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DelayedAutoStart, _ptr_psda); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_DelayedAutoStart) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psda := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DelayedAutoStart == nil {
			o.DelayedAutoStart = &ServiceDelayedAutoStartInfo{}
		}
		if err := o.DelayedAutoStart.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psda := func(ptr interface{}) { o.DelayedAutoStart = *ptr.(**ServiceDelayedAutoStartInfo) }
	if err := w.ReadPointer(&o.DelayedAutoStart, _s_psda, _ptr_psda); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_FailureActionsFlag structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 4
type ConfigInfoA_FailureActionsFlag struct {
	// psfaf:  A structure that defines if failure actions are queued when the service exits
	// with a nonzero error code, as specified in section 2.2.41.
	FailureActionsFlag *ServiceFailureActionsFlag `idl:"name:psfaf" json:"failure_actions_flag"`
}

func (*ConfigInfoA_FailureActionsFlag) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_FailureActionsFlag) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FailureActionsFlag != nil {
		_ptr_psfaf := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FailureActionsFlag != nil {
				if err := o.FailureActionsFlag.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceFailureActionsFlag{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FailureActionsFlag, _ptr_psfaf); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_FailureActionsFlag) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psfaf := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FailureActionsFlag == nil {
			o.FailureActionsFlag = &ServiceFailureActionsFlag{}
		}
		if err := o.FailureActionsFlag.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psfaf := func(ptr interface{}) { o.FailureActionsFlag = *ptr.(**ServiceFailureActionsFlag) }
	if err := w.ReadPointer(&o.FailureActionsFlag, _s_psfaf, _ptr_psfaf); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_SIDInfo structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 5
type ConfigInfoA_SIDInfo struct {
	// pssid:  A structure that defines the type of service SID, as specified in section
	// 2.2.46.
	SIDInfo *ServiceSIDInfo `idl:"name:pssid" json:"sid_info"`
}

func (*ConfigInfoA_SIDInfo) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_SIDInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SIDInfo != nil {
		_ptr_pssid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SIDInfo != nil {
				if err := o.SIDInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceSIDInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SIDInfo, _ptr_pssid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_SIDInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pssid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SIDInfo == nil {
			o.SIDInfo = &ServiceSIDInfo{}
		}
		if err := o.SIDInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pssid := func(ptr interface{}) { o.SIDInfo = *ptr.(**ServiceSIDInfo) }
	if err := w.ReadPointer(&o.SIDInfo, _s_pssid, _ptr_pssid); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_RequiredPrivileges structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 6
type ConfigInfoA_RequiredPrivileges struct {
	// psrp:  A structure that defines the privileges required by the service, as specified
	// in section 2.2.48.
	RequiredPrivileges *RequiredPrivilegesInfo `idl:"name:psrp" json:"required_privileges"`
}

func (*ConfigInfoA_RequiredPrivileges) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_RequiredPrivileges) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.RequiredPrivileges != nil {
		_ptr_psrp := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.RequiredPrivileges != nil {
				if err := o.RequiredPrivileges.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RequiredPrivilegesInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.RequiredPrivileges, _ptr_psrp); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_RequiredPrivileges) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrp := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.RequiredPrivileges == nil {
			o.RequiredPrivileges = &RequiredPrivilegesInfo{}
		}
		if err := o.RequiredPrivileges.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrp := func(ptr interface{}) { o.RequiredPrivileges = *ptr.(**RequiredPrivilegesInfo) }
	if err := w.ReadPointer(&o.RequiredPrivileges, _s_psrp, _ptr_psrp); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_Preshutdown structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 7
type ConfigInfoA_Preshutdown struct {
	// psps:  A structure that defines the pre-shutdown settings for the service, as specified
	// in section 2.2.45.
	Preshutdown *ServicePreshutdownInfo `idl:"name:psps" json:"preshutdown"`
}

func (*ConfigInfoA_Preshutdown) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_Preshutdown) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Preshutdown != nil {
		_ptr_psps := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Preshutdown != nil {
				if err := o.Preshutdown.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServicePreshutdownInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Preshutdown, _ptr_psps); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_Preshutdown) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psps := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Preshutdown == nil {
			o.Preshutdown = &ServicePreshutdownInfo{}
		}
		if err := o.Preshutdown.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psps := func(ptr interface{}) { o.Preshutdown = *ptr.(**ServicePreshutdownInfo) }
	if err := w.ReadPointer(&o.Preshutdown, _s_psps, _ptr_psps); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_TriggerInfo structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 8
type ConfigInfoA_TriggerInfo struct {
	// psti:  A structure that defines the trigger settings for the service, as specified
	// in section 2.2.54.
	TriggerInfo *ServiceTriggerInfo `idl:"name:psti" json:"trigger_info"`
}

func (*ConfigInfoA_TriggerInfo) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_TriggerInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.TriggerInfo != nil {
		_ptr_psti := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.TriggerInfo != nil {
				if err := o.TriggerInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceTriggerInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TriggerInfo, _ptr_psti); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_TriggerInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psti := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.TriggerInfo == nil {
			o.TriggerInfo = &ServiceTriggerInfo{}
		}
		if err := o.TriggerInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psti := func(ptr interface{}) { o.TriggerInfo = *ptr.(**ServiceTriggerInfo) }
	if err := w.ReadPointer(&o.TriggerInfo, _s_psti, _ptr_psti); err != nil {
		return err
	}
	return nil
}

// ConfigInfoA_PreferredNode structure represents ConfigInfoA_ConfigInfoA RPC union arm.
//
// It has following labels: 9
type ConfigInfoA_PreferredNode struct {
	// pspn:  A structure that defines the preferred node information for the service, as
	// specified in section 2.2.55.
	PreferredNode *ServicePreferredNodeInfo `idl:"name:pspn" json:"preferred_node"`
}

func (*ConfigInfoA_PreferredNode) is_ConfigInfoA_ConfigInfoA() {}

func (o *ConfigInfoA_PreferredNode) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.PreferredNode != nil {
		_ptr_pspn := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PreferredNode != nil {
				if err := o.PreferredNode.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServicePreferredNodeInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PreferredNode, _ptr_pspn); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoA_PreferredNode) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pspn := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PreferredNode == nil {
			o.PreferredNode = &ServicePreferredNodeInfo{}
		}
		if err := o.PreferredNode.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pspn := func(ptr interface{}) { o.PreferredNode = *ptr.(**ServicePreferredNodeInfo) }
	if err := w.ReadPointer(&o.PreferredNode, _s_pspn, _ptr_pspn); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW structure represents SC_RPC_CONFIG_INFOW RPC structure.
//
// The SC_RPC_CONFIG_INFOW structure SHOULD<3> define, based on a supplied level, either
// the service configuration or a list of failure actions. String values are stored
// as Unicode.
type ConfigInfoW struct {
	// dwInfoLevel:  A value that indicates the type of configuration information in the
	// included data.
	InfoLevel   uint32                   `idl:"name:dwInfoLevel" json:"info_level"`
	ConfigInfoW *ConfigInfoW_ConfigInfoW `idl:"name:ConfigInfoW;switch_is:dwInfoLevel" json:"config_info_w"`
}

func (o *ConfigInfoW) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoLevel); err != nil {
		return err
	}
	_swConfigInfoW := uint32(o.InfoLevel)
	if o.ConfigInfoW != nil {
		if err := o.ConfigInfoW.MarshalUnionNDR(ctx, w, _swConfigInfoW); err != nil {
			return err
		}
	} else {
		if err := (&ConfigInfoW_ConfigInfoW{}).MarshalUnionNDR(ctx, w, _swConfigInfoW); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoLevel); err != nil {
		return err
	}
	if o.ConfigInfoW == nil {
		o.ConfigInfoW = &ConfigInfoW_ConfigInfoW{}
	}
	_swConfigInfoW := uint32(o.InfoLevel)
	if err := o.ConfigInfoW.UnmarshalUnionNDR(ctx, w, _swConfigInfoW); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_ConfigInfoW structure represents SC_RPC_CONFIG_INFOW union anonymous member.
//
// The SC_RPC_CONFIG_INFOW structure SHOULD<3> define, based on a supplied level, either
// the service configuration or a list of failure actions. String values are stored
// as Unicode.
type ConfigInfoW_ConfigInfoW struct {
	// Types that are assignable to Value
	//
	// *ConfigInfoW_Description
	// *ConfigInfoW_FailureActions
	// *ConfigInfoW_DelayedAutoStart
	// *ConfigInfoW_FailureActionsFlag
	// *ConfigInfoW_SIDInfo
	// *ConfigInfoW_RequiredPrivileges
	// *ConfigInfoW_Preshutdown
	// *ConfigInfoW_TriggerInfo
	// *ConfigInfoW_PreferredNode
	Value is_ConfigInfoW_ConfigInfoW `json:"value"`
}

func (o *ConfigInfoW_ConfigInfoW) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ConfigInfoW_Description:
		if value != nil {
			return value.Description
		}
	case *ConfigInfoW_FailureActions:
		if value != nil {
			return value.FailureActions
		}
	case *ConfigInfoW_DelayedAutoStart:
		if value != nil {
			return value.DelayedAutoStart
		}
	case *ConfigInfoW_FailureActionsFlag:
		if value != nil {
			return value.FailureActionsFlag
		}
	case *ConfigInfoW_SIDInfo:
		if value != nil {
			return value.SIDInfo
		}
	case *ConfigInfoW_RequiredPrivileges:
		if value != nil {
			return value.RequiredPrivileges
		}
	case *ConfigInfoW_Preshutdown:
		if value != nil {
			return value.Preshutdown
		}
	case *ConfigInfoW_TriggerInfo:
		if value != nil {
			return value.TriggerInfo
		}
	case *ConfigInfoW_PreferredNode:
		if value != nil {
			return value.PreferredNode
		}
	}
	return nil
}

type is_ConfigInfoW_ConfigInfoW interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ConfigInfoW_ConfigInfoW()
}

func (o *ConfigInfoW_ConfigInfoW) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ConfigInfoW_Description:
		return uint32(1)
	case *ConfigInfoW_FailureActions:
		return uint32(2)
	case *ConfigInfoW_DelayedAutoStart:
		return uint32(3)
	case *ConfigInfoW_FailureActionsFlag:
		return uint32(4)
	case *ConfigInfoW_SIDInfo:
		return uint32(5)
	case *ConfigInfoW_RequiredPrivileges:
		return uint32(6)
	case *ConfigInfoW_Preshutdown:
		return uint32(7)
	case *ConfigInfoW_TriggerInfo:
		return uint32(8)
	case *ConfigInfoW_PreferredNode:
		return uint32(9)
	}
	return uint32(0)
}

func (o *ConfigInfoW_ConfigInfoW) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ConfigInfoW_Description)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_Description{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ConfigInfoW_FailureActions)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_FailureActions{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*ConfigInfoW_DelayedAutoStart)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_DelayedAutoStart{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*ConfigInfoW_FailureActionsFlag)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_FailureActionsFlag{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*ConfigInfoW_SIDInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_SIDInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*ConfigInfoW_RequiredPrivileges)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_RequiredPrivileges{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*ConfigInfoW_Preshutdown)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_Preshutdown{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*ConfigInfoW_TriggerInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_TriggerInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(9):
		_o, _ := o.Value.(*ConfigInfoW_PreferredNode)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW_PreferredNode{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ConfigInfoW_ConfigInfoW) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ConfigInfoW_Description{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ConfigInfoW_FailureActions{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &ConfigInfoW_DelayedAutoStart{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &ConfigInfoW_FailureActionsFlag{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &ConfigInfoW_SIDInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &ConfigInfoW_RequiredPrivileges{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &ConfigInfoW_Preshutdown{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &ConfigInfoW_TriggerInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(9):
		o.Value = &ConfigInfoW_PreferredNode{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ConfigInfoW_Description structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 1
type ConfigInfoW_Description struct {
	// psd:  A structure that contains a description of the service, as specified in section
	// 2.2.35.
	Description *ServiceDescriptionW `idl:"name:psd" json:"description"`
}

func (*ConfigInfoW_Description) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_Description) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Description != nil {
		_ptr_psd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Description != nil {
				if err := o.Description.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceDescriptionW{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Description, _ptr_psd); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_Description) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Description == nil {
			o.Description = &ServiceDescriptionW{}
		}
		if err := o.Description.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psd := func(ptr interface{}) { o.Description = *ptr.(**ServiceDescriptionW) }
	if err := w.ReadPointer(&o.Description, _s_psd, _ptr_psd); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_FailureActions structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 2
type ConfigInfoW_FailureActions struct {
	// psfa:  A structure that contains a list of failure actions, as specified in section
	// 2.2.40.
	FailureActions *ServiceFailureActionsW `idl:"name:psfa" json:"failure_actions"`
}

func (*ConfigInfoW_FailureActions) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_FailureActions) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FailureActions != nil {
		_ptr_psfa := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FailureActions != nil {
				if err := o.FailureActions.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceFailureActionsW{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FailureActions, _ptr_psfa); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_FailureActions) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psfa := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FailureActions == nil {
			o.FailureActions = &ServiceFailureActionsW{}
		}
		if err := o.FailureActions.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psfa := func(ptr interface{}) { o.FailureActions = *ptr.(**ServiceFailureActionsW) }
	if err := w.ReadPointer(&o.FailureActions, _s_psfa, _ptr_psfa); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_DelayedAutoStart structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 3
type ConfigInfoW_DelayedAutoStart struct {
	// psda:  A structure that specifies whether the service is part of the delayed start
	// group, as specified in section 2.2.33.
	DelayedAutoStart *ServiceDelayedAutoStartInfo `idl:"name:psda" json:"delayed_auto_start"`
}

func (*ConfigInfoW_DelayedAutoStart) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_DelayedAutoStart) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DelayedAutoStart != nil {
		_ptr_psda := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DelayedAutoStart != nil {
				if err := o.DelayedAutoStart.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceDelayedAutoStartInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DelayedAutoStart, _ptr_psda); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_DelayedAutoStart) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psda := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DelayedAutoStart == nil {
			o.DelayedAutoStart = &ServiceDelayedAutoStartInfo{}
		}
		if err := o.DelayedAutoStart.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psda := func(ptr interface{}) { o.DelayedAutoStart = *ptr.(**ServiceDelayedAutoStartInfo) }
	if err := w.ReadPointer(&o.DelayedAutoStart, _s_psda, _ptr_psda); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_FailureActionsFlag structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 4
type ConfigInfoW_FailureActionsFlag struct {
	// psfaf:  A structure that specifies whether failure actions are queued when the service
	// exits with a nonzero error code, as specified in section 2.2.41.
	FailureActionsFlag *ServiceFailureActionsFlag `idl:"name:psfaf" json:"failure_actions_flag"`
}

func (*ConfigInfoW_FailureActionsFlag) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_FailureActionsFlag) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FailureActionsFlag != nil {
		_ptr_psfaf := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FailureActionsFlag != nil {
				if err := o.FailureActionsFlag.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceFailureActionsFlag{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FailureActionsFlag, _ptr_psfaf); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_FailureActionsFlag) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psfaf := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FailureActionsFlag == nil {
			o.FailureActionsFlag = &ServiceFailureActionsFlag{}
		}
		if err := o.FailureActionsFlag.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psfaf := func(ptr interface{}) { o.FailureActionsFlag = *ptr.(**ServiceFailureActionsFlag) }
	if err := w.ReadPointer(&o.FailureActionsFlag, _s_psfaf, _ptr_psfaf); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_SIDInfo structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 5
type ConfigInfoW_SIDInfo struct {
	// pssid:  A structure that defines the type of service SID, as specified in section
	// 2.2.46.
	SIDInfo *ServiceSIDInfo `idl:"name:pssid" json:"sid_info"`
}

func (*ConfigInfoW_SIDInfo) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_SIDInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SIDInfo != nil {
		_ptr_pssid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SIDInfo != nil {
				if err := o.SIDInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceSIDInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SIDInfo, _ptr_pssid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_SIDInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pssid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SIDInfo == nil {
			o.SIDInfo = &ServiceSIDInfo{}
		}
		if err := o.SIDInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pssid := func(ptr interface{}) { o.SIDInfo = *ptr.(**ServiceSIDInfo) }
	if err := w.ReadPointer(&o.SIDInfo, _s_pssid, _ptr_pssid); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_RequiredPrivileges structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 6
type ConfigInfoW_RequiredPrivileges struct {
	// psrp:  A structure that defines the privileges required by the service, as specified
	// in section 2.2.48.
	RequiredPrivileges *RequiredPrivilegesInfo `idl:"name:psrp" json:"required_privileges"`
}

func (*ConfigInfoW_RequiredPrivileges) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_RequiredPrivileges) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.RequiredPrivileges != nil {
		_ptr_psrp := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.RequiredPrivileges != nil {
				if err := o.RequiredPrivileges.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RequiredPrivilegesInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.RequiredPrivileges, _ptr_psrp); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_RequiredPrivileges) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrp := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.RequiredPrivileges == nil {
			o.RequiredPrivileges = &RequiredPrivilegesInfo{}
		}
		if err := o.RequiredPrivileges.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrp := func(ptr interface{}) { o.RequiredPrivileges = *ptr.(**RequiredPrivilegesInfo) }
	if err := w.ReadPointer(&o.RequiredPrivileges, _s_psrp, _ptr_psrp); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_Preshutdown structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 7
type ConfigInfoW_Preshutdown struct {
	// psps:  A structure that defines the pre-shutdown settings for the service, as specified
	// in section 2.2.45.
	Preshutdown *ServicePreshutdownInfo `idl:"name:psps" json:"preshutdown"`
}

func (*ConfigInfoW_Preshutdown) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_Preshutdown) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Preshutdown != nil {
		_ptr_psps := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Preshutdown != nil {
				if err := o.Preshutdown.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServicePreshutdownInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Preshutdown, _ptr_psps); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_Preshutdown) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psps := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Preshutdown == nil {
			o.Preshutdown = &ServicePreshutdownInfo{}
		}
		if err := o.Preshutdown.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psps := func(ptr interface{}) { o.Preshutdown = *ptr.(**ServicePreshutdownInfo) }
	if err := w.ReadPointer(&o.Preshutdown, _s_psps, _ptr_psps); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_TriggerInfo structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 8
type ConfigInfoW_TriggerInfo struct {
	// psti:  A structure that defines the trigger settings for the service, as specified
	// in section 2.2.54.<4>
	TriggerInfo *ServiceTriggerInfo `idl:"name:psti" json:"trigger_info"`
}

func (*ConfigInfoW_TriggerInfo) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_TriggerInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.TriggerInfo != nil {
		_ptr_psti := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.TriggerInfo != nil {
				if err := o.TriggerInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceTriggerInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TriggerInfo, _ptr_psti); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_TriggerInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psti := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.TriggerInfo == nil {
			o.TriggerInfo = &ServiceTriggerInfo{}
		}
		if err := o.TriggerInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psti := func(ptr interface{}) { o.TriggerInfo = *ptr.(**ServiceTriggerInfo) }
	if err := w.ReadPointer(&o.TriggerInfo, _s_psti, _ptr_psti); err != nil {
		return err
	}
	return nil
}

// ConfigInfoW_PreferredNode structure represents ConfigInfoW_ConfigInfoW RPC union arm.
//
// It has following labels: 9
type ConfigInfoW_PreferredNode struct {
	// pspn:  A structure that defines the preferred node information for the service, as
	// specified in section 2.2.55.<5>
	PreferredNode *ServicePreferredNodeInfo `idl:"name:pspn" json:"preferred_node"`
}

func (*ConfigInfoW_PreferredNode) is_ConfigInfoW_ConfigInfoW() {}

func (o *ConfigInfoW_PreferredNode) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.PreferredNode != nil {
		_ptr_pspn := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PreferredNode != nil {
				if err := o.PreferredNode.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServicePreferredNodeInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PreferredNode, _ptr_pspn); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConfigInfoW_PreferredNode) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pspn := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PreferredNode == nil {
			o.PreferredNode = &ServicePreferredNodeInfo{}
		}
		if err := o.PreferredNode.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pspn := func(ptr interface{}) { o.PreferredNode = *ptr.(**ServicePreferredNodeInfo) }
	if err := w.ReadPointer(&o.PreferredNode, _s_pspn, _ptr_pspn); err != nil {
		return err
	}
	return nil
}

// ServiceNotifyStatusChangeParams1 structure represents SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1 RPC structure.
//
// The SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1 structure defines the service status notification
// information. If a client uses this structure, the server copies data from this structure
// to the newer structure specified in 2.2.44, and uses the newer structure.
type ServiceNotifyStatusChangeParams1 struct {
	// ullThreadId:  Not used.
	ThreadID uint64 `idl:"name:ullThreadId" json:"thread_id"`
	// dwNotifyMask:  A value that specifies the status changes in which the client is interested.
	// It MUST be one or more of the following values.
	//
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	|                                            |                                                                 |
	//	|                   VALUE                    |                             MEANING                             |
	//	|                                            |                                                                 |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_CREATED 0x00000080          | Report when the service has been created.                       |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_CONTINUE_PENDING 0x00000010 | Report when the service is about to continue.                   |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_DELETE_PENDING 0x00000200   | Report when an application has specified the service to delete. |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_DELETED 0x00000100          | Report when the service has been deleted.                       |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_PAUSE_PENDING 0x00000020    | Report when the service is pausing.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_PAUSED 0x00000040           | Report when the service has paused.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_RUNNING 0x00000008          | Report when the service is running.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_START_PENDING 0x00000002    | Report when the service is starting.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_STOP_PENDING 0x00000004     | Report when the service is stopping.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_STOPPED 0x00000001          | Report when the service has stopped.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	NotifyMask uint32 `idl:"name:dwNotifyMask" json:"notify_mask"`
	// CallbackAddressArray:  Not used.
	CallbackAddressArray []byte `idl:"name:CallbackAddressArray" json:"callback_address_array"`
	// CallbackParamAddressArray:  Not used.
	CallbackParamAddressArray []byte `idl:"name:CallbackParamAddressArray" json:"callback_param_address_array"`
	// ServiceStatus:  A SERVICE_STATUS_PROCESS (section 2.2.49) structure that contains
	// information about the service.
	ServiceStatus *ServiceStatusProcess `idl:"name:ServiceStatus" json:"service_status"`
	// dwNotificationStatus:  A value that indicates the notification status. If this member
	// is ERROR_SUCCESS, the notification has succeeded and the server adds valid information
	// to the ServiceStatus, dwNotificationTriggered, and pszServiceNames members. If this
	// member is ERROR_REQUEST_ABORTED or ERROR_SERVICE_MARKED_FOR_DELETE, the notification
	// has failed.
	NotificationStatus uint32 `idl:"name:dwNotificationStatus" json:"notification_status"`
	// dwSequence:  Not used.
	Sequence uint32 `idl:"name:dwSequence" json:"sequence"`
}

func (o *ServiceNotifyStatusChangeParams1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadID); err != nil {
		return err
	}
	if err := w.WriteData(o.NotifyMask); err != nil {
		return err
	}
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackParamAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NotificationStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.Sequence); err != nil {
		return err
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadID); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotifyMask); err != nil {
		return err
	}
	o.CallbackAddressArray = make([]byte, 16)
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	o.CallbackParamAddressArray = make([]byte, 16)
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.Sequence); err != nil {
		return err
	}
	return nil
}

// ServiceNotifyStatusChangeParams2 structure represents SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 RPC structure.
//
// The SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 structure<14> defines the service status
// notification information.
type ServiceNotifyStatusChangeParams2 struct {
	// ullThreadId:  Not used.
	ThreadID uint64 `idl:"name:ullThreadId" json:"thread_id"`
	// dwNotifyMask:  A value that specifies the status changes in which the client is interested.
	// It MUST be one or more of the following values.
	//
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	|                                            |                                                                 |
	//	|                   VALUE                    |                             MEANING                             |
	//	|                                            |                                                                 |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_CREATED 0x00000080          | Report when the service has been created.                       |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_CONTINUE_PENDING 0x00000010 | Report when the service is about to continue.                   |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_DELETE_PENDING 0x00000200   | Report when an application has specified the service to delete. |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_DELETED 0x00000100          | Report when the service has been deleted.                       |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_PAUSE_PENDING 0x00000020    | Report when the service is pausing.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_PAUSED 0x00000040           | Report when the service has paused.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_RUNNING 0x00000008          | Report when the service is running.                             |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_START_PENDING 0x00000002    | Report when the service is starting.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_STOP_PENDING 0x00000004     | Report when the service is stopping.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	//	| SERVICE_NOTIFY_STOPPED 0x00000001          | Report when the service has stopped.                            |
	//	+--------------------------------------------+-----------------------------------------------------------------+
	NotifyMask uint32 `idl:"name:dwNotifyMask" json:"notify_mask"`
	// CallbackAddressArray:  Not used.
	CallbackAddressArray []byte `idl:"name:CallbackAddressArray" json:"callback_address_array"`
	// CallbackParamAddressArray:  Not used.
	CallbackParamAddressArray []byte `idl:"name:CallbackParamAddressArray" json:"callback_param_address_array"`
	// ServiceStatus:  A SERVICE_STATUS_PROCESS (section 2.2.49) structure that contains
	// information about the service.
	ServiceStatus *ServiceStatusProcess `idl:"name:ServiceStatus" json:"service_status"`
	// dwNotificationStatus:  A value that indicates the notification status. If this member
	// is ERROR_SUCCESS, the notification has succeeded and the server adds valid information
	// to the ServiceStatus, dwNotificationTriggered, and pszServiceNames members. If this
	// member is ERROR_REQUEST_ABORTED or ERROR_SERVICE_MARKED_FOR_DELETE, the notification
	// has failed.
	NotificationStatus uint32 `idl:"name:dwNotificationStatus" json:"notification_status"`
	// dwSequence:  Not used.
	Sequence uint32 `idl:"name:dwSequence" json:"sequence"`
	// dwNotificationTriggered:  The value that specifies the specific status change event
	// that triggered the notification to the client. This MUST be one or more of the values
	// specified in the dwNotifyMask parameter.
	NotificationTriggered uint32 `idl:"name:dwNotificationTriggered" json:"notification_triggered"`
	// pszServiceNames:  A pointer to a sequence of null-terminated strings, terminated
	// by an empty string (\0) that contains the name of the service that was created or
	// deleted.
	//
	// The forward slash, back slash, comma, and space characters are illegal in service
	// names.
	ServiceNames string `idl:"name:pszServiceNames;string" json:"service_names"`
}

func (o *ServiceNotifyStatusChangeParams2) xxx_PreparePayload(ctx context.Context) error {
	if len(o.ServiceNames) > int(65536) {
		return fmt.Errorf("ServiceNames is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadID); err != nil {
		return err
	}
	if err := w.WriteData(o.NotifyMask); err != nil {
		return err
	}
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackParamAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NotificationStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.Sequence); err != nil {
		return err
	}
	if err := w.WriteData(o.NotificationTriggered); err != nil {
		return err
	}
	if o.ServiceNames != "" {
		_ptr_pszServiceNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServiceNames); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceNames, _ptr_pszServiceNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadID); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotifyMask); err != nil {
		return err
	}
	o.CallbackAddressArray = make([]byte, 16)
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	o.CallbackParamAddressArray = make([]byte, 16)
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.Sequence); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationTriggered); err != nil {
		return err
	}
	_ptr_pszServiceNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceNames); err != nil {
			return err
		}
		return nil
	})
	_s_pszServiceNames := func(ptr interface{}) { o.ServiceNames = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceNames, _s_pszServiceNames, _ptr_pszServiceNames); err != nil {
		return err
	}
	return nil
}

// ServiceNotifyStatusChangeParams structure represents SERVICE_NOTIFY_STATUS_CHANGE_PARAMS RPC structure.
type ServiceNotifyStatusChangeParams ServiceNotifyStatusChangeParams2

func (o *ServiceNotifyStatusChangeParams) ServiceNotifyStatusChangeParams2() *ServiceNotifyStatusChangeParams2 {
	return (*ServiceNotifyStatusChangeParams2)(o)
}

func (o *ServiceNotifyStatusChangeParams) xxx_PreparePayload(ctx context.Context) error {
	if len(o.ServiceNames) > int(65536) {
		return fmt.Errorf("ServiceNames is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadID); err != nil {
		return err
	}
	if err := w.WriteData(o.NotifyMask); err != nil {
		return err
	}
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CallbackParamAddressArray); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NotificationStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.Sequence); err != nil {
		return err
	}
	if err := w.WriteData(o.NotificationTriggered); err != nil {
		return err
	}
	if o.ServiceNames != "" {
		_ptr_pszServiceNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServiceNames); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServiceNames, _ptr_pszServiceNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceNotifyStatusChangeParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadID); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotifyMask); err != nil {
		return err
	}
	o.CallbackAddressArray = make([]byte, 16)
	for i1 := range o.CallbackAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackAddressArray[i1]); err != nil {
			return err
		}
	}
	o.CallbackParamAddressArray = make([]byte, 16)
	for i1 := range o.CallbackParamAddressArray {
		i1 := i1
		if err := w.ReadData(&o.CallbackParamAddressArray[i1]); err != nil {
			return err
		}
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.Sequence); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationTriggered); err != nil {
		return err
	}
	_ptr_pszServiceNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceNames); err != nil {
			return err
		}
		return nil
	})
	_s_pszServiceNames := func(ptr interface{}) { o.ServiceNames = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServiceNames, _s_pszServiceNames, _ptr_pszServiceNames); err != nil {
		return err
	}
	return nil
}

// NotifyParams structure represents SC_RPC_NOTIFY_PARAMS RPC structure.
//
// The SC_RPC_NOTIFY_PARAMS structure<6> contains the parameters associated with the
// notification information of the service status.
type NotifyParams struct {
	// dwInfoLevel:  A value that indicates the version of the notification structure being
	// used.
	InfoLevel    uint32                     `idl:"name:dwInfoLevel" json:"info_level"`
	NotifyParams *NotifyParams_NotifyParams `idl:"name:NotifyParams;switch_is:dwInfoLevel" json:"notify_params"`
}

func (o *NotifyParams) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoLevel); err != nil {
		return err
	}
	_swNotifyParams := uint32(o.InfoLevel)
	if o.NotifyParams != nil {
		if err := o.NotifyParams.MarshalUnionNDR(ctx, w, _swNotifyParams); err != nil {
			return err
		}
	} else {
		if err := (&NotifyParams_NotifyParams{}).MarshalUnionNDR(ctx, w, _swNotifyParams); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoLevel); err != nil {
		return err
	}
	if o.NotifyParams == nil {
		o.NotifyParams = &NotifyParams_NotifyParams{}
	}
	_swNotifyParams := uint32(o.InfoLevel)
	if err := o.NotifyParams.UnmarshalUnionNDR(ctx, w, _swNotifyParams); err != nil {
		return err
	}
	return nil
}

// NotifyParams_NotifyParams structure represents SC_RPC_NOTIFY_PARAMS union anonymous member.
//
// The SC_RPC_NOTIFY_PARAMS structure<6> contains the parameters associated with the
// notification information of the service status.
type NotifyParams_NotifyParams struct {
	// Types that are assignable to Value
	//
	// *NotifyParams_StatusChangeParam1
	// *NotifyParams_StatusChangeParams
	Value is_NotifyParams_NotifyParams `json:"value"`
}

func (o *NotifyParams_NotifyParams) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *NotifyParams_StatusChangeParam1:
		if value != nil {
			return value.StatusChangeParam1
		}
	case *NotifyParams_StatusChangeParams:
		if value != nil {
			return value.StatusChangeParams
		}
	}
	return nil
}

type is_NotifyParams_NotifyParams interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_NotifyParams_NotifyParams()
}

func (o *NotifyParams_NotifyParams) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *NotifyParams_StatusChangeParam1:
		return uint32(1)
	case *NotifyParams_StatusChangeParams:
		return uint32(2)
	}
	return uint32(0)
}

func (o *NotifyParams_NotifyParams) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*NotifyParams_StatusChangeParam1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NotifyParams_StatusChangeParam1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*NotifyParams_StatusChangeParams)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NotifyParams_StatusChangeParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *NotifyParams_NotifyParams) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &NotifyParams_StatusChangeParam1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &NotifyParams_StatusChangeParams{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// NotifyParams_StatusChangeParam1 structure represents NotifyParams_NotifyParams RPC union arm.
//
// It has following labels: 1
type NotifyParams_StatusChangeParam1 struct {
	// pStatusChangeParam1:  A SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1 (section 2.2.43) structure
	// that contains the service status notification information.
	StatusChangeParam1 *ServiceNotifyStatusChangeParams1 `idl:"name:pStatusChangeParam1" json:"status_change_param1"`
}

func (*NotifyParams_StatusChangeParam1) is_NotifyParams_NotifyParams() {}

func (o *NotifyParams_StatusChangeParam1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusChangeParam1 != nil {
		_ptr_pStatusChangeParam1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusChangeParam1 != nil {
				if err := o.StatusChangeParam1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceNotifyStatusChangeParams1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusChangeParam1, _ptr_pStatusChangeParam1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyParams_StatusChangeParam1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pStatusChangeParam1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusChangeParam1 == nil {
			o.StatusChangeParam1 = &ServiceNotifyStatusChangeParams1{}
		}
		if err := o.StatusChangeParam1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pStatusChangeParam1 := func(ptr interface{}) { o.StatusChangeParam1 = *ptr.(**ServiceNotifyStatusChangeParams1) }
	if err := w.ReadPointer(&o.StatusChangeParam1, _s_pStatusChangeParam1, _ptr_pStatusChangeParam1); err != nil {
		return err
	}
	return nil
}

// NotifyParams_StatusChangeParams structure represents NotifyParams_NotifyParams RPC union arm.
//
// It has following labels: 2
type NotifyParams_StatusChangeParams struct {
	// pStatusChangeParams:  A SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 (section 2.2.44) structure
	// that contains the service status notification information.
	StatusChangeParams *ServiceNotifyStatusChangeParams2 `idl:"name:pStatusChangeParams" json:"status_change_params"`
}

func (*NotifyParams_StatusChangeParams) is_NotifyParams_NotifyParams() {}

func (o *NotifyParams_StatusChangeParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusChangeParams != nil {
		_ptr_pStatusChangeParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusChangeParams != nil {
				if err := o.StatusChangeParams.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceNotifyStatusChangeParams2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusChangeParams, _ptr_pStatusChangeParams); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyParams_StatusChangeParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pStatusChangeParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusChangeParams == nil {
			o.StatusChangeParams = &ServiceNotifyStatusChangeParams2{}
		}
		if err := o.StatusChangeParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pStatusChangeParams := func(ptr interface{}) { o.StatusChangeParams = *ptr.(**ServiceNotifyStatusChangeParams2) }
	if err := w.ReadPointer(&o.StatusChangeParams, _s_pStatusChangeParams, _ptr_pStatusChangeParams); err != nil {
		return err
	}
	return nil
}

// NotifyParamsList structure represents SC_RPC_NOTIFY_PARAMS_LIST RPC structure.
//
// The SC_RPC_NOTIFY_PARAMS_LIST structure<7> defines an array of service state change
// parameters.
type NotifyParamsList struct {
	// cElements:  The number of elements in the array.
	ElementsCount uint32 `idl:"name:cElements" json:"elements_count"`
	// NotifyParamsArray:  An array of SC_RPC_NOTIFY_PARAMS (section 2.2.23) structures.
	NotifyParamsArray []*NotifyParams `idl:"name:NotifyParamsArray;size_is:(cElements)" json:"notify_params_array"`
}

func (o *NotifyParamsList) xxx_PreparePayload(ctx context.Context) error {
	if o.NotifyParamsArray != nil && o.ElementsCount == 0 {
		o.ElementsCount = uint32(len(o.NotifyParamsArray))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *NotifyParamsList) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.ElementsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *NotifyParamsList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ElementsCount); err != nil {
		return err
	}
	for i1 := range o.NotifyParamsArray {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.NotifyParamsArray[i1] != nil {
			if err := o.NotifyParamsArray[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NotifyParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.NotifyParamsArray); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&NotifyParams{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NotifyParamsList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ElementsCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.ElementsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.ElementsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.NotifyParamsArray", sizeInfo[0])
	}
	o.NotifyParamsArray = make([]*NotifyParams, sizeInfo[0])
	for i1 := range o.NotifyParamsArray {
		i1 := i1
		if o.NotifyParamsArray[i1] == nil {
			o.NotifyParamsArray[i1] = &NotifyParams{}
		}
		if err := o.NotifyParamsArray[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ServiceControlStatusReasonInParamsA structure represents SERVICE_CONTROL_STATUS_REASON_IN_PARAMSA RPC structure.
//
// The SERVICE_CONTROL_STATUS_REASON_IN_PARAMSA structure<8> contains the reason associated
// with the SERVICE_CONTROL_STOP control. String values are in ANSI.
type ServiceControlStatusReasonInParamsA struct {
	// dwReason:  The reason associated with the SERVICE_CONTROL_STOP control. This member
	// MUST be set to a combination of one general reason code, one major reason code, and
	// one minor reason code.
	//
	// The following are the general reason codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_CUSTOM 0x20000000    | The reason code is defined by the user. If this flag is not present, the         |
	//	|                                   | reason code is defined by the system. If this flag is specified with a           |
	//	|                                   | system reason code, the function call fails. Users can create custom major       |
	//	|                                   | reason codes in the range SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM (0x00400000)      |
	//	|                                   | through SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM (0x00ff0000) and minor reason       |
	//	|                                   | codes in the range SERVICE_STOP_REASON_MINOR_MIN_CUSTOM (0x00000100) through     |
	//	|                                   | SERVICE_STOP_REASON_MINOR_MAX_CUSTOM (0x0000FFFF).                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_PLANNED 0x40000000   | The service stop was planned.                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_UNPLANNED 0x10000000 | The service stop was not planned.                                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// The following are the major reason codes.
	//
	//	+------------------------------------------------------+------------------------+
	//	|                                                      |                        |
	//	|                        VALUE                         |        MEANING         |
	//	|                                                      |                        |
	//	+------------------------------------------------------+------------------------+
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_APPLICATION 0x00050000     | Application issue      |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_HARDWARE 0x00020000        | Hardware issue         |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_NONE 0x00060000            | No major reason        |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM 0x00030000 | Operating system issue |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_OTHER 0x00010000           | Other issue            |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_SOFTWARE 0x00040000        | Software issue         |
	//	+------------------------------------------------------+------------------------+
	//
	// The following are the minor reason codes.
	//
	//	+----------------------------------------------------------------+---------------------------+
	//	|                                                                |                           |
	//	|                             VALUE                              |          MEANING          |
	//	|                                                                |                           |
	//	+----------------------------------------------------------------+---------------------------+
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_DISK 0x00000008                      | Disk                      |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_ENVIRONMENT 0x0000000a               | Environment               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER 0x0000000b           | Driver                    |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_HUNG 0x00000006                      | Unresponsive              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_INSTALLATION 0x00000003              | Installation              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_MAINTENANCE 0x00000002               | Maintenance               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_MMC 0x00000016                       | MMC issue                 |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000011      | Network connectivity      |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NETWORKCARD 0x00000009               | Network card              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NONE 0x00000017                      | No minor reason           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_OTHER 0x00000001                     | Other issue               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_OTHERDRIVER 0x0000000c               | Other driver event        |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_RECONFIG 0x00000005                  | Reconfigure               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITY 0x00000010                  | Security issue            |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITYFIX 0x0000000f               | Security update           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000015     | Security update uninstall |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SERVICEPACK 0x0000000d               | Service pack              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000013     | Service pack uninstall    |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE 0x0000000e           | Software update           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL 0x00000014 | Software update uninstall |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_UNSTABLE 0x00000007                  | Unstable                  |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_UPGRADE 0x00000004                   | Installation of software  |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_WMI 0x00000012                       | WMI issue                 |
	//	+----------------------------------------------------------------+---------------------------+
	Reason uint32 `idl:"name:dwReason" json:"reason"`
	// pszComment:  A pointer to a string that specifies a comment associated with the dwReason
	// parameter. String values are in ANSI.
	Comment string `idl:"name:pszComment;string" json:"comment"`
}

func (o *ServiceControlStatusReasonInParamsA) xxx_PreparePayload(ctx context.Context) error {
	if len(o.Comment) > int(128) {
		return fmt.Errorf("Comment is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonInParamsA) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Reason); err != nil {
		return err
	}
	if o.Comment != "" {
		_ptr_pszComment := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.Comment); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Comment, _ptr_pszComment); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonInParamsA) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Reason); err != nil {
		return err
	}
	_ptr_pszComment := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.Comment); err != nil {
			return err
		}
		return nil
	})
	_s_pszComment := func(ptr interface{}) { o.Comment = *ptr.(*string) }
	if err := w.ReadPointer(&o.Comment, _s_pszComment, _ptr_pszComment); err != nil {
		return err
	}
	return nil
}

// ServiceControlStatusReasonOutParams structure represents SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS RPC structure.
//
// The SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS structure<10> contains the status of
// the service.
type ServiceControlStatusReasonOutParams struct {
	// ServiceStatus:  A SERVICE_STATUS_PROCESS (section 2.2.49) structure that contains
	// the current status of the service.
	ServiceStatus *ServiceStatusProcess `idl:"name:ServiceStatus" json:"service_status"`
}

func (o *ServiceControlStatusReasonOutParams) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonOutParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.ServiceStatus != nil {
		if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceStatusProcess{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonOutParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.ServiceStatus == nil {
		o.ServiceStatus = &ServiceStatusProcess{}
	}
	if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServiceControlInParamsA structure represents SC_RPC_SERVICE_CONTROL_IN_PARAMSA RPC union.
type ServiceControlInParamsA struct {
	// Types that are assignable to Value
	//
	// *ServiceControlInParamsA_StatusReasonInParams
	Value is_ServiceControlInParamsA `json:"value"`
}

func (o *ServiceControlInParamsA) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServiceControlInParamsA_StatusReasonInParams:
		if value != nil {
			return value.StatusReasonInParams
		}
	}
	return nil
}

type is_ServiceControlInParamsA interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServiceControlInParamsA()
}

func (o *ServiceControlInParamsA) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServiceControlInParamsA_StatusReasonInParams:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ServiceControlInParamsA) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ServiceControlInParamsA_StatusReasonInParams)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlInParamsA_StatusReasonInParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServiceControlInParamsA) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ServiceControlInParamsA_StatusReasonInParams{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServiceControlInParamsA_StatusReasonInParams structure represents SC_RPC_SERVICE_CONTROL_IN_PARAMSA RPC union arm.
//
// It has following labels: 1
type ServiceControlInParamsA_StatusReasonInParams struct {
	StatusReasonInParams *ServiceControlStatusReasonInParamsA `idl:"name:psrInParams" json:"status_reason_in_params"`
}

func (*ServiceControlInParamsA_StatusReasonInParams) is_ServiceControlInParamsA() {}

func (o *ServiceControlInParamsA_StatusReasonInParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusReasonInParams != nil {
		_ptr_psrInParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusReasonInParams != nil {
				if err := o.StatusReasonInParams.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceControlStatusReasonInParamsA{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusReasonInParams, _ptr_psrInParams); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlInParamsA_StatusReasonInParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrInParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusReasonInParams == nil {
			o.StatusReasonInParams = &ServiceControlStatusReasonInParamsA{}
		}
		if err := o.StatusReasonInParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrInParams := func(ptr interface{}) { o.StatusReasonInParams = *ptr.(**ServiceControlStatusReasonInParamsA) }
	if err := w.ReadPointer(&o.StatusReasonInParams, _s_psrInParams, _ptr_psrInParams); err != nil {
		return err
	}
	return nil
}

// ServiceControlOutParamsA structure represents SC_RPC_SERVICE_CONTROL_OUT_PARAMSA RPC union.
type ServiceControlOutParamsA struct {
	// Types that are assignable to Value
	//
	// *ServiceControlOutParamsA_StatusReasonOutParams
	Value is_ServiceControlOutParamsA `json:"value"`
}

func (o *ServiceControlOutParamsA) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServiceControlOutParamsA_StatusReasonOutParams:
		if value != nil {
			return value.StatusReasonOutParams
		}
	}
	return nil
}

type is_ServiceControlOutParamsA interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServiceControlOutParamsA()
}

func (o *ServiceControlOutParamsA) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServiceControlOutParamsA_StatusReasonOutParams:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ServiceControlOutParamsA) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ServiceControlOutParamsA_StatusReasonOutParams)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlOutParamsA_StatusReasonOutParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServiceControlOutParamsA) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ServiceControlOutParamsA_StatusReasonOutParams{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServiceControlOutParamsA_StatusReasonOutParams structure represents SC_RPC_SERVICE_CONTROL_OUT_PARAMSA RPC union arm.
//
// It has following labels: 1
type ServiceControlOutParamsA_StatusReasonOutParams struct {
	StatusReasonOutParams *ServiceControlStatusReasonOutParams `idl:"name:psrOutParams" json:"status_reason_out_params"`
}

func (*ServiceControlOutParamsA_StatusReasonOutParams) is_ServiceControlOutParamsA() {}

func (o *ServiceControlOutParamsA_StatusReasonOutParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusReasonOutParams != nil {
		_ptr_psrOutParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusReasonOutParams != nil {
				if err := o.StatusReasonOutParams.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceControlStatusReasonOutParams{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusReasonOutParams, _ptr_psrOutParams); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlOutParamsA_StatusReasonOutParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrOutParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusReasonOutParams == nil {
			o.StatusReasonOutParams = &ServiceControlStatusReasonOutParams{}
		}
		if err := o.StatusReasonOutParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrOutParams := func(ptr interface{}) { o.StatusReasonOutParams = *ptr.(**ServiceControlStatusReasonOutParams) }
	if err := w.ReadPointer(&o.StatusReasonOutParams, _s_psrOutParams, _ptr_psrOutParams); err != nil {
		return err
	}
	return nil
}

// ServiceControlStatusReasonInParamsW structure represents SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW RPC structure.
//
// The SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW structure<9> contains the reason associated
// with the SERVICE_CONTROL_STOP. String values are in Unicode.
type ServiceControlStatusReasonInParamsW struct {
	// dwReason:  The reason associated with the SERVICE_CONTROL_STOP control. This member
	// MUST be set to a combination of one general reason code, one major reason code, and
	// one minor reason code.
	//
	// The following are the general reason codes.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_CUSTOM 0x20000000    | The reason code is defined by the user. If this flag is not present, the         |
	//	|                                   | reason code is defined by the system. If this flag is specified with a           |
	//	|                                   | system reason code, the function call fails. Users can create custom major       |
	//	|                                   | reason codes in the range SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM (0x00400000)      |
	//	|                                   | through SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM (0x00ff0000) and minor reason       |
	//	|                                   | codes in the range SERVICE_STOP_REASON_MINOR_MIN_CUSTOM (0x00000100) through     |
	//	|                                   | SERVICE_STOP_REASON_MINOR_MAX_CUSTOM (0x0000FFFF).                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_PLANNED 0x40000000   | The service stop was planned.                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STOP_UNPLANNED 0x10000000 | The service stop was not planned.                                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// The following are the major reason codes.
	//
	//	+------------------------------------------------------+------------------------+
	//	|                                                      |                        |
	//	|                        VALUE                         |        MEANING         |
	//	|                                                      |                        |
	//	+------------------------------------------------------+------------------------+
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_APPLICATION 0x00050000     | Application issue      |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_HARDWARE 0x00020000        | Hardware issue         |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_NONE 0x00060000            | No major reason        |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM 0x00030000 | Operating system issue |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_OTHER 0x00010000           | Other issue            |
	//	+------------------------------------------------------+------------------------+
	//	| SERVICE_STOP_REASON_MAJOR_SOFTWARE 0x00040000        | Software issue         |
	//	+------------------------------------------------------+------------------------+
	//
	// The following are the minor reason codes.
	//
	//	+----------------------------------------------------------------+---------------------------+
	//	|                                                                |                           |
	//	|                             VALUE                              |          MEANING          |
	//	|                                                                |                           |
	//	+----------------------------------------------------------------+---------------------------+
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_DISK 0x00000008                      | Disk                      |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_ENVIRONMENT 0x0000000a               | Environment               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER 0x0000000b           | Driver                    |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_HUNG 0x00000006                      | Unresponsive              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_INSTALLATION 0x00000003              | Installation              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_MAINTENANCE 0x00000002               | Maintenance               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_MMC 0x00000016                       | MMC issue                 |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000011      | Network connectivity      |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NETWORKCARD 0x00000009               | Network card              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_NONE 0x00000017                      | No minor reason           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_OTHER 0x00000001                     | Other issue               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_OTHERDRIVER 0x0000000c               | Other driver event        |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_RECONFIG 0x00000005                  | Reconfigure               |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITY 0x00000010                  | Security issue            |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITYFIX 0x0000000f               | Security update           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000015     | Security update uninstall |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SERVICEPACK 0x0000000d               | Service pack              |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000013     | Service pack uninstall    |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE 0x0000000e           | Software update           |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL 0x00000014 | Software update uninstall |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_UNSTABLE 0x00000007                  | Unstable                  |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_UPGRADE 0x00000004                   | Installation of software  |
	//	+----------------------------------------------------------------+---------------------------+
	//	| SERVICE_STOP_REASON_MINOR_WMI 0x00000012                       | WMI issue                 |
	//	+----------------------------------------------------------------+---------------------------+
	Reason uint32 `idl:"name:dwReason" json:"reason"`
	// pszComment:  A pointer to a string that specifies a comment associated with the dwReason
	// parameter. String values are in Unicode.
	Comment string `idl:"name:pszComment;string" json:"comment"`
}

func (o *ServiceControlStatusReasonInParamsW) xxx_PreparePayload(ctx context.Context) error {
	if len(o.Comment) > int(128) {
		return fmt.Errorf("Comment is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonInParamsW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Reason); err != nil {
		return err
	}
	if o.Comment != "" {
		_ptr_pszComment := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Comment); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Comment, _ptr_pszComment); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlStatusReasonInParamsW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Reason); err != nil {
		return err
	}
	_ptr_pszComment := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Comment); err != nil {
			return err
		}
		return nil
	})
	_s_pszComment := func(ptr interface{}) { o.Comment = *ptr.(*string) }
	if err := w.ReadPointer(&o.Comment, _s_pszComment, _ptr_pszComment); err != nil {
		return err
	}
	return nil
}

// ServiceControlInParamsW structure represents SC_RPC_SERVICE_CONTROL_IN_PARAMSW RPC union.
type ServiceControlInParamsW struct {
	// Types that are assignable to Value
	//
	// *ServiceControlInParamsW_StatusReasonInParams
	Value is_ServiceControlInParamsW `json:"value"`
}

func (o *ServiceControlInParamsW) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServiceControlInParamsW_StatusReasonInParams:
		if value != nil {
			return value.StatusReasonInParams
		}
	}
	return nil
}

type is_ServiceControlInParamsW interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServiceControlInParamsW()
}

func (o *ServiceControlInParamsW) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServiceControlInParamsW_StatusReasonInParams:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ServiceControlInParamsW) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ServiceControlInParamsW_StatusReasonInParams)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlInParamsW_StatusReasonInParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServiceControlInParamsW) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ServiceControlInParamsW_StatusReasonInParams{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServiceControlInParamsW_StatusReasonInParams structure represents SC_RPC_SERVICE_CONTROL_IN_PARAMSW RPC union arm.
//
// It has following labels: 1
type ServiceControlInParamsW_StatusReasonInParams struct {
	StatusReasonInParams *ServiceControlStatusReasonInParamsW `idl:"name:psrInParams" json:"status_reason_in_params"`
}

func (*ServiceControlInParamsW_StatusReasonInParams) is_ServiceControlInParamsW() {}

func (o *ServiceControlInParamsW_StatusReasonInParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusReasonInParams != nil {
		_ptr_psrInParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusReasonInParams != nil {
				if err := o.StatusReasonInParams.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceControlStatusReasonInParamsW{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusReasonInParams, _ptr_psrInParams); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlInParamsW_StatusReasonInParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrInParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusReasonInParams == nil {
			o.StatusReasonInParams = &ServiceControlStatusReasonInParamsW{}
		}
		if err := o.StatusReasonInParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrInParams := func(ptr interface{}) { o.StatusReasonInParams = *ptr.(**ServiceControlStatusReasonInParamsW) }
	if err := w.ReadPointer(&o.StatusReasonInParams, _s_psrInParams, _ptr_psrInParams); err != nil {
		return err
	}
	return nil
}

// ServiceControlOutParamsW structure represents SC_RPC_SERVICE_CONTROL_OUT_PARAMSW RPC union.
type ServiceControlOutParamsW struct {
	// Types that are assignable to Value
	//
	// *ServiceControlOutParamsW_StatusReasonOutParams
	Value is_ServiceControlOutParamsW `json:"value"`
}

func (o *ServiceControlOutParamsW) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServiceControlOutParamsW_StatusReasonOutParams:
		if value != nil {
			return value.StatusReasonOutParams
		}
	}
	return nil
}

type is_ServiceControlOutParamsW interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServiceControlOutParamsW()
}

func (o *ServiceControlOutParamsW) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServiceControlOutParamsW_StatusReasonOutParams:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ServiceControlOutParamsW) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ServiceControlOutParamsW_StatusReasonOutParams)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlOutParamsW_StatusReasonOutParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServiceControlOutParamsW) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ServiceControlOutParamsW_StatusReasonOutParams{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServiceControlOutParamsW_StatusReasonOutParams structure represents SC_RPC_SERVICE_CONTROL_OUT_PARAMSW RPC union arm.
//
// It has following labels: 1
type ServiceControlOutParamsW_StatusReasonOutParams struct {
	StatusReasonOutParams *ServiceControlStatusReasonOutParams `idl:"name:psrOutParams" json:"status_reason_out_params"`
}

func (*ServiceControlOutParamsW_StatusReasonOutParams) is_ServiceControlOutParamsW() {}

func (o *ServiceControlOutParamsW_StatusReasonOutParams) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.StatusReasonOutParams != nil {
		_ptr_psrOutParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.StatusReasonOutParams != nil {
				if err := o.StatusReasonOutParams.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceControlStatusReasonOutParams{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.StatusReasonOutParams, _ptr_psrOutParams); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceControlOutParamsW_StatusReasonOutParams) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_psrOutParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.StatusReasonOutParams == nil {
			o.StatusReasonOutParams = &ServiceControlStatusReasonOutParams{}
		}
		if err := o.StatusReasonOutParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_psrOutParams := func(ptr interface{}) { o.StatusReasonOutParams = *ptr.(**ServiceControlStatusReasonOutParams) }
	if err := w.ReadPointer(&o.StatusReasonOutParams, _s_psrOutParams, _ptr_psrOutParams); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultSvcctlClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultSvcctlClient) CloseService(ctx context.Context, in *CloseServiceRequest, opts ...dcerpc.CallOption) (*CloseServiceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseServiceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ControlService(ctx context.Context, in *ControlServiceRequest, opts ...dcerpc.CallOption) (*ControlServiceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ControlServiceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) DeleteService(ctx context.Context, in *DeleteServiceRequest, opts ...dcerpc.CallOption) (*DeleteServiceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteServiceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) LockServiceDatabase(ctx context.Context, in *LockServiceDatabaseRequest, opts ...dcerpc.CallOption) (*LockServiceDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &LockServiceDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceObjectSecurity(ctx context.Context, in *QueryServiceObjectSecurityRequest, opts ...dcerpc.CallOption) (*QueryServiceObjectSecurityResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceObjectSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) SetServiceObjectSecurity(ctx context.Context, in *SetServiceObjectSecurityRequest, opts ...dcerpc.CallOption) (*SetServiceObjectSecurityResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServiceObjectSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceStatus(ctx context.Context, in *QueryServiceStatusRequest, opts ...dcerpc.CallOption) (*QueryServiceStatusResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceStatusResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) SetServiceStatus(ctx context.Context, in *SetServiceStatusRequest, opts ...dcerpc.CallOption) (*SetServiceStatusResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServiceStatusResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) UnlockServiceDatabase(ctx context.Context, in *UnlockServiceDatabaseRequest, opts ...dcerpc.CallOption) (*UnlockServiceDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UnlockServiceDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) NotifyBootConfigStatus(ctx context.Context, in *NotifyBootConfigStatusRequest, opts ...dcerpc.CallOption) (*NotifyBootConfigStatusResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NotifyBootConfigStatusResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ChangeServiceConfigW(ctx context.Context, in *ChangeServiceConfigWRequest, opts ...dcerpc.CallOption) (*ChangeServiceConfigWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeServiceConfigWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CreateServiceW(ctx context.Context, in *CreateServiceWRequest, opts ...dcerpc.CallOption) (*CreateServiceWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateServiceWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumDependentServicesW(ctx context.Context, in *EnumDependentServicesWRequest, opts ...dcerpc.CallOption) (*EnumDependentServicesWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumDependentServicesWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumServicesStatusW(ctx context.Context, in *EnumServicesStatusWRequest, opts ...dcerpc.CallOption) (*EnumServicesStatusWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumServicesStatusWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) OpenSCMW(ctx context.Context, in *OpenSCMWRequest, opts ...dcerpc.CallOption) (*OpenSCMWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenSCMWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) OpenServiceW(ctx context.Context, in *OpenServiceWRequest, opts ...dcerpc.CallOption) (*OpenServiceWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenServiceWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceConfigW(ctx context.Context, in *QueryServiceConfigWRequest, opts ...dcerpc.CallOption) (*QueryServiceConfigWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceConfigWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceLockStatusW(ctx context.Context, in *QueryServiceLockStatusWRequest, opts ...dcerpc.CallOption) (*QueryServiceLockStatusWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceLockStatusWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) StartServiceW(ctx context.Context, in *StartServiceWRequest, opts ...dcerpc.CallOption) (*StartServiceWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartServiceWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) GetServiceDisplayNameW(ctx context.Context, in *GetServiceDisplayNameWRequest, opts ...dcerpc.CallOption) (*GetServiceDisplayNameWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServiceDisplayNameWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) GetServiceKeyNameW(ctx context.Context, in *GetServiceKeyNameWRequest, opts ...dcerpc.CallOption) (*GetServiceKeyNameWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServiceKeyNameWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ChangeServiceConfigA(ctx context.Context, in *ChangeServiceConfigARequest, opts ...dcerpc.CallOption) (*ChangeServiceConfigAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeServiceConfigAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CreateServiceA(ctx context.Context, in *CreateServiceARequest, opts ...dcerpc.CallOption) (*CreateServiceAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateServiceAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumDependentServicesA(ctx context.Context, in *EnumDependentServicesARequest, opts ...dcerpc.CallOption) (*EnumDependentServicesAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumDependentServicesAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumServicesStatusA(ctx context.Context, in *EnumServicesStatusARequest, opts ...dcerpc.CallOption) (*EnumServicesStatusAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumServicesStatusAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) OpenSCMA(ctx context.Context, in *OpenSCMARequest, opts ...dcerpc.CallOption) (*OpenSCMAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenSCMAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) OpenServiceA(ctx context.Context, in *OpenServiceARequest, opts ...dcerpc.CallOption) (*OpenServiceAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenServiceAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceConfigA(ctx context.Context, in *QueryServiceConfigARequest, opts ...dcerpc.CallOption) (*QueryServiceConfigAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceConfigAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceLockStatusA(ctx context.Context, in *QueryServiceLockStatusARequest, opts ...dcerpc.CallOption) (*QueryServiceLockStatusAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceLockStatusAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) StartServiceA(ctx context.Context, in *StartServiceARequest, opts ...dcerpc.CallOption) (*StartServiceAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartServiceAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) GetServiceDisplayNameA(ctx context.Context, in *GetServiceDisplayNameARequest, opts ...dcerpc.CallOption) (*GetServiceDisplayNameAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServiceDisplayNameAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) GetServiceKeyNameA(ctx context.Context, in *GetServiceKeyNameARequest, opts ...dcerpc.CallOption) (*GetServiceKeyNameAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServiceKeyNameAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumServiceGroupW(ctx context.Context, in *EnumServiceGroupWRequest, opts ...dcerpc.CallOption) (*EnumServiceGroupWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumServiceGroupWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ChangeServiceConfig2A(ctx context.Context, in *ChangeServiceConfig2ARequest, opts ...dcerpc.CallOption) (*ChangeServiceConfig2AResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeServiceConfig2AResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ChangeServiceConfig2W(ctx context.Context, in *ChangeServiceConfig2WRequest, opts ...dcerpc.CallOption) (*ChangeServiceConfig2WResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChangeServiceConfig2WResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceConfig2A(ctx context.Context, in *QueryServiceConfig2ARequest, opts ...dcerpc.CallOption) (*QueryServiceConfig2AResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceConfig2AResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceConfig2W(ctx context.Context, in *QueryServiceConfig2WRequest, opts ...dcerpc.CallOption) (*QueryServiceConfig2WResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceConfig2WResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceStatusEx(ctx context.Context, in *QueryServiceStatusExRequest, opts ...dcerpc.CallOption) (*QueryServiceStatusExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceStatusExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumServicesStatusExA(ctx context.Context, in *EnumServicesStatusExARequest, opts ...dcerpc.CallOption) (*EnumServicesStatusExAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumServicesStatusExAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) EnumServicesStatusExW(ctx context.Context, in *EnumServicesStatusExWRequest, opts ...dcerpc.CallOption) (*EnumServicesStatusExWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumServicesStatusExWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CreateServiceWOW64A(ctx context.Context, in *CreateServiceWOW64ARequest, opts ...dcerpc.CallOption) (*CreateServiceWOW64AResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateServiceWOW64AResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CreateServiceWOW64W(ctx context.Context, in *CreateServiceWOW64WRequest, opts ...dcerpc.CallOption) (*CreateServiceWOW64WResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateServiceWOW64WResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) NotifyServiceStatusChange(ctx context.Context, in *NotifyServiceStatusChangeRequest, opts ...dcerpc.CallOption) (*NotifyServiceStatusChangeResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NotifyServiceStatusChangeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) GetNotifyResults(ctx context.Context, in *GetNotifyResultsRequest, opts ...dcerpc.CallOption) (*GetNotifyResultsResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNotifyResultsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CloseNotify(ctx context.Context, in *CloseNotifyRequest, opts ...dcerpc.CallOption) (*CloseNotifyResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CloseNotifyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ControlServiceExA(ctx context.Context, in *ControlServiceExARequest, opts ...dcerpc.CallOption) (*ControlServiceExAResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ControlServiceExAResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) ControlServiceExW(ctx context.Context, in *ControlServiceExWRequest, opts ...dcerpc.CallOption) (*ControlServiceExWResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ControlServiceExWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) QueryServiceConfigEx(ctx context.Context, in *QueryServiceConfigExRequest, opts ...dcerpc.CallOption) (*QueryServiceConfigExResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryServiceConfigExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) CreateWOWService(ctx context.Context, in *CreateWOWServiceRequest, opts ...dcerpc.CallOption) (*CreateWOWServiceResponse, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateWOWServiceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) OpenSCM2(ctx context.Context, in *OpenSCM2Request, opts ...dcerpc.CallOption) (*OpenSCM2Response, error) {
	op := in.xxx_ToOp(ctx)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenSCM2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSvcctlClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}
func NewSvcctlClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (SvcctlClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(SvcctlSyntaxV2_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultSvcctlClient{cc: cc}, nil
}

// xxx_CloseServiceOperation structure represents the RCloseServiceHandle operation
type xxx_CloseServiceOperation struct {
	ServiceObject *Handle `idl:"name:hSCObject" json:"service_object"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseServiceOperation) OpNum() int { return 0 }

func (o *xxx_CloseServiceOperation) OpName() string { return "/svcctl/v2/RCloseServiceHandle" }

func (o *xxx_CloseServiceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseServiceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCObject {in, out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceObject != nil {
			if err := o.ServiceObject.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseServiceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCObject {in, out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceObject == nil {
			o.ServiceObject = &Handle{}
		}
		if err := o.ServiceObject.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseServiceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseServiceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// hSCObject {in, out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceObject != nil {
			if err := o.ServiceObject.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseServiceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// hSCObject {in, out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceObject == nil {
			o.ServiceObject = &Handle{}
		}
		if err := o.ServiceObject.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseServiceRequest structure represents the RCloseServiceHandle operation request
type CloseServiceRequest struct {
	// hSCObject: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// a service record or to the SCM database that MUST have been created previously using
	// one of the open methods specified in section 3.1.4.
	ServiceObject *Handle `idl:"name:hSCObject" json:"service_object"`
}

func (o *CloseServiceRequest) xxx_ToOp(ctx context.Context) *xxx_CloseServiceOperation {
	if o == nil {
		return &xxx_CloseServiceOperation{}
	}
	return &xxx_CloseServiceOperation{
		ServiceObject: o.ServiceObject,
	}
}

func (o *CloseServiceRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseServiceOperation) {
	if o == nil {
		return
	}
	o.ServiceObject = op.ServiceObject
}
func (o *CloseServiceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseServiceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseServiceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseServiceResponse structure represents the RCloseServiceHandle operation response
type CloseServiceResponse struct {
	// hSCObject: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// a service record or to the SCM database that MUST have been created previously using
	// one of the open methods specified in section 3.1.4.
	ServiceObject *Handle `idl:"name:hSCObject" json:"service_object"`
	// Return: The RCloseServiceHandle return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseServiceResponse) xxx_ToOp(ctx context.Context) *xxx_CloseServiceOperation {
	if o == nil {
		return &xxx_CloseServiceOperation{}
	}
	return &xxx_CloseServiceOperation{
		ServiceObject: o.ServiceObject,
		Return:        o.Return,
	}
}

func (o *CloseServiceResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseServiceOperation) {
	if o == nil {
		return
	}
	o.ServiceObject = op.ServiceObject
	o.Return = op.Return
}
func (o *CloseServiceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseServiceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseServiceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ControlServiceOperation structure represents the RControlService operation
type xxx_ControlServiceOperation struct {
	Service       *Handle        `idl:"name:hService" json:"service"`
	Control       uint32         `idl:"name:dwControl" json:"control"`
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
	Return        uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_ControlServiceOperation) OpNum() int { return 1 }

func (o *xxx_ControlServiceOperation) OpName() string { return "/svcctl/v2/RControlService" }

func (o *xxx_ControlServiceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Control); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Control); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceStatus {out} (1:{alias=LPSERVICE_STATUS}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus != nil {
			if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceStatus{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceStatus {out} (1:{alias=LPSERVICE_STATUS,pointer=ref}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus == nil {
			o.ServiceStatus = &ServiceStatus{}
		}
		if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ControlServiceRequest structure represents the RControlService operation request
type ControlServiceRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously using one of the open methods
	// specified in section 3.1.4.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwControl: Requested control code. MUST be one of the following values.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                           |                                                                                  |
	//	|                   VALUE                   |                                     MEANING                                      |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_CONTINUE 0x00000003       | Notifies a paused service that it SHOULD resume. The SERVICE_PAUSE_CONTINUE      |
	//	|                                           | access right MUST have been granted to the caller when the RPC control           |
	//	|                                           | handle to the service record was created. The service record MUST have the       |
	//	|                                           | SERVICE_ACCEPT_PAUSE_CONTINUE bit set in the ServiceStatus.dwControlsAccepted    |
	//	|                                           | field of the service record.                                                     |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_INTERROGATE 0x00000004    | Notifies a service that it SHOULD report its current status information to the   |
	//	|                                           | SCM. The SERVICE_INTERROGATE access right MUST have been granted to the caller   |
	//	|                                           | when the RPC control handle to the service record was created.                   |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDADD 0x00000007     | Notifies a service that there is a new component for binding. The                |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDDISABLE 0x0000000A | Notifies a network service that one of its bindings has been disabled.           |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDENABLE 0x00000009  | Notifies a network service that a disabled binding has been enabled.             |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDREMOVE 0x00000008  | Notifies a network service that a component for binding has been removed.        |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PARAMCHANGE 0x00000006    | Notifies a service that its startup parameters have changed. The                 |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_PARAMCHANGE bit set in the           |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PAUSE 0x00000002          | Notifies a service that it SHOULD pause. The SERVICE_PAUSE_CONTINUE              |
	//	|                                           | access right MUST have been granted to the caller when the RPC control           |
	//	|                                           | handle to the service record was created. The service record MUST have the       |
	//	|                                           | SERVICE_ACCEPT_PAUSE_CONTINUE bit set in the ServiceStatus.dwControlsAccepted    |
	//	|                                           | field of the service record.                                                     |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_STOP 0x00000001           | Notifies a service that it SHOULD stop. The SERVICE_STOP access right MUST have  |
	//	|                                           | been granted to the caller when the RPC control handle to the service record     |
	//	|                                           | was created. The service record MUST have the SERVICE_ACCEPT_STOP bit set in the |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	Control uint32 `idl:"name:dwControl" json:"control"`
}

func (o *ControlServiceRequest) xxx_ToOp(ctx context.Context) *xxx_ControlServiceOperation {
	if o == nil {
		return &xxx_ControlServiceOperation{}
	}
	return &xxx_ControlServiceOperation{
		Service: o.Service,
		Control: o.Control,
	}
}

func (o *ControlServiceRequest) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Control = op.Control
}
func (o *ControlServiceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ControlServiceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ControlServiceResponse structure represents the RControlService operation response
type ControlServiceResponse struct {
	// lpServiceStatus: Pointer to a SERVICE_STATUS (section 2.2.47) structure that receives
	// the latest service status information. The returned information reflects the most
	// recent status that the service reported to the SCM.
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
	// Return: The RControlService return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ControlServiceResponse) xxx_ToOp(ctx context.Context) *xxx_ControlServiceOperation {
	if o == nil {
		return &xxx_ControlServiceOperation{}
	}
	return &xxx_ControlServiceOperation{
		ServiceStatus: o.ServiceStatus,
		Return:        o.Return,
	}
}

func (o *ControlServiceResponse) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceOperation) {
	if o == nil {
		return
	}
	o.ServiceStatus = op.ServiceStatus
	o.Return = op.Return
}
func (o *ControlServiceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ControlServiceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteServiceOperation structure represents the RDeleteService operation
type xxx_DeleteServiceOperation struct {
	Service *Handle `idl:"name:hService" json:"service"`
	Return  uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteServiceOperation) OpNum() int { return 2 }

func (o *xxx_DeleteServiceOperation) OpName() string { return "/svcctl/v2/RDeleteService" }

func (o *xxx_DeleteServiceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteServiceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteServiceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteServiceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteServiceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteServiceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteServiceRequest structure represents the RDeleteService operation request
type DeleteServiceRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The DELETE access right MUST have been granted to the
	// caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
}

func (o *DeleteServiceRequest) xxx_ToOp(ctx context.Context) *xxx_DeleteServiceOperation {
	if o == nil {
		return &xxx_DeleteServiceOperation{}
	}
	return &xxx_DeleteServiceOperation{
		Service: o.Service,
	}
}

func (o *DeleteServiceRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteServiceOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
}
func (o *DeleteServiceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *DeleteServiceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteServiceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteServiceResponse structure represents the RDeleteService operation response
type DeleteServiceResponse struct {
	// Return: The RDeleteService return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteServiceResponse) xxx_ToOp(ctx context.Context) *xxx_DeleteServiceOperation {
	if o == nil {
		return &xxx_DeleteServiceOperation{}
	}
	return &xxx_DeleteServiceOperation{
		Return: o.Return,
	}
}

func (o *DeleteServiceResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteServiceOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteServiceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *DeleteServiceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteServiceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_LockServiceDatabaseOperation structure represents the RLockServiceDatabase operation
type xxx_LockServiceDatabaseOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	Lock           *Lock   `idl:"name:lpLock" json:"lock"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_LockServiceDatabaseOperation) OpNum() int { return 3 }

func (o *xxx_LockServiceDatabaseOperation) OpName() string { return "/svcctl/v2/RLockServiceDatabase" }

func (o *xxx_LockServiceDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_LockServiceDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_LockServiceDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_LockServiceDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_LockServiceDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpLock {out} (1:{alias=LPSC_RPC_LOCK}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock != nil {
			if err := o.Lock.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Lock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_LockServiceDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpLock {out} (1:{alias=LPSC_RPC_LOCK,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock == nil {
			o.Lock = &Lock{}
		}
		if err := o.Lock.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// LockServiceDatabaseRequest structure represents the RLockServiceDatabase operation request
type LockServiceDatabaseRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The caller MUST be granted the SC_MANAGER_LOCK access right when the RPC context
	// handle is created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
}

func (o *LockServiceDatabaseRequest) xxx_ToOp(ctx context.Context) *xxx_LockServiceDatabaseOperation {
	if o == nil {
		return &xxx_LockServiceDatabaseOperation{}
	}
	return &xxx_LockServiceDatabaseOperation{
		ServiceManager: o.ServiceManager,
	}
}

func (o *LockServiceDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_LockServiceDatabaseOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
}
func (o *LockServiceDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *LockServiceDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_LockServiceDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// LockServiceDatabaseResponse structure represents the RLockServiceDatabase operation response
type LockServiceDatabaseResponse struct {
	// lpLock: An LPSC_RPC_LOCK (section 2.2.5) data type that defines the handle to the
	// resulting database lock.
	Lock *Lock `idl:"name:lpLock" json:"lock"`
	// Return: The RLockServiceDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *LockServiceDatabaseResponse) xxx_ToOp(ctx context.Context) *xxx_LockServiceDatabaseOperation {
	if o == nil {
		return &xxx_LockServiceDatabaseOperation{}
	}
	return &xxx_LockServiceDatabaseOperation{
		Lock:   o.Lock,
		Return: o.Return,
	}
}

func (o *LockServiceDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_LockServiceDatabaseOperation) {
	if o == nil {
		return
	}
	o.Lock = op.Lock
	o.Return = op.Return
}
func (o *LockServiceDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *LockServiceDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_LockServiceDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceObjectSecurityOperation structure represents the RQueryServiceObjectSecurity operation
type xxx_QueryServiceObjectSecurityOperation struct {
	Service             *Handle `idl:"name:hService" json:"service"`
	SecurityInformation uint32  `idl:"name:dwSecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte  `idl:"name:lpSecurityDescriptor;size_is:(cbBufSize)" json:"security_descriptor"`
	BufferLength        uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength   uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return              uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceObjectSecurityOperation) OpNum() int { return 4 }

func (o *xxx_QueryServiceObjectSecurityOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceObjectSecurity"
}

func (o *xxx_QueryServiceObjectSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceObjectSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwSecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=ULONG}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceObjectSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwSecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceObjectSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceObjectSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpSecurityDescriptor {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceObjectSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpSecurityDescriptor {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceObjectSecurityRequest structure represents the RQueryServiceObjectSecurity operation request
type QueryServiceObjectSecurityRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to a
	// service record or to the SCM database that MUST have been created previously using
	// one of the open methods specified in section 3.1.4.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwSecurityInformation: A SECURITY_INFORMATION (section 2.2.1) type definition that
	// specifies the security information being requested.
	SecurityInformation uint32 `idl:"name:dwSecurityInformation" json:"security_information"`
	// cbBufSize: Size, in bytes, of the buffer to which the lpSecurityDescriptor parameter
	// points.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceObjectSecurityRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceObjectSecurityOperation {
	if o == nil {
		return &xxx_QueryServiceObjectSecurityOperation{}
	}
	return &xxx_QueryServiceObjectSecurityOperation{
		Service:             o.Service,
		SecurityInformation: o.SecurityInformation,
		BufferLength:        o.BufferLength,
	}
}

func (o *QueryServiceObjectSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceObjectSecurityOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.SecurityInformation = op.SecurityInformation
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceObjectSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceObjectSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceObjectSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceObjectSecurityResponse structure represents the RQueryServiceObjectSecurity operation response
type QueryServiceObjectSecurityResponse struct {
	// lpSecurityDescriptor: A pointer to a buffer that contains a copy of the SECURITY_DESCRIPTOR
	// structure (as specified in [MS-DTYP] section 2.4.6) for the specified service object.
	SecurityDescriptor []byte `idl:"name:lpSecurityDescriptor;size_is:(cbBufSize)" json:"security_descriptor"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to return all the requested SECURITY_DESCRIPTOR
	// information if the method fails.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceObjectSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceObjectSecurityResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceObjectSecurityOperation {
	if o == nil {
		return &xxx_QueryServiceObjectSecurityOperation{}
	}
	return &xxx_QueryServiceObjectSecurityOperation{
		SecurityDescriptor: o.SecurityDescriptor,
		BytesNeededLength:  o.BytesNeededLength,
		Return:             o.Return,
	}
}

func (o *QueryServiceObjectSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceObjectSecurityOperation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceObjectSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceObjectSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceObjectSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServiceObjectSecurityOperation structure represents the RSetServiceObjectSecurity operation
type xxx_SetServiceObjectSecurityOperation struct {
	Service             *Handle `idl:"name:hService" json:"service"`
	SecurityInformation uint32  `idl:"name:dwSecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte  `idl:"name:lpSecurityDescriptor;size_is:(cbBufSize)" json:"security_descriptor"`
	BufferLength        uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	Return              uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServiceObjectSecurityOperation) OpNum() int { return 5 }

func (o *xxx_SetServiceObjectSecurityOperation) OpName() string {
	return "/svcctl/v2/RSetServiceObjectSecurity"
}

func (o *xxx_SetServiceObjectSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceObjectSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwSecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=ULONG}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// lpSecurityDescriptor {in} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceObjectSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwSecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// lpSecurityDescriptor {in} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceObjectSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceObjectSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceObjectSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServiceObjectSecurityRequest structure represents the RSetServiceObjectSecurity operation request
type SetServiceObjectSecurityRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to a
	// service record or to the SCM database that MUST have been created previously using
	// one of the open methods specified in section 3.1.4.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwSecurityInformation: A SECURITY_INFORMATION (section 2.2.1) type definition that
	// specifies the security information being set.
	SecurityInformation uint32 `idl:"name:dwSecurityInformation" json:"security_information"`
	// lpSecurityDescriptor: A pointer to a buffer of bytes that contains the new security
	// information.
	SecurityDescriptor []byte `idl:"name:lpSecurityDescriptor;size_is:(cbBufSize)" json:"security_descriptor"`
	// cbBufSize: Size, in bytes, of the buffer pointed to by the lpSecurityDescriptor parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *SetServiceObjectSecurityRequest) xxx_ToOp(ctx context.Context) *xxx_SetServiceObjectSecurityOperation {
	if o == nil {
		return &xxx_SetServiceObjectSecurityOperation{}
	}
	return &xxx_SetServiceObjectSecurityOperation{
		Service:             o.Service,
		SecurityInformation: o.SecurityInformation,
		SecurityDescriptor:  o.SecurityDescriptor,
		BufferLength:        o.BufferLength,
	}
}

func (o *SetServiceObjectSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_SetServiceObjectSecurityOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferLength = op.BufferLength
}
func (o *SetServiceObjectSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetServiceObjectSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceObjectSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServiceObjectSecurityResponse structure represents the RSetServiceObjectSecurity operation response
type SetServiceObjectSecurityResponse struct {
	// Return: The RSetServiceObjectSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetServiceObjectSecurityResponse) xxx_ToOp(ctx context.Context) *xxx_SetServiceObjectSecurityOperation {
	if o == nil {
		return &xxx_SetServiceObjectSecurityOperation{}
	}
	return &xxx_SetServiceObjectSecurityOperation{
		Return: o.Return,
	}
}

func (o *SetServiceObjectSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_SetServiceObjectSecurityOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetServiceObjectSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetServiceObjectSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceObjectSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceStatusOperation structure represents the RQueryServiceStatus operation
type xxx_QueryServiceStatusOperation struct {
	Service       *Handle        `idl:"name:hService" json:"service"`
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
	Return        uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceStatusOperation) OpNum() int { return 6 }

func (o *xxx_QueryServiceStatusOperation) OpName() string { return "/svcctl/v2/RQueryServiceStatus" }

func (o *xxx_QueryServiceStatusOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceStatus {out} (1:{alias=LPSERVICE_STATUS}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus != nil {
			if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceStatus{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceStatus {out} (1:{alias=LPSERVICE_STATUS,pointer=ref}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus == nil {
			o.ServiceStatus = &ServiceStatus{}
		}
		if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceStatusRequest structure represents the RQueryServiceStatus operation request
type QueryServiceStatusRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_STATUS access right MUST have been
	// granted to the caller when the RPC context handle was created.
	Service *Handle `idl:"name:hService" json:"service"`
}

func (o *QueryServiceStatusRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceStatusOperation {
	if o == nil {
		return &xxx_QueryServiceStatusOperation{}
	}
	return &xxx_QueryServiceStatusOperation{
		Service: o.Service,
	}
}

func (o *QueryServiceStatusRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceStatusOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
}
func (o *QueryServiceStatusRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceStatusRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceStatusOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceStatusResponse structure represents the RQueryServiceStatus operation response
type QueryServiceStatusResponse struct {
	// lpServiceStatus: Pointer to a SERVICE_STATUS (section 2.2.47) structure that contains
	// the status information for the service.
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
	// Return: The RQueryServiceStatus return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceStatusResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceStatusOperation {
	if o == nil {
		return &xxx_QueryServiceStatusOperation{}
	}
	return &xxx_QueryServiceStatusOperation{
		ServiceStatus: o.ServiceStatus,
		Return:        o.Return,
	}
}

func (o *QueryServiceStatusResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceStatusOperation) {
	if o == nil {
		return
	}
	o.ServiceStatus = op.ServiceStatus
	o.Return = op.Return
}
func (o *QueryServiceStatusResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceStatusResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceStatusOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServiceStatusOperation structure represents the RSetServiceStatus operation
type xxx_SetServiceStatusOperation struct {
	Service       *Handle        `idl:"name:hServiceStatus" json:"service"`
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
	Return        uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServiceStatusOperation) OpNum() int { return 7 }

func (o *xxx_SetServiceStatusOperation) OpName() string { return "/svcctl/v2/RSetServiceStatus" }

func (o *xxx_SetServiceStatusOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceStatusOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hServiceStatus {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceStatus {in} (1:{alias=LPSERVICE_STATUS}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus != nil {
			if err := o.ServiceStatus.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServiceStatus{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetServiceStatusOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hServiceStatus {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceStatus {in} (1:{alias=LPSERVICE_STATUS,pointer=ref}*(1))(2:{alias=SERVICE_STATUS}(struct))
	{
		if o.ServiceStatus == nil {
			o.ServiceStatus = &ServiceStatus{}
		}
		if err := o.ServiceStatus.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceStatusOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceStatusOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceStatusOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServiceStatusRequest structure represents the RSetServiceStatus operation request
type SetServiceStatusRequest struct {
	// hServiceStatus: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the service record that MUST have been created previously using one of the open
	// methods specified in section 3.1.4. The SERVICE_SET_STATUS access right MUST have
	// been granted to the caller when the RPC context handle was created.
	Service *Handle `idl:"name:hServiceStatus" json:"service"`
	// lpServiceStatus: Pointer to the SERVICE_STATUS (section 2.2.47) structure that contains
	// the latest status information for the service.
	ServiceStatus *ServiceStatus `idl:"name:lpServiceStatus" json:"service_status"`
}

func (o *SetServiceStatusRequest) xxx_ToOp(ctx context.Context) *xxx_SetServiceStatusOperation {
	if o == nil {
		return &xxx_SetServiceStatusOperation{}
	}
	return &xxx_SetServiceStatusOperation{
		Service:       o.Service,
		ServiceStatus: o.ServiceStatus,
	}
}

func (o *SetServiceStatusRequest) xxx_FromOp(ctx context.Context, op *xxx_SetServiceStatusOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.ServiceStatus = op.ServiceStatus
}
func (o *SetServiceStatusRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *SetServiceStatusRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceStatusOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServiceStatusResponse structure represents the RSetServiceStatus operation response
type SetServiceStatusResponse struct {
	// Return: The RSetServiceStatus return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetServiceStatusResponse) xxx_ToOp(ctx context.Context) *xxx_SetServiceStatusOperation {
	if o == nil {
		return &xxx_SetServiceStatusOperation{}
	}
	return &xxx_SetServiceStatusOperation{
		Return: o.Return,
	}
}

func (o *SetServiceStatusResponse) xxx_FromOp(ctx context.Context, op *xxx_SetServiceStatusOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetServiceStatusResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *SetServiceStatusResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceStatusOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UnlockServiceDatabaseOperation structure represents the RUnlockServiceDatabase operation
type xxx_UnlockServiceDatabaseOperation struct {
	Lock   *Lock  `idl:"name:Lock" json:"lock"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_UnlockServiceDatabaseOperation) OpNum() int { return 8 }

func (o *xxx_UnlockServiceDatabaseOperation) OpName() string {
	return "/svcctl/v2/RUnlockServiceDatabase"
}

func (o *xxx_UnlockServiceDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnlockServiceDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Lock {in, out} (1:{alias=LPSC_RPC_LOCK}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock != nil {
			if err := o.Lock.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Lock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_UnlockServiceDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Lock {in, out} (1:{alias=LPSC_RPC_LOCK,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock == nil {
			o.Lock = &Lock{}
		}
		if err := o.Lock.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnlockServiceDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnlockServiceDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Lock {in, out} (1:{alias=LPSC_RPC_LOCK}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock != nil {
			if err := o.Lock.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Lock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnlockServiceDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Lock {in, out} (1:{alias=LPSC_RPC_LOCK,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_LOCK, names=ndr_context_handle}(struct))
	{
		if o.Lock == nil {
			o.Lock = &Lock{}
		}
		if err := o.Lock.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UnlockServiceDatabaseRequest structure represents the RUnlockServiceDatabase operation request
type UnlockServiceDatabaseRequest struct {
	// Lock: An LPSC_RPC_LOCK (section 2.2.5) data type that defines the database lock context
	// handle created by a previous call to the RLockServiceDatabase method.
	Lock *Lock `idl:"name:Lock" json:"lock"`
}

func (o *UnlockServiceDatabaseRequest) xxx_ToOp(ctx context.Context) *xxx_UnlockServiceDatabaseOperation {
	if o == nil {
		return &xxx_UnlockServiceDatabaseOperation{}
	}
	return &xxx_UnlockServiceDatabaseOperation{
		Lock: o.Lock,
	}
}

func (o *UnlockServiceDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_UnlockServiceDatabaseOperation) {
	if o == nil {
		return
	}
	o.Lock = op.Lock
}
func (o *UnlockServiceDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *UnlockServiceDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnlockServiceDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UnlockServiceDatabaseResponse structure represents the RUnlockServiceDatabase operation response
type UnlockServiceDatabaseResponse struct {
	// Lock: An LPSC_RPC_LOCK (section 2.2.5) data type that defines the database lock context
	// handle created by a previous call to the RLockServiceDatabase method.
	Lock *Lock `idl:"name:Lock" json:"lock"`
	// Return: The RUnlockServiceDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UnlockServiceDatabaseResponse) xxx_ToOp(ctx context.Context) *xxx_UnlockServiceDatabaseOperation {
	if o == nil {
		return &xxx_UnlockServiceDatabaseOperation{}
	}
	return &xxx_UnlockServiceDatabaseOperation{
		Lock:   o.Lock,
		Return: o.Return,
	}
}

func (o *UnlockServiceDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_UnlockServiceDatabaseOperation) {
	if o == nil {
		return
	}
	o.Lock = op.Lock
	o.Return = op.Return
}
func (o *UnlockServiceDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *UnlockServiceDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnlockServiceDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NotifyBootConfigStatusOperation structure represents the RNotifyBootConfigStatus operation
type xxx_NotifyBootConfigStatusOperation struct {
	MachineName    string `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	BootAcceptable uint32 `idl:"name:BootAcceptable" json:"boot_acceptable"`
	Return         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NotifyBootConfigStatusOperation) OpNum() int { return 9 }

func (o *xxx_NotifyBootConfigStatusOperation) OpName() string {
	return "/svcctl/v2/RNotifyBootConfigStatus"
}

func (o *xxx_NotifyBootConfigStatusOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.MachineName) > int(1024) {
		return fmt.Errorf("MachineName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyBootConfigStatusOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEW}*(1)[dim:0,string,null](wchar))
	{
		if o.MachineName != "" {
			_ptr_lpMachineName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MachineName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MachineName, _ptr_lpMachineName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BootAcceptable {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BootAcceptable); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyBootConfigStatusOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEW}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpMachineName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MachineName); err != nil {
				return err
			}
			return nil
		})
		_s_lpMachineName := func(ptr interface{}) { o.MachineName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MachineName, _s_lpMachineName, _ptr_lpMachineName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BootAcceptable {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BootAcceptable); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyBootConfigStatusOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyBootConfigStatusOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyBootConfigStatusOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NotifyBootConfigStatusRequest structure represents the RNotifyBootConfigStatus operation request
type NotifyBootConfigStatusRequest struct {
	// lpMachineName: An SVCCTL_HANDLEW (section 2.2.3) data type that defines the handle
	// that contains the UNICODE string name of the server to be notified.
	MachineName string `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	// BootAcceptable: A value that specifies whether the configuration used when booting
	// the system is acceptable. MUST be one of the following values.
	//
	//	+--------------------+----------------------------------------------------------------------------------+
	//	|                    |                                                                                  |
	//	|       VALUE        |                                     MEANING                                      |
	//	|                    |                                                                                  |
	//	+--------------------+----------------------------------------------------------------------------------+
	//	+--------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 < value | Server saves the configuration as the last-known good configuration.             |
	//	+--------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000         | Server immediately reboots, using the previously saved last-known good           |
	//	|                    | configuration.                                                                   |
	//	+--------------------+----------------------------------------------------------------------------------+
	BootAcceptable uint32 `idl:"name:BootAcceptable" json:"boot_acceptable"`
}

func (o *NotifyBootConfigStatusRequest) xxx_ToOp(ctx context.Context) *xxx_NotifyBootConfigStatusOperation {
	if o == nil {
		return &xxx_NotifyBootConfigStatusOperation{}
	}
	return &xxx_NotifyBootConfigStatusOperation{
		MachineName:    o.MachineName,
		BootAcceptable: o.BootAcceptable,
	}
}

func (o *NotifyBootConfigStatusRequest) xxx_FromOp(ctx context.Context, op *xxx_NotifyBootConfigStatusOperation) {
	if o == nil {
		return
	}
	o.MachineName = op.MachineName
	o.BootAcceptable = op.BootAcceptable
}
func (o *NotifyBootConfigStatusRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NotifyBootConfigStatusRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NotifyBootConfigStatusOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NotifyBootConfigStatusResponse structure represents the RNotifyBootConfigStatus operation response
type NotifyBootConfigStatusResponse struct {
	// Return: The RNotifyBootConfigStatus return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NotifyBootConfigStatusResponse) xxx_ToOp(ctx context.Context) *xxx_NotifyBootConfigStatusOperation {
	if o == nil {
		return &xxx_NotifyBootConfigStatusOperation{}
	}
	return &xxx_NotifyBootConfigStatusOperation{
		Return: o.Return,
	}
}

func (o *NotifyBootConfigStatusResponse) xxx_FromOp(ctx context.Context, op *xxx_NotifyBootConfigStatusOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *NotifyBootConfigStatusResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NotifyBootConfigStatusResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NotifyBootConfigStatusOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeServiceConfigWOperation structure represents the RChangeServiceConfigW operation
type xxx_ChangeServiceConfigWOperation struct {
	Service          *Handle `idl:"name:hService" json:"service"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string;pointer:unique" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeServiceConfigWOperation) OpNum() int { return 11 }

func (o *xxx_ChangeServiceConfigWOperation) OpName() string {
	return "/svcctl/v2/RChangeServiceConfigW"
}

func (o *xxx_ChangeServiceConfigWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=unique, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if o.BinaryPathName != "" {
			_ptr_lpBinaryPathName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.BinaryPathName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.BinaryPathName, _ptr_lpBinaryPathName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=unique, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpBinaryPathName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.BinaryPathName); err != nil {
				return err
			}
			return nil
		})
		_s_lpBinaryPathName := func(ptr interface{}) { o.BinaryPathName = *ptr.(*string) }
		if err := w.ReadPointer(&o.BinaryPathName, _s_lpBinaryPathName, _ptr_lpBinaryPathName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeServiceConfigWRequest structure represents the RChangeServiceConfigW operation request
type ChangeServiceConfigWRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_CHANGE_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwServiceType: A Type value for the service record (section 3.1.1) that specifies
	// the type of service. This MUST be one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF           | Service type does not change.                                                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//
	// The following flag can also be combined with the value passed in dwServiceStartType:
	//
	//	+----------------------------------------+--------------------------------------------+
	//	|                                        |                                            |
	//	|                 VALUE                  |                  MEANING                   |
	//	|                                        |                                            |
	//	+----------------------------------------+--------------------------------------------+
	//	+----------------------------------------+--------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop. |
	//	+----------------------------------------+--------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A Start value for the service record (section 3.1.1) that specifies
	// when to start the service. This MUST be one of the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF    | Service start type does not change.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: An ErrorControl value for the service record (section 3.1.1) that
	// specifies the severity of the error if the service fails to start and determines
	// the action that the SCM takes. MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error and displays a message box, but continues the startup     |
	//	|                                   | operation.                                                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF      | Service error control type does not change.                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: An ImagePath value for the service record (section 3.1.1) as a
	// pointer to a null-terminated UNICODE string name. The pointer contains the fully
	// qualified path to the service binary file. The path MAY include arguments. If the
	// path contains a space, it MUST be quoted so that it is correctly interpreted. For
	// example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string;pointer:unique" json:"binary_path_name"`
	// lpLoadOrderGroup: A Group value for the service record (section 3.1.1) as a pointer
	// to a null-terminated UNICODE string that names the load-ordering group of which this
	// service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A Tag value for the service record (section 3.1.1) as a pointer to a variable
	// that receives a tag value. The value is unique to the group specified in the lpLoadOrderGroup
	// parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: DependOnService and DependOnGroup values for the service record (section
	// 3.1.1) as a pointer to an array of null-separated names of services or load ordering
	// groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is Unicode. Dependency on a service means that this service can only
	// run if the service it depends on is running. Dependency on a group means that this
	// service can run if at least one member of the group is running after an attempt to
	// start all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the lpDependencies parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: An ObjectName value for the service record (section 3.1.1) as
	// a pointer to a null-terminated UNICODE string that specifies the name of the account
	// under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A Password value for the service record (section 3.1.1) as a pointer
	// to a null-terminated UNICODE string that contains the password of the account whose
	// name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
	// lpDisplayName: A DisplayName value for the service record (section 3.1.1) as a pointer
	// to a null-terminated UNICODE string that contains the display name that applications
	// can use to identify the service for its users.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
}

func (o *ChangeServiceConfigWRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfigWOperation {
	if o == nil {
		return &xxx_ChangeServiceConfigWOperation{}
	}
	return &xxx_ChangeServiceConfigWOperation{
		Service:          o.Service,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
		DisplayName:      o.DisplayName,
	}
}

func (o *ChangeServiceConfigWRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfigWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
	o.DisplayName = op.DisplayName
}
func (o *ChangeServiceConfigWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeServiceConfigWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfigWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeServiceConfigWResponse structure represents the RChangeServiceConfigW operation response
type ChangeServiceConfigWResponse struct {
	// lpdwTagId: A Tag value for the service record (section 3.1.1) as a pointer to a variable
	// that receives a tag value. The value is unique to the group specified in the lpLoadOrderGroup
	// parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// Return: The RChangeServiceConfigW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeServiceConfigWResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfigWOperation {
	if o == nil {
		return &xxx_ChangeServiceConfigWOperation{}
	}
	return &xxx_ChangeServiceConfigWOperation{
		TagID:  o.TagID,
		Return: o.Return,
	}
}

func (o *ChangeServiceConfigWResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfigWOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Return = op.Return
}
func (o *ChangeServiceConfigWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeServiceConfigWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfigWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateServiceWOperation structure represents the RCreateServiceW operation
type xxx_CreateServiceWOperation struct {
	ServiceManager   *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName      string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	DesiredAccess    uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	Service          *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateServiceWOperation) OpNum() int { return 12 }

func (o *xxx_CreateServiceWOperation) OpName() string { return "/svcctl/v2/RCreateServiceW" }

func (o *xxx_CreateServiceWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateServiceWRequest structure represents the RCreateServiceW operation request
type CreateServiceWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The SC_MANAGER_CREATE_SERVICE access right MUST have been granted to the caller when
	// the RPC context handle was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated UNICODE string that specifies the name
	// of the service to install. This MUST not be NULL.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpDisplayName: A pointer to a null-terminated UNICODE string that contains the display
	// name by which user interface programs identify the service.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	// dwDesiredAccess: A value that specifies the access to the service. This MUST be one
	// of the values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	// dwServiceType: A value that specifies the type of service. This MUST be one or a
	// combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A value that specifies when to start the service. This MUST be one of
	// the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: A value that specifies the severity of the error if the service fails
	// to start and determines the action that the SCM takes. This MUST be one of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: A pointer to a null-terminated UNICODE string that contains the
	// fully qualified path to the service binary file. The path MAY include arguments.
	// If the path contains a space, it MUST be quoted so that it is correctly interpreted.
	// For example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup: A pointer to a null-terminated UNICODE string that names the load-ordering
	// group of which this service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: A pointer to an array of null-separated names of services or load
	// ordering groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is Unicode. Dependency on a service means that this service can only
	// run if the service it depends on is running. Dependency on a group means that this
	// service can run if at least one member of the group is running after an attempt to
	// start all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the lpDependencies parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: A pointer to a null-terminated UNICODE string that specifies
	// the name of the account under which the service SHOULD run.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A pointer to a null-terminated UNICODE string that contains the password
	// of the account whose name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
}

func (o *CreateServiceWRequest) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOperation {
	if o == nil {
		return &xxx_CreateServiceWOperation{}
	}
	return &xxx_CreateServiceWOperation{
		ServiceManager:   o.ServiceManager,
		ServiceName:      o.ServiceName,
		DisplayName:      o.DisplayName,
		DesiredAccess:    o.DesiredAccess,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
	}
}

func (o *CreateServiceWRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DisplayName = op.DisplayName
	o.DesiredAccess = op.DesiredAccess
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
}
func (o *CreateServiceWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateServiceWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateServiceWResponse structure represents the RCreateServiceW operation response
type CreateServiceWResponse struct {
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly created service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The RCreateServiceW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateServiceWResponse) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOperation {
	if o == nil {
		return &xxx_CreateServiceWOperation{}
	}
	return &xxx_CreateServiceWOperation{
		TagID:   o.TagID,
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *CreateServiceWResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Service = op.Service
	o.Return = op.Return
}
func (o *CreateServiceWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateServiceWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumDependentServicesWOperation structure represents the REnumDependentServicesW operation
type xxx_EnumDependentServicesWOperation struct {
	Service           *Handle `idl:"name:hService" json:"service"`
	ServiceState      uint32  `idl:"name:dwServiceState" json:"service_state"`
	Services          []byte  `idl:"name:lpServices;size_is:(cbBufSize)" json:"services"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32  `idl:"name:lpServicesReturned" json:"services_returned"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumDependentServicesWOperation) OpNum() int { return 13 }

func (o *xxx_EnumDependentServicesWOperation) OpName() string {
	return "/svcctl/v2/REnumDependentServicesW"
}

func (o *xxx_EnumDependentServicesWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServices {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Services {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Services[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Services); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServices {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Services", sizeInfo[0])
		}
		o.Services = make([]byte, sizeInfo[0])
		for i1 := range o.Services {
			i1 := i1
			if err := w.ReadData(&o.Services[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumDependentServicesWRequest structure represents the REnumDependentServicesW operation request
type EnumDependentServicesWRequest struct {
	// hService: An SC_RPC_HANDLE data type that defines the handle to the service record
	// that MUST have been created previously, using one of the open methods specified in
	// section 3.1.4. The SERVICE_ENUMERATE_DEPENDENT access right MUST have been granted
	// to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// the value of their ServiceStatus.dwCurrentState. This MUST be one of the following
	// values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records that have a ServiceStatus.dwCurrentState equal to one |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records that have a ServiceStatus.dwCurrentState equal to     |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates service records that have a ServiceStatus.dwCurrentState equal to one |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the array pointed to by lpServices.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *EnumDependentServicesWRequest) xxx_ToOp(ctx context.Context) *xxx_EnumDependentServicesWOperation {
	if o == nil {
		return &xxx_EnumDependentServicesWOperation{}
	}
	return &xxx_EnumDependentServicesWOperation{
		Service:      o.Service,
		ServiceState: o.ServiceState,
		BufferLength: o.BufferLength,
	}
}

func (o *EnumDependentServicesWRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumDependentServicesWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
}
func (o *EnumDependentServicesWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumDependentServicesWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumDependentServicesWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumDependentServicesWResponse structure represents the REnumDependentServicesW operation response
type EnumDependentServicesWResponse struct {
	// lpServices: A pointer to an array of ENUM_SERVICE_STATUSW (section 2.2.11) structures
	// that contain the name and service status information for each dependent service in
	// the database.
	Services []byte `idl:"name:lpServices;size_is:(cbBufSize)" json:"services"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to store the array of service entries.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// Return: The REnumDependentServicesW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumDependentServicesWResponse) xxx_ToOp(ctx context.Context) *xxx_EnumDependentServicesWOperation {
	if o == nil {
		return &xxx_EnumDependentServicesWOperation{}
	}
	return &xxx_EnumDependentServicesWOperation{
		Services:          o.Services,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		Return:            o.Return,
	}
}

func (o *EnumDependentServicesWResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumDependentServicesWOperation) {
	if o == nil {
		return
	}
	o.Services = op.Services
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.Return = op.Return
}
func (o *EnumDependentServicesWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumDependentServicesWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumDependentServicesWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumServicesStatusWOperation structure represents the REnumServicesStatusW operation
type xxx_EnumServicesStatusWOperation struct {
	ServiceManager    *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceType       uint32  `idl:"name:dwServiceType" json:"service_type"`
	ServiceState      uint32  `idl:"name:dwServiceState" json:"service_state"`
	Buffer            []byte  `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32  `idl:"name:lpServicesReturned" json:"services_returned"`
	ResumeIndex       uint32  `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumServicesStatusWOperation) OpNum() int { return 14 }

func (o *xxx_EnumServicesStatusWOperation) OpName() string { return "/svcctl/v2/REnumServicesStatusW" }

func (o *xxx_EnumServicesStatusWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumServicesStatusWRequest structure represents the REnumServicesStatusW operation request
type EnumServicesStatusWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE access right MUST have
	// been granted to the caller when the RPC context handle to the service record was
	// created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// dwServiceType: A value that specifies what types of service records to enumerate.
	// This MUST be one or a combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system           |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// the value of their ServiceStatus.dwCurrentState. This MUST be one of the following
	// values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records that have ServiceStatus.dwCurrentState equal to one   |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records that have ServiceStatus.dwCurrentState equal to       |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates service records that have ServiceStatus.dwCurrentState equal to one   |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the array pointed to by the lpBuffer parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
}

func (o *EnumServicesStatusWRequest) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusWOperation {
	if o == nil {
		return &xxx_EnumServicesStatusWOperation{}
	}
	return &xxx_EnumServicesStatusWOperation{
		ServiceManager: o.ServiceManager,
		ServiceType:    o.ServiceType,
		ServiceState:   o.ServiceState,
		BufferLength:   o.BufferLength,
		ResumeIndex:    o.ResumeIndex,
	}
}

func (o *EnumServicesStatusWRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceType = op.ServiceType
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
	o.ResumeIndex = op.ResumeIndex
}
func (o *EnumServicesStatusWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumServicesStatusWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumServicesStatusWResponse structure represents the REnumServicesStatusW operation response
type EnumServicesStatusWResponse struct {
	// lpBuffer: A pointer to an array of ENUM_SERVICE_STATUSW (section 2.2.11) structures
	// that contain the name and service status information for each service in the database.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to store the array of service entries.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// Return: The REnumServicesStatusW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumServicesStatusWResponse) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusWOperation {
	if o == nil {
		return &xxx_EnumServicesStatusWOperation{}
	}
	return &xxx_EnumServicesStatusWOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		ResumeIndex:       o.ResumeIndex,
		Return:            o.Return,
	}
}

func (o *EnumServicesStatusWResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusWOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.ResumeIndex = op.ResumeIndex
	o.Return = op.Return
}
func (o *EnumServicesStatusWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumServicesStatusWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenSCMWOperation structure represents the ROpenSCManagerW operation
type xxx_OpenSCMWOperation struct {
	MachineName   string  `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	DatabaseName  string  `idl:"name:lpDatabaseName;string;pointer:unique" json:"database_name"`
	DesiredAccess uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	SCM           *Handle `idl:"name:lpScHandle" json:"scm"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenSCMWOperation) OpNum() int { return 15 }

func (o *xxx_OpenSCMWOperation) OpName() string { return "/svcctl/v2/ROpenSCManagerW" }

func (o *xxx_OpenSCMWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.MachineName) > int(1024) {
		return fmt.Errorf("MachineName is out of range")
	}
	if len(o.DatabaseName) > int(257) {
		return fmt.Errorf("DatabaseName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEW}*(1)[dim:0,string,null](wchar))
	{
		if o.MachineName != "" {
			_ptr_lpMachineName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MachineName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MachineName, _ptr_lpMachineName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDatabaseName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DatabaseName != "" {
			_ptr_lpDatabaseName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DatabaseName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DatabaseName, _ptr_lpDatabaseName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEW}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpMachineName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MachineName); err != nil {
				return err
			}
			return nil
		})
		_s_lpMachineName := func(ptr interface{}) { o.MachineName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MachineName, _s_lpMachineName, _ptr_lpMachineName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDatabaseName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpDatabaseName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DatabaseName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDatabaseName := func(ptr interface{}) { o.DatabaseName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DatabaseName, _s_lpDatabaseName, _ptr_lpDatabaseName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpScHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM != nil {
			if err := o.SCM.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpScHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM == nil {
			o.SCM = &Handle{}
		}
		if err := o.SCM.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenSCMWRequest structure represents the ROpenSCManagerW operation request
type OpenSCMWRequest struct {
	// lpMachineName: An SVCCTL_HANDLEW (section 2.2.3) data type that defines the pointer
	// to a null-terminated UNICODE string that specifies the server's machine name.
	MachineName string `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	// lpDatabaseName: A pointer to a null-terminated UNICODE string that specifies the
	// name of the SCM database to open. The parameter MUST be set to NULL, "ServicesActive",
	// or "ServicesFailed".
	DatabaseName string `idl:"name:lpDatabaseName;string;pointer:unique" json:"database_name"`
	// dwDesiredAccess: A value that specifies the access to the database. This MUST be
	// one of the values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenSCMWRequest) xxx_ToOp(ctx context.Context) *xxx_OpenSCMWOperation {
	if o == nil {
		return &xxx_OpenSCMWOperation{}
	}
	return &xxx_OpenSCMWOperation{
		MachineName:   o.MachineName,
		DatabaseName:  o.DatabaseName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenSCMWRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenSCMWOperation) {
	if o == nil {
		return
	}
	o.MachineName = op.MachineName
	o.DatabaseName = op.DatabaseName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenSCMWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenSCMWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCMWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenSCMWResponse structure represents the ROpenSCManagerW operation response
type OpenSCMWResponse struct {
	// lpScHandle: An LPSC_RPC_HANDLE data type that defines the handle to the newly opened
	// SCM database.
	SCM *Handle `idl:"name:lpScHandle" json:"scm"`
	// Return: The ROpenSCManagerW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenSCMWResponse) xxx_ToOp(ctx context.Context) *xxx_OpenSCMWOperation {
	if o == nil {
		return &xxx_OpenSCMWOperation{}
	}
	return &xxx_OpenSCMWOperation{
		SCM:    o.SCM,
		Return: o.Return,
	}
}

func (o *OpenSCMWResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenSCMWOperation) {
	if o == nil {
		return
	}
	o.SCM = op.SCM
	o.Return = op.Return
}
func (o *OpenSCMWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenSCMWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCMWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenServiceWOperation structure represents the ROpenServiceW operation
type xxx_OpenServiceWOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName    string  `idl:"name:lpServiceName;string" json:"service_name"`
	DesiredAccess  uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	Service        *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenServiceWOperation) OpNum() int { return 16 }

func (o *xxx_OpenServiceWOperation) OpName() string { return "/svcctl/v2/ROpenServiceW" }

func (o *xxx_OpenServiceWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenServiceWRequest structure represents the ROpenServiceW operation request
type OpenServiceWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database, created using one of the open methods specified in section 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated UNICODE string that specifies the ServiceName
	// of the service record.
	//
	// The forward slash, back slash, comma, and space characters are illegal in service
	// names.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// dwDesiredAccess: A value that specifies the access right. This MUST be one of the
	// values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenServiceWRequest) xxx_ToOp(ctx context.Context) *xxx_OpenServiceWOperation {
	if o == nil {
		return &xxx_OpenServiceWOperation{}
	}
	return &xxx_OpenServiceWOperation{
		ServiceManager: o.ServiceManager,
		ServiceName:    o.ServiceName,
		DesiredAccess:  o.DesiredAccess,
	}
}

func (o *OpenServiceWRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenServiceWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenServiceWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenServiceWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenServiceWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenServiceWResponse structure represents the ROpenServiceW operation response
type OpenServiceWResponse struct {
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the found service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The ROpenServiceW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenServiceWResponse) xxx_ToOp(ctx context.Context) *xxx_OpenServiceWOperation {
	if o == nil {
		return &xxx_OpenServiceWOperation{}
	}
	return &xxx_OpenServiceWOperation{
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *OpenServiceWResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenServiceWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Return = op.Return
}
func (o *OpenServiceWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenServiceWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenServiceWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceConfigWOperation structure represents the RQueryServiceConfigW operation
type xxx_QueryServiceConfigWOperation struct {
	Service           *Handle              `idl:"name:hService" json:"service"`
	ServiceConfig     *QueryServiceConfigW `idl:"name:lpServiceConfig" json:"service_config"`
	BufferLength      uint32               `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32               `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceConfigWOperation) OpNum() int { return 17 }

func (o *xxx_QueryServiceConfigWOperation) OpName() string { return "/svcctl/v2/RQueryServiceConfigW" }

func (o *xxx_QueryServiceConfigWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(8192) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceConfig {out} (1:{alias=LPQUERY_SERVICE_CONFIGW}*(1))(2:{alias=QUERY_SERVICE_CONFIGW}(struct))
	{
		if o.ServiceConfig != nil {
			if err := o.ServiceConfig.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&QueryServiceConfigW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceConfig {out} (1:{alias=LPQUERY_SERVICE_CONFIGW,pointer=ref}*(1))(2:{alias=QUERY_SERVICE_CONFIGW}(struct))
	{
		if o.ServiceConfig == nil {
			o.ServiceConfig = &QueryServiceConfigW{}
		}
		if err := o.ServiceConfig.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K,pointer=ref}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceConfigWRequest structure represents the RQueryServiceConfigW operation request
type QueryServiceConfigWRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// cbBufSize: The size, in bytes, of the lpServiceConfig parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceConfigWRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigWOperation {
	if o == nil {
		return &xxx_QueryServiceConfigWOperation{}
	}
	return &xxx_QueryServiceConfigWOperation{
		Service:      o.Service,
		BufferLength: o.BufferLength,
	}
}

func (o *QueryServiceConfigWRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceConfigWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceConfigWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceConfigWResponse structure represents the RQueryServiceConfigW operation response
type QueryServiceConfigWResponse struct {
	// lpServiceConfig: A pointer to a buffer that contains the QUERY_SERVICE_CONFIGW (section
	// 2.2.15) structure.
	ServiceConfig *QueryServiceConfigW `idl:"name:lpServiceConfig" json:"service_config"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_8K (section 2.2.8) data type that defines the
	// pointer to a variable that contains the number of bytes needed to return all the
	// configuration information if the method fails.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceConfigW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceConfigWResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigWOperation {
	if o == nil {
		return &xxx_QueryServiceConfigWOperation{}
	}
	return &xxx_QueryServiceConfigWOperation{
		ServiceConfig:     o.ServiceConfig,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceConfigWResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigWOperation) {
	if o == nil {
		return
	}
	o.ServiceConfig = op.ServiceConfig
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceConfigWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceConfigWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceLockStatusWOperation structure represents the RQueryServiceLockStatusW operation
type xxx_QueryServiceLockStatusWOperation struct {
	ServiceManager    *Handle                  `idl:"name:hSCManager" json:"service_manager"`
	LockStatus        *QueryServiceLockStatusW `idl:"name:lpLockStatus" json:"lock_status"`
	BufferLength      uint32                   `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32                   `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceLockStatusWOperation) OpNum() int { return 18 }

func (o *xxx_QueryServiceLockStatusWOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceLockStatusW"
}

func (o *xxx_QueryServiceLockStatusWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(4096) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpLockStatus {out} (1:{alias=LPQUERY_SERVICE_LOCK_STATUSW}*(1))(2:{alias=QUERY_SERVICE_LOCK_STATUSW}(struct))
	{
		if o.LockStatus != nil {
			if err := o.LockStatus.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&QueryServiceLockStatusW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpLockStatus {out} (1:{alias=LPQUERY_SERVICE_LOCK_STATUSW,pointer=ref}*(1))(2:{alias=QUERY_SERVICE_LOCK_STATUSW}(struct))
	{
		if o.LockStatus == nil {
			o.LockStatus = &QueryServiceLockStatusW{}
		}
		if err := o.LockStatus.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceLockStatusWRequest structure represents the RQueryServiceLockStatusW operation request
type QueryServiceLockStatusWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The SC_MANAGER_QUERY_LOCK_STATUS access right MUST have been granted to the caller
	// when the RPC context handle was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// cbBufSize: The size, in bytes, of the lpLockStatus buffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceLockStatusWRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceLockStatusWOperation {
	if o == nil {
		return &xxx_QueryServiceLockStatusWOperation{}
	}
	return &xxx_QueryServiceLockStatusWOperation{
		ServiceManager: o.ServiceManager,
		BufferLength:   o.BufferLength,
	}
}

func (o *QueryServiceLockStatusWRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceLockStatusWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceLockStatusWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceLockStatusWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceLockStatusWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceLockStatusWResponse structure represents the RQueryServiceLockStatusW operation response
type QueryServiceLockStatusWResponse struct {
	// lpLockStatus: A pointer to a buffer that contains QUERY_SERVICE_LOCK_STATUSW (section
	// 2.2.17) structures.
	LockStatus *QueryServiceLockStatusW `idl:"name:lpLockStatus" json:"lock_status"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the
	// pointer to a variable that receives the number of bytes needed to return all the
	// lock status information if the method fails.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceLockStatusW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceLockStatusWResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceLockStatusWOperation {
	if o == nil {
		return &xxx_QueryServiceLockStatusWOperation{}
	}
	return &xxx_QueryServiceLockStatusWOperation{
		LockStatus:        o.LockStatus,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceLockStatusWResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceLockStatusWOperation) {
	if o == nil {
		return
	}
	o.LockStatus = op.LockStatus
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceLockStatusWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceLockStatusWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceLockStatusWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartServiceWOperation structure represents the RStartServiceW operation
type xxx_StartServiceWOperation struct {
	Service *Handle          `idl:"name:hService" json:"service"`
	Argc    uint32           `idl:"name:argc" json:"argc"`
	Argv    []*UnicodeString `idl:"name:argv;size_is:(argc);pointer:unique" json:"argv"`
	Return  uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_StartServiceWOperation) OpNum() int { return 19 }

func (o *xxx_StartServiceWOperation) OpName() string { return "/svcctl/v2/RStartServiceW" }

func (o *xxx_StartServiceWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Argv != nil && o.Argc == 0 {
		o.Argc = uint32(len(o.Argv))
	}
	if o.Argc > uint32(1024) {
		return fmt.Errorf("Argc is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// argc {in} (1:{range=(0,1024), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Argc); err != nil {
			return err
		}
	}
	// argv {in} (1:{pointer=unique, alias=LPSTRING_PTRSW}*(1))(2:{alias=STRING_PTRSW}[dim:0,size_is=argc](struct))
	{
		if o.Argv != nil || o.Argc > 0 {
			_ptr_argv := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.Argc)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Argv {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Argv[i1] != nil {
						if err := o.Argv[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&UnicodeString{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Argv); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Argv, _ptr_argv); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// argc {in} (1:{range=(0,1024), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Argc); err != nil {
			return err
		}
	}
	// argv {in} (1:{pointer=unique, alias=LPSTRING_PTRSW}*(1))(2:{alias=STRING_PTRSW}[dim:0,size_is=argc](struct))
	{
		_ptr_argv := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Argv", sizeInfo[0])
			}
			o.Argv = make([]*UnicodeString, sizeInfo[0])
			for i1 := range o.Argv {
				i1 := i1
				if o.Argv[i1] == nil {
					o.Argv[i1] = &UnicodeString{}
				}
				if err := o.Argv[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_argv := func(ptr interface{}) { o.Argv = *ptr.(*[]*UnicodeString) }
		if err := w.ReadPointer(&o.Argv, _s_argv, _ptr_argv); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartServiceWRequest structure represents the RStartServiceW operation request
type StartServiceWRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously using one of the open methods
	// specified in section 3.1.4. The SERVICE_START access right MUST have been granted
	// to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// argc: The number of argument strings in the argv array. If argv is NULL, this parameter
	// MAY be 0.
	Argc uint32 `idl:"name:argc" json:"argc"`
	// argv: A pointer to a buffer that contains an array of pointers to null-terminated
	// UNICODE strings that are passed as arguments to the service.
	Argv []*UnicodeString `idl:"name:argv;size_is:(argc);pointer:unique" json:"argv"`
}

func (o *StartServiceWRequest) xxx_ToOp(ctx context.Context) *xxx_StartServiceWOperation {
	if o == nil {
		return &xxx_StartServiceWOperation{}
	}
	return &xxx_StartServiceWOperation{
		Service: o.Service,
		Argc:    o.Argc,
		Argv:    o.Argv,
	}
}

func (o *StartServiceWRequest) xxx_FromOp(ctx context.Context, op *xxx_StartServiceWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Argc = op.Argc
	o.Argv = op.Argv
}
func (o *StartServiceWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *StartServiceWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServiceWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartServiceWResponse structure represents the RStartServiceW operation response
type StartServiceWResponse struct {
	// Return: The RStartServiceW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartServiceWResponse) xxx_ToOp(ctx context.Context) *xxx_StartServiceWOperation {
	if o == nil {
		return &xxx_StartServiceWOperation{}
	}
	return &xxx_StartServiceWOperation{
		Return: o.Return,
	}
}

func (o *StartServiceWResponse) xxx_FromOp(ctx context.Context, op *xxx_StartServiceWOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *StartServiceWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *StartServiceWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServiceWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServiceDisplayNameWOperation structure represents the RGetServiceDisplayNameW operation
type xxx_GetServiceDisplayNameWOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName    string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName    string  `idl:"name:lpDisplayName;size_is:((lpcchBuffer+1));string" json:"display_name"`
	BufferLength   uint32  `idl:"name:lpcchBuffer" json:"buffer_length"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServiceDisplayNameWOperation) OpNum() int { return 20 }

func (o *xxx_GetServiceDisplayNameWOperation) OpName() string {
	return "/svcctl/v2/RGetServiceDisplayNameW"
}

func (o *xxx_GetServiceDisplayNameWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.DisplayName != "" && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.DisplayName))
	}
	if len(o.DisplayName) > int(4097) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpDisplayName {out} (1:{string, pointer=ref, range=(1,4097)}*(1)[dim:0,size_is=(lpcchBuffer+1),string,null](wchar))
	{
		dimSize1 := uint64((o.BufferLength + 1))
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := ndr.UTF16NLen(o.DisplayName)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		_DisplayName_buf := utf16.Encode([]rune(o.DisplayName))
		if uint64(len(_DisplayName_buf)) > sizeInfo[0]-1 {
			_DisplayName_buf = _DisplayName_buf[:sizeInfo[0]-1]
		}
		if o.DisplayName != ndr.ZeroString {
			_DisplayName_buf = append(_DisplayName_buf, uint16(0))
		}
		for i1 := range _DisplayName_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_DisplayName_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_DisplayName_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpDisplayName {out} (1:{string, pointer=ref, range=(1,4097)}*(1)[dim:0,size_is=(lpcchBuffer+1),string,null](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _DisplayName_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _DisplayName_buf", sizeInfo[0])
		}
		_DisplayName_buf = make([]uint16, sizeInfo[0])
		for i1 := range _DisplayName_buf {
			i1 := i1
			if err := w.ReadData(&_DisplayName_buf[i1]); err != nil {
				return err
			}
		}
		o.DisplayName = strings.TrimRight(string(utf16.Decode(_DisplayName_buf)), ndr.ZeroString)
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServiceDisplayNameWRequest structure represents the RGetServiceDisplayNameW operation request
type GetServiceDisplayNameWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database, created using one of the open methods specified in section 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated UNICODE string that specifies the service
	// name.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpcchBuffer: A DWORD data type that defines the pointer to a variable that specifies
	// the size, in wchar_ts, of the buffer. On output, this variable receives the size
	// of the service's display name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
}

func (o *GetServiceDisplayNameWRequest) xxx_ToOp(ctx context.Context) *xxx_GetServiceDisplayNameWOperation {
	if o == nil {
		return &xxx_GetServiceDisplayNameWOperation{}
	}
	return &xxx_GetServiceDisplayNameWOperation{
		ServiceManager: o.ServiceManager,
		ServiceName:    o.ServiceName,
		BufferLength:   o.BufferLength,
	}
}

func (o *GetServiceDisplayNameWRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServiceDisplayNameWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.BufferLength = op.BufferLength
}
func (o *GetServiceDisplayNameWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetServiceDisplayNameWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceDisplayNameWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServiceDisplayNameWResponse structure represents the RGetServiceDisplayNameW operation response
type GetServiceDisplayNameWResponse struct {
	// lpDisplayName: A pointer to a buffer that receives the null-terminated UNICODE string
	// that contains the service display name.
	DisplayName string `idl:"name:lpDisplayName;size_is:((lpcchBuffer+1));string" json:"display_name"`
	// lpcchBuffer: A DWORD data type that defines the pointer to a variable that specifies
	// the size, in wchar_ts, of the buffer. On output, this variable receives the size
	// of the service's display name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
	// Return: The RGetServiceDisplayNameW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServiceDisplayNameWResponse) xxx_ToOp(ctx context.Context) *xxx_GetServiceDisplayNameWOperation {
	if o == nil {
		return &xxx_GetServiceDisplayNameWOperation{}
	}
	return &xxx_GetServiceDisplayNameWOperation{
		DisplayName:  o.DisplayName,
		BufferLength: o.BufferLength,
		Return:       o.Return,
	}
}

func (o *GetServiceDisplayNameWResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServiceDisplayNameWOperation) {
	if o == nil {
		return
	}
	o.DisplayName = op.DisplayName
	o.BufferLength = op.BufferLength
	o.Return = op.Return
}
func (o *GetServiceDisplayNameWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetServiceDisplayNameWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceDisplayNameWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServiceKeyNameWOperation structure represents the RGetServiceKeyNameW operation
type xxx_GetServiceKeyNameWOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	DisplayName    string  `idl:"name:lpDisplayName;string" json:"display_name"`
	ServiceName    string  `idl:"name:lpServiceName;size_is:((lpcchBuffer+1));string" json:"service_name"`
	BufferLength   uint32  `idl:"name:lpcchBuffer" json:"buffer_length"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServiceKeyNameWOperation) OpNum() int { return 21 }

func (o *xxx_GetServiceKeyNameWOperation) OpName() string { return "/svcctl/v2/RGetServiceKeyNameW" }

func (o *xxx_GetServiceKeyNameWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpDisplayName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.ServiceName != "" && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.ServiceName))
	}
	if len(o.ServiceName) > int(4097) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceName {out} (1:{string, pointer=ref, range=(1,4097)}*(1)[dim:0,size_is=(lpcchBuffer+1),string,null](wchar))
	{
		dimSize1 := uint64((o.BufferLength + 1))
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := ndr.UTF16NLen(o.ServiceName)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		_ServiceName_buf := utf16.Encode([]rune(o.ServiceName))
		if uint64(len(_ServiceName_buf)) > sizeInfo[0]-1 {
			_ServiceName_buf = _ServiceName_buf[:sizeInfo[0]-1]
		}
		if o.ServiceName != ndr.ZeroString {
			_ServiceName_buf = append(_ServiceName_buf, uint16(0))
		}
		for i1 := range _ServiceName_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_ServiceName_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_ServiceName_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceName {out} (1:{string, pointer=ref, range=(1,4097)}*(1)[dim:0,size_is=(lpcchBuffer+1),string,null](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _ServiceName_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _ServiceName_buf", sizeInfo[0])
		}
		_ServiceName_buf = make([]uint16, sizeInfo[0])
		for i1 := range _ServiceName_buf {
			i1 := i1
			if err := w.ReadData(&_ServiceName_buf[i1]); err != nil {
				return err
			}
		}
		o.ServiceName = strings.TrimRight(string(utf16.Decode(_ServiceName_buf)), ndr.ZeroString)
	}
	// lpcchBuffer {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServiceKeyNameWRequest structure represents the RGetServiceKeyNameW operation request
type GetServiceKeyNameWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpDisplayName: A pointer to a null-terminated UNICODE string that specifies the service
	// display name.
	DisplayName string `idl:"name:lpDisplayName;string" json:"display_name"`
	// lpcchBuffer: A DWORD data type that defines the pointer to a variable that specifies
	// the size, in wchar_ts, of the buffer. On output, this variable receives the size
	// of the service name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
}

func (o *GetServiceKeyNameWRequest) xxx_ToOp(ctx context.Context) *xxx_GetServiceKeyNameWOperation {
	if o == nil {
		return &xxx_GetServiceKeyNameWOperation{}
	}
	return &xxx_GetServiceKeyNameWOperation{
		ServiceManager: o.ServiceManager,
		DisplayName:    o.DisplayName,
		BufferLength:   o.BufferLength,
	}
}

func (o *GetServiceKeyNameWRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServiceKeyNameWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.DisplayName = op.DisplayName
	o.BufferLength = op.BufferLength
}
func (o *GetServiceKeyNameWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetServiceKeyNameWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceKeyNameWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServiceKeyNameWResponse structure represents the RGetServiceKeyNameW operation response
type GetServiceKeyNameWResponse struct {
	// lpServiceName: A pointer to a buffer that receives the null-terminated UNICODE string
	// that contains the service name.
	ServiceName string `idl:"name:lpServiceName;size_is:((lpcchBuffer+1));string" json:"service_name"`
	// lpcchBuffer: A DWORD data type that defines the pointer to a variable that specifies
	// the size, in wchar_ts, of the buffer. On output, this variable receives the size
	// of the service name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
	// Return: The RGetServiceKeyNameW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServiceKeyNameWResponse) xxx_ToOp(ctx context.Context) *xxx_GetServiceKeyNameWOperation {
	if o == nil {
		return &xxx_GetServiceKeyNameWOperation{}
	}
	return &xxx_GetServiceKeyNameWOperation{
		ServiceName:  o.ServiceName,
		BufferLength: o.BufferLength,
		Return:       o.Return,
	}
}

func (o *GetServiceKeyNameWResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServiceKeyNameWOperation) {
	if o == nil {
		return
	}
	o.ServiceName = op.ServiceName
	o.BufferLength = op.BufferLength
	o.Return = op.Return
}
func (o *GetServiceKeyNameWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetServiceKeyNameWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceKeyNameWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeServiceConfigAOperation structure represents the RChangeServiceConfigA operation
type xxx_ChangeServiceConfigAOperation struct {
	Service          *Handle `idl:"name:hService" json:"service"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string;pointer:unique" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeServiceConfigAOperation) OpNum() int { return 23 }

func (o *xxx_ChangeServiceConfigAOperation) OpName() string {
	return "/svcctl/v2/RChangeServiceConfigA"
}

func (o *xxx_ChangeServiceConfigAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=unique, range=(0,32768), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.BinaryPathName != "" {
			_ptr_lpBinaryPathName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.BinaryPathName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.BinaryPathName, _ptr_lpBinaryPathName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=unique, range=(0,32768), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpBinaryPathName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.BinaryPathName); err != nil {
				return err
			}
			return nil
		})
		_s_lpBinaryPathName := func(ptr interface{}) { o.BinaryPathName = *ptr.(*string) }
		if err := w.ReadPointer(&o.BinaryPathName, _s_lpBinaryPathName, _ptr_lpBinaryPathName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfigAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeServiceConfigARequest structure represents the RChangeServiceConfigA operation request
type ChangeServiceConfigARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_CHANGE_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwServiceType: A Type value for the service record (section 3.1.1) that specifies
	// the type of service. This MUST be one of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF           | Service type does not change.                                                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//
	// The following flag can also be combined with the value passed in dwServiceType.
	//
	//	+----------------------------------------+--------------------------------------------+
	//	|                                        |                                            |
	//	|                 VALUE                  |                  MEANING                   |
	//	|                                        |                                            |
	//	+----------------------------------------+--------------------------------------------+
	//	+----------------------------------------+--------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop. |
	//	+----------------------------------------+--------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A Start value for the service record (section 3.1.1) that specifies
	// when to start the service. This MUST be one of the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF    | Service start type does not change.                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: An ErrorControl value for the service record (section 3.1.1) that
	// specifies the severity of the error if the service fails to start and determines
	// the action that the SCM takes. This MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_NO_CHANGE 0xFFFFFFFF      | Service error control type does not change.                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: An ImagePath value for the service record (section 3.1.1) as a
	// pointer to a null-terminated ANSI string that contains the fully qualified path to
	// the service binary file. The path MAY include arguments. If the path contains a space,
	// it MUST be quoted so that it is correctly interpreted. For example, "d:\\my share\\myservice.exe"
	// is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string;pointer:unique" json:"binary_path_name"`
	// lpLoadOrderGroup: A Group value for the service record (section 3.1.1) as a pointer
	// to a null-terminated ANSI string that names the load ordering group of which this
	// service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A Tag value for the service record (section 3.1.1) as a pointer to a variable
	// that receives a tag value. The value is unique to the group specified in the lpLoadOrderGroup
	// parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: DependOnSize and DependOnGroup values for the service record (section
	// 3.1.1) as a pointer to an array of null-separated names of services or load ordering
	// groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is ANSI. Dependency on a service means that this service can only run
	// if the service it depends on is running. Dependency on a group means that this service
	// can run if at least one member of the group is running after an attempt to start
	// all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the lpDependencies parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: An ObjectName value for the service record (section 3.1.1) as
	// a pointer to a null-terminated ANSI string that specifies the name of the account
	// under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A Password value for the service record (section 3.1.1) as a pointer
	// to a null-terminated ANSI string that contains the password of the account whose
	// name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
	// lpDisplayName: A DisplayName value for the service record (section 3.1.1) as a pointer
	// to a null-terminated ANSI string that contains the display name that applications
	// can use to identify the service for its users.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
}

func (o *ChangeServiceConfigARequest) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfigAOperation {
	if o == nil {
		return &xxx_ChangeServiceConfigAOperation{}
	}
	return &xxx_ChangeServiceConfigAOperation{
		Service:          o.Service,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
		DisplayName:      o.DisplayName,
	}
}

func (o *ChangeServiceConfigARequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfigAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
	o.DisplayName = op.DisplayName
}
func (o *ChangeServiceConfigARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeServiceConfigARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfigAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeServiceConfigAResponse structure represents the RChangeServiceConfigA operation response
type ChangeServiceConfigAResponse struct {
	// lpdwTagId: A Tag value for the service record (section 3.1.1) as a pointer to a variable
	// that receives a tag value. The value is unique to the group specified in the lpLoadOrderGroup
	// parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// Return: The RChangeServiceConfigA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeServiceConfigAResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfigAOperation {
	if o == nil {
		return &xxx_ChangeServiceConfigAOperation{}
	}
	return &xxx_ChangeServiceConfigAOperation{
		TagID:  o.TagID,
		Return: o.Return,
	}
}

func (o *ChangeServiceConfigAResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfigAOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Return = op.Return
}
func (o *ChangeServiceConfigAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeServiceConfigAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfigAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateServiceAOperation structure represents the RCreateServiceA operation
type xxx_CreateServiceAOperation struct {
	ServiceManager   *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName      string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	DesiredAccess    uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	Service          *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateServiceAOperation) OpNum() int { return 24 }

func (o *xxx_CreateServiceAOperation) OpName() string { return "/svcctl/v2/RCreateServiceA" }

func (o *xxx_CreateServiceAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, range=(0,32768), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, range=(0,32768), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateServiceARequest structure represents the RCreateServiceA operation request
type CreateServiceARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The SC_MANAGER_CREATE_SERVICE access right MUST have been granted to the caller when
	// the RPC context handle was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated ANSI string that specifies the name
	// of the service to install. This MUST not be null.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpDisplayName: A pointer to a null-terminated ANSI string that contains the display
	// name by which user interface programs identify the service.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	// dwDesiredAccess: A value that specifies the access to the service. This MUST be one
	// of the values specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	// dwServiceType: A value that specifies the type of service. This MUST be one or a
	// combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A value that specifies when to start the service. This MUST be one of
	// the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | The SCM starts the service when a process calls the StartService function. For   |
	//	|                                 | more information, see [MSDN-STARTSERVICE].                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: A value that specifies the severity of the error if the service fails
	// to start and determines the action that the SCM takes. This MUST be one of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: A pointer to a null-terminated ANSI string that contains the fully
	// qualified path to the service binary file. The path MAY include arguments. If the
	// path contains a space, it MUST be quoted so that it is correctly interpreted. For
	// example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup: A pointer to a null-terminated ANSI string that names the load-ordering
	// group of which this service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: A pointer to an array of null-separated names of services or load
	// ordering groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is ANSI. Dependency on a service means that this service can only run
	// if the service it depends on is running. Dependency on a group means that this service
	// can run if at least one member of the group is running after an attempt to start
	// all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the lpDependencies parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: A pointer to a null-terminated ANSI string that specifies the
	// name of the account under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A pointer to a null-terminated ANSI string that contains the password
	// of the account whose name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
}

func (o *CreateServiceARequest) xxx_ToOp(ctx context.Context) *xxx_CreateServiceAOperation {
	if o == nil {
		return &xxx_CreateServiceAOperation{}
	}
	return &xxx_CreateServiceAOperation{
		ServiceManager:   o.ServiceManager,
		ServiceName:      o.ServiceName,
		DisplayName:      o.DisplayName,
		DesiredAccess:    o.DesiredAccess,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
	}
}

func (o *CreateServiceARequest) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DisplayName = op.DisplayName
	o.DesiredAccess = op.DesiredAccess
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
}
func (o *CreateServiceARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateServiceARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateServiceAResponse structure represents the RCreateServiceA operation response
type CreateServiceAResponse struct {
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly created service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The RCreateServiceA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateServiceAResponse) xxx_ToOp(ctx context.Context) *xxx_CreateServiceAOperation {
	if o == nil {
		return &xxx_CreateServiceAOperation{}
	}
	return &xxx_CreateServiceAOperation{
		TagID:   o.TagID,
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *CreateServiceAResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceAOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Service = op.Service
	o.Return = op.Return
}
func (o *CreateServiceAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateServiceAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumDependentServicesAOperation structure represents the REnumDependentServicesA operation
type xxx_EnumDependentServicesAOperation struct {
	Service           *Handle `idl:"name:hService" json:"service"`
	ServiceState      uint32  `idl:"name:dwServiceState" json:"service_state"`
	Services          []byte  `idl:"name:lpServices;size_is:(cbBufSize)" json:"services"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32  `idl:"name:lpServicesReturned" json:"services_returned"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumDependentServicesAOperation) OpNum() int { return 25 }

func (o *xxx_EnumDependentServicesAOperation) OpName() string {
	return "/svcctl/v2/REnumDependentServicesA"
}

func (o *xxx_EnumDependentServicesAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServices {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Services {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Services[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Services); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumDependentServicesAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServices {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Services", sizeInfo[0])
		}
		o.Services = make([]byte, sizeInfo[0])
		for i1 := range o.Services {
			i1 := i1
			if err := w.ReadData(&o.Services[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumDependentServicesARequest structure represents the REnumDependentServicesA operation request
type EnumDependentServicesARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_ENUMERATE_DEPENDENT access right MUST have
	// been granted to the caller when the RPC context handle to the service record was
	// created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// the value of their ServiceStatus.dwCurrentState. This MUST be one of the following
	// values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records that have ServiceStatus.dwCurrentState equal to one   |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records that have ServiceStatus.dwCurrentState equal to       |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates services that have ServiceStatus.dwCurrentState equal to one of       |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the array pointed to by lpServices.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *EnumDependentServicesARequest) xxx_ToOp(ctx context.Context) *xxx_EnumDependentServicesAOperation {
	if o == nil {
		return &xxx_EnumDependentServicesAOperation{}
	}
	return &xxx_EnumDependentServicesAOperation{
		Service:      o.Service,
		ServiceState: o.ServiceState,
		BufferLength: o.BufferLength,
	}
}

func (o *EnumDependentServicesARequest) xxx_FromOp(ctx context.Context, op *xxx_EnumDependentServicesAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
}
func (o *EnumDependentServicesARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumDependentServicesARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumDependentServicesAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumDependentServicesAResponse structure represents the REnumDependentServicesA operation response
type EnumDependentServicesAResponse struct {
	// lpServices: A pointer to an array of ENUM_SERVICE_STATUSA (section 2.2.10) structures
	// that contain the name and service status information for each dependent service record
	// in the database.
	Services []byte `idl:"name:lpServices;size_is:(cbBufSize)" json:"services"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to store the array of service entries.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// Return: The REnumDependentServicesA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumDependentServicesAResponse) xxx_ToOp(ctx context.Context) *xxx_EnumDependentServicesAOperation {
	if o == nil {
		return &xxx_EnumDependentServicesAOperation{}
	}
	return &xxx_EnumDependentServicesAOperation{
		Services:          o.Services,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		Return:            o.Return,
	}
}

func (o *EnumDependentServicesAResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumDependentServicesAOperation) {
	if o == nil {
		return
	}
	o.Services = op.Services
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.Return = op.Return
}
func (o *EnumDependentServicesAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumDependentServicesAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumDependentServicesAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumServicesStatusAOperation structure represents the REnumServicesStatusA operation
type xxx_EnumServicesStatusAOperation struct {
	ServiceManager    *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceType       uint32  `idl:"name:dwServiceType" json:"service_type"`
	ServiceState      uint32  `idl:"name:dwServiceState" json:"service_state"`
	Buffer            []byte  `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32  `idl:"name:lpServicesReturned" json:"services_returned"`
	ResumeIndex       uint32  `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumServicesStatusAOperation) OpNum() int { return 26 }

func (o *xxx_EnumServicesStatusAOperation) OpName() string { return "/svcctl/v2/REnumServicesStatusA" }

func (o *xxx_EnumServicesStatusAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumServicesStatusARequest structure represents the REnumServicesStatusA operation request
type EnumServicesStatusARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE access right MUST have
	// been granted to the caller when the RPC context handle to the service record was
	// created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// dwServiceType: A value that specifies the service records to enumerate based on the
	// Type value. This MUST be one or a combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// their ServiceStatus.dwCurrentState. This MUST be one of the following values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records that have ServiceStatus.dwCurrentState equal to one   |
	//	|                              | of the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,  |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates services that have ServiceStatus.dwCurrentState equal to              |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates services that have ServiceStatus.dwCurrentState equal to one of       |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the array pointed to by lpBuffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
}

func (o *EnumServicesStatusARequest) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusAOperation {
	if o == nil {
		return &xxx_EnumServicesStatusAOperation{}
	}
	return &xxx_EnumServicesStatusAOperation{
		ServiceManager: o.ServiceManager,
		ServiceType:    o.ServiceType,
		ServiceState:   o.ServiceState,
		BufferLength:   o.BufferLength,
		ResumeIndex:    o.ResumeIndex,
	}
}

func (o *EnumServicesStatusARequest) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceType = op.ServiceType
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
	o.ResumeIndex = op.ResumeIndex
}
func (o *EnumServicesStatusARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumServicesStatusARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumServicesStatusAResponse structure represents the REnumServicesStatusA operation response
type EnumServicesStatusAResponse struct {
	// lpBuffer: A pointer to an array of ENUM_SERVICE_STATUSA (section 2.2.10) structures
	// that contain the name and service status information for each dependent service in
	// the database.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to store the array of service entries.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// Return: The REnumServicesStatusA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumServicesStatusAResponse) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusAOperation {
	if o == nil {
		return &xxx_EnumServicesStatusAOperation{}
	}
	return &xxx_EnumServicesStatusAOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		ResumeIndex:       o.ResumeIndex,
		Return:            o.Return,
	}
}

func (o *EnumServicesStatusAResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusAOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.ResumeIndex = op.ResumeIndex
	o.Return = op.Return
}
func (o *EnumServicesStatusAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumServicesStatusAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenSCMAOperation structure represents the ROpenSCManagerA operation
type xxx_OpenSCMAOperation struct {
	MachineName   string  `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	DatabaseName  string  `idl:"name:lpDatabaseName;string;pointer:unique" json:"database_name"`
	DesiredAccess uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	SCM           *Handle `idl:"name:lpScHandle" json:"scm"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenSCMAOperation) OpNum() int { return 27 }

func (o *xxx_OpenSCMAOperation) OpName() string { return "/svcctl/v2/ROpenSCManagerA" }

func (o *xxx_OpenSCMAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.MachineName) > int(1024) {
		return fmt.Errorf("MachineName is out of range")
	}
	if len(o.DatabaseName) > int(257) {
		return fmt.Errorf("DatabaseName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEA, names=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.MachineName != "" {
			_ptr_lpMachineName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.MachineName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MachineName, _ptr_lpMachineName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDatabaseName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.DatabaseName != "" {
			_ptr_lpDatabaseName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.DatabaseName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DatabaseName, _ptr_lpDatabaseName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpMachineName {in} (1:{handle, string, pointer=unique, range=(0,1024), alias=SVCCTL_HANDLEA, names=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpMachineName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.MachineName); err != nil {
				return err
			}
			return nil
		})
		_s_lpMachineName := func(ptr interface{}) { o.MachineName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MachineName, _s_lpMachineName, _ptr_lpMachineName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDatabaseName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpDatabaseName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.DatabaseName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDatabaseName := func(ptr interface{}) { o.DatabaseName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DatabaseName, _s_lpDatabaseName, _ptr_lpDatabaseName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpScHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM != nil {
			if err := o.SCM.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCMAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpScHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM == nil {
			o.SCM = &Handle{}
		}
		if err := o.SCM.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenSCMARequest structure represents the ROpenSCManagerA operation request
type OpenSCMARequest struct {
	// lpMachineName: An SVCCTL_HANDLEA (section 2.2.2) data type that defines the pointer
	// to a null-terminated ANSI string that specifies the server's machine name.
	MachineName string `idl:"name:lpMachineName;string;pointer:unique" json:"machine_name"`
	// lpDatabaseName: A pointer to a null-terminated ANSI string that specifies the name
	// of the SCM database to open. The parameter MUST be set to NULL,  "ServicesActive",
	// or "ServicesFailed".
	DatabaseName string `idl:"name:lpDatabaseName;string;pointer:unique" json:"database_name"`
	// dwDesiredAccess: A value that specifies the access to the database. This MUST be
	// one of the values specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenSCMARequest) xxx_ToOp(ctx context.Context) *xxx_OpenSCMAOperation {
	if o == nil {
		return &xxx_OpenSCMAOperation{}
	}
	return &xxx_OpenSCMAOperation{
		MachineName:   o.MachineName,
		DatabaseName:  o.DatabaseName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenSCMARequest) xxx_FromOp(ctx context.Context, op *xxx_OpenSCMAOperation) {
	if o == nil {
		return
	}
	o.MachineName = op.MachineName
	o.DatabaseName = op.DatabaseName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenSCMARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenSCMARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCMAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenSCMAResponse structure represents the ROpenSCManagerA operation response
type OpenSCMAResponse struct {
	// lpScHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly opened SCM connection.
	SCM *Handle `idl:"name:lpScHandle" json:"scm"`
	// Return: The ROpenSCManagerA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenSCMAResponse) xxx_ToOp(ctx context.Context) *xxx_OpenSCMAOperation {
	if o == nil {
		return &xxx_OpenSCMAOperation{}
	}
	return &xxx_OpenSCMAOperation{
		SCM:    o.SCM,
		Return: o.Return,
	}
}

func (o *OpenSCMAResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenSCMAOperation) {
	if o == nil {
		return
	}
	o.SCM = op.SCM
	o.Return = op.Return
}
func (o *OpenSCMAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenSCMAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCMAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenServiceAOperation structure represents the ROpenServiceA operation
type xxx_OpenServiceAOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName    string  `idl:"name:lpServiceName;string" json:"service_name"`
	DesiredAccess  uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	Service        *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenServiceAOperation) OpNum() int { return 28 }

func (o *xxx_OpenServiceAOperation) OpName() string { return "/svcctl/v2/ROpenServiceA" }

func (o *xxx_OpenServiceAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenServiceAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenServiceARequest structure represents the ROpenServiceA operation request
type OpenServiceARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database, created using one of the open methods specified in section 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated ANSI string that specifies the ServiceName
	// of the service record to open.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// dwDesiredAccess: A value that specifies the access right. This MUST be one of the
	// values specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
}

func (o *OpenServiceARequest) xxx_ToOp(ctx context.Context) *xxx_OpenServiceAOperation {
	if o == nil {
		return &xxx_OpenServiceAOperation{}
	}
	return &xxx_OpenServiceAOperation{
		ServiceManager: o.ServiceManager,
		ServiceName:    o.ServiceName,
		DesiredAccess:  o.DesiredAccess,
	}
}

func (o *OpenServiceARequest) xxx_FromOp(ctx context.Context, op *xxx_OpenServiceAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenServiceARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenServiceARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenServiceAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenServiceAResponse structure represents the ROpenServiceA operation response
type OpenServiceAResponse struct {
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the found service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The ROpenServiceA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenServiceAResponse) xxx_ToOp(ctx context.Context) *xxx_OpenServiceAOperation {
	if o == nil {
		return &xxx_OpenServiceAOperation{}
	}
	return &xxx_OpenServiceAOperation{
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *OpenServiceAResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenServiceAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Return = op.Return
}
func (o *OpenServiceAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenServiceAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenServiceAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceConfigAOperation structure represents the RQueryServiceConfigA operation
type xxx_QueryServiceConfigAOperation struct {
	Service           *Handle              `idl:"name:hService" json:"service"`
	ServiceConfig     *QueryServiceConfigA `idl:"name:lpServiceConfig" json:"service_config"`
	BufferLength      uint32               `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32               `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceConfigAOperation) OpNum() int { return 29 }

func (o *xxx_QueryServiceConfigAOperation) OpName() string { return "/svcctl/v2/RQueryServiceConfigA" }

func (o *xxx_QueryServiceConfigAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(8192) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpServiceConfig {out} (1:{alias=LPQUERY_SERVICE_CONFIGA}*(1))(2:{alias=QUERY_SERVICE_CONFIGA}(struct))
	{
		if o.ServiceConfig != nil {
			if err := o.ServiceConfig.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&QueryServiceConfigA{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpServiceConfig {out} (1:{alias=LPQUERY_SERVICE_CONFIGA,pointer=ref}*(1))(2:{alias=QUERY_SERVICE_CONFIGA}(struct))
	{
		if o.ServiceConfig == nil {
			o.ServiceConfig = &QueryServiceConfigA{}
		}
		if err := o.ServiceConfig.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K,pointer=ref}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceConfigARequest structure represents the RQueryServiceConfigA operation request
type QueryServiceConfigARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// cbBufSize: The size, in bytes, of the lpServiceConfig parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceConfigARequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigAOperation {
	if o == nil {
		return &xxx_QueryServiceConfigAOperation{}
	}
	return &xxx_QueryServiceConfigAOperation{
		Service:      o.Service,
		BufferLength: o.BufferLength,
	}
}

func (o *QueryServiceConfigARequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceConfigARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceConfigARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceConfigAResponse structure represents the RQueryServiceConfigA operation response
type QueryServiceConfigAResponse struct {
	// lpServiceConfig: A pointer to a buffer that contains the QUERY_SERVICE_CONFIGA structure.
	ServiceConfig *QueryServiceConfigA `idl:"name:lpServiceConfig" json:"service_config"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_8K (section 2.2.8) data type that defines the
	// pointer to a variable that contains the number of bytes needed to return all the
	// configuration information if the function fails.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceConfigA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceConfigAResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigAOperation {
	if o == nil {
		return &xxx_QueryServiceConfigAOperation{}
	}
	return &xxx_QueryServiceConfigAOperation{
		ServiceConfig:     o.ServiceConfig,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceConfigAResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigAOperation) {
	if o == nil {
		return
	}
	o.ServiceConfig = op.ServiceConfig
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceConfigAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceConfigAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceLockStatusAOperation structure represents the RQueryServiceLockStatusA operation
type xxx_QueryServiceLockStatusAOperation struct {
	ServiceManager    *Handle                  `idl:"name:hSCManager" json:"service_manager"`
	LockStatus        *QueryServiceLockStatusA `idl:"name:lpLockStatus" json:"lock_status"`
	BufferLength      uint32                   `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32                   `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceLockStatusAOperation) OpNum() int { return 30 }

func (o *xxx_QueryServiceLockStatusAOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceLockStatusA"
}

func (o *xxx_QueryServiceLockStatusAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(4096) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// cbBufSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpLockStatus {out} (1:{alias=LPQUERY_SERVICE_LOCK_STATUSA}*(1))(2:{alias=QUERY_SERVICE_LOCK_STATUSA}(struct))
	{
		if o.LockStatus != nil {
			if err := o.LockStatus.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&QueryServiceLockStatusA{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceLockStatusAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpLockStatus {out} (1:{alias=LPQUERY_SERVICE_LOCK_STATUSA,pointer=ref}*(1))(2:{alias=QUERY_SERVICE_LOCK_STATUSA}(struct))
	{
		if o.LockStatus == nil {
			o.LockStatus = &QueryServiceLockStatusA{}
		}
		if err := o.LockStatus.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceLockStatusARequest structure represents the RQueryServiceLockStatusA operation request
type QueryServiceLockStatusARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created previously, using one of the open methods specified in section
	// 3.1.4. The SC_MANAGER_QUERY_LOCK_STATUS access right MUST have been granted to the
	// caller when the RPC context handle was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// cbBufSize: The size, in bytes, of the lpLockStatus buffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceLockStatusARequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceLockStatusAOperation {
	if o == nil {
		return &xxx_QueryServiceLockStatusAOperation{}
	}
	return &xxx_QueryServiceLockStatusAOperation{
		ServiceManager: o.ServiceManager,
		BufferLength:   o.BufferLength,
	}
}

func (o *QueryServiceLockStatusARequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceLockStatusAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceLockStatusARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceLockStatusARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceLockStatusAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceLockStatusAResponse structure represents the RQueryServiceLockStatusA operation response
type QueryServiceLockStatusAResponse struct {
	// lpLockStatus: A pointer to a buffer that contains the QUERY_SERVICE_LOCK_STATUSA
	// (section 2.2.16) structures.
	LockStatus *QueryServiceLockStatusA `idl:"name:lpLockStatus" json:"lock_status"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the
	// pointer to a variable that receives the number of bytes needed to return all the
	// lock status.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceLockStatusA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceLockStatusAResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceLockStatusAOperation {
	if o == nil {
		return &xxx_QueryServiceLockStatusAOperation{}
	}
	return &xxx_QueryServiceLockStatusAOperation{
		LockStatus:        o.LockStatus,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceLockStatusAResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceLockStatusAOperation) {
	if o == nil {
		return
	}
	o.LockStatus = op.LockStatus
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceLockStatusAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceLockStatusAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceLockStatusAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartServiceAOperation structure represents the RStartServiceA operation
type xxx_StartServiceAOperation struct {
	Service *Handle   `idl:"name:hService" json:"service"`
	Argc    uint32    `idl:"name:argc" json:"argc"`
	Argv    []*String `idl:"name:argv;size_is:(argc);pointer:unique" json:"argv"`
	Return  uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_StartServiceAOperation) OpNum() int { return 31 }

func (o *xxx_StartServiceAOperation) OpName() string { return "/svcctl/v2/RStartServiceA" }

func (o *xxx_StartServiceAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Argv != nil && o.Argc == 0 {
		o.Argc = uint32(len(o.Argv))
	}
	if o.Argc > uint32(1024) {
		return fmt.Errorf("Argc is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// argc {in} (1:{range=(0,1024), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Argc); err != nil {
			return err
		}
	}
	// argv {in} (1:{pointer=unique, alias=LPSTRING_PTRSA}*(1))(2:{alias=STRING_PTRSA}[dim:0,size_is=argc](struct))
	{
		if o.Argv != nil || o.Argc > 0 {
			_ptr_argv := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.Argc)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Argv {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Argv[i1] != nil {
						if err := o.Argv[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&String{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Argv); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&String{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Argv, _ptr_argv); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// argc {in} (1:{range=(0,1024), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Argc); err != nil {
			return err
		}
	}
	// argv {in} (1:{pointer=unique, alias=LPSTRING_PTRSA}*(1))(2:{alias=STRING_PTRSA}[dim:0,size_is=argc](struct))
	{
		_ptr_argv := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Argv", sizeInfo[0])
			}
			o.Argv = make([]*String, sizeInfo[0])
			for i1 := range o.Argv {
				i1 := i1
				if o.Argv[i1] == nil {
					o.Argv[i1] = &String{}
				}
				if err := o.Argv[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_argv := func(ptr interface{}) { o.Argv = *ptr.(*[]*String) }
		if err := w.ReadPointer(&o.Argv, _s_argv, _ptr_argv); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServiceAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartServiceARequest structure represents the RStartServiceA operation request
type StartServiceARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) that defines the handle to the service
	// record that MUST have been created previously, using one of the open methods specified
	// in section 3.1.4. The SERVICE_START access right MUST have been granted to the caller
	// when the RPC context handle was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// argc: The number of argument strings in the argv array. If argv is NULL, this parameter
	// MAY be zero.
	Argc uint32 `idl:"name:argc" json:"argc"`
	// argv: A pointer to a buffer that contains an array of pointers to null-terminated
	// ANSI strings that are passed as arguments to the service.
	Argv []*String `idl:"name:argv;size_is:(argc);pointer:unique" json:"argv"`
}

func (o *StartServiceARequest) xxx_ToOp(ctx context.Context) *xxx_StartServiceAOperation {
	if o == nil {
		return &xxx_StartServiceAOperation{}
	}
	return &xxx_StartServiceAOperation{
		Service: o.Service,
		Argc:    o.Argc,
		Argv:    o.Argv,
	}
}

func (o *StartServiceARequest) xxx_FromOp(ctx context.Context, op *xxx_StartServiceAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Argc = op.Argc
	o.Argv = op.Argv
}
func (o *StartServiceARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *StartServiceARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServiceAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartServiceAResponse structure represents the RStartServiceA operation response
type StartServiceAResponse struct {
	// Return: The RStartServiceA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartServiceAResponse) xxx_ToOp(ctx context.Context) *xxx_StartServiceAOperation {
	if o == nil {
		return &xxx_StartServiceAOperation{}
	}
	return &xxx_StartServiceAOperation{
		Return: o.Return,
	}
}

func (o *StartServiceAResponse) xxx_FromOp(ctx context.Context, op *xxx_StartServiceAOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *StartServiceAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *StartServiceAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServiceAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServiceDisplayNameAOperation structure represents the RGetServiceDisplayNameA operation
type xxx_GetServiceDisplayNameAOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName    string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName    string  `idl:"name:lpDisplayName;size_is:(lpcchBuffer);string" json:"display_name"`
	BufferLength   uint32  `idl:"name:lpcchBuffer" json:"buffer_length"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServiceDisplayNameAOperation) OpNum() int { return 32 }

func (o *xxx_GetServiceDisplayNameAOperation) OpName() string {
	return "/svcctl/v2/RGetServiceDisplayNameA"
}

func (o *xxx_GetServiceDisplayNameAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.DisplayName != "" && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.DisplayName))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpDisplayName {out} (1:{string, alias=LPSTR}*(1)[dim:0,size_is=lpcchBuffer,string,null](char))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := ndr.CharNLen(o.DisplayName)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		_DisplayName_buf := []byte(o.DisplayName)
		if uint64(len(_DisplayName_buf)) > sizeInfo[0]-1 {
			_DisplayName_buf = _DisplayName_buf[:sizeInfo[0]-1]
		}
		if o.DisplayName != ndr.ZeroString {
			_DisplayName_buf = append(_DisplayName_buf, byte(0))
		}
		for i1 := range _DisplayName_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_DisplayName_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_DisplayName_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceDisplayNameAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpDisplayName {out} (1:{string, alias=LPSTR,pointer=ref}*(1)[dim:0,size_is=lpcchBuffer,string,null](char))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _DisplayName_buf []byte
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _DisplayName_buf", sizeInfo[0])
		}
		_DisplayName_buf = make([]byte, sizeInfo[0])
		for i1 := range _DisplayName_buf {
			i1 := i1
			if err := w.ReadData(&_DisplayName_buf[i1]); err != nil {
				return err
			}
		}
		o.DisplayName = strings.TrimRight(string(_DisplayName_buf), ndr.ZeroString)
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServiceDisplayNameARequest structure represents the RGetServiceDisplayNameA operation request
type GetServiceDisplayNameARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created previously, using one of the open methods specified in section
	// 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated ANSI string that specifies the service
	// name.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpcchBuffer: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the pointer
	// to a variable that specifies the size, in chars, of the buffer. On output, this variable
	// receives the size of the service's display name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
}

func (o *GetServiceDisplayNameARequest) xxx_ToOp(ctx context.Context) *xxx_GetServiceDisplayNameAOperation {
	if o == nil {
		return &xxx_GetServiceDisplayNameAOperation{}
	}
	return &xxx_GetServiceDisplayNameAOperation{
		ServiceManager: o.ServiceManager,
		ServiceName:    o.ServiceName,
		BufferLength:   o.BufferLength,
	}
}

func (o *GetServiceDisplayNameARequest) xxx_FromOp(ctx context.Context, op *xxx_GetServiceDisplayNameAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.BufferLength = op.BufferLength
}
func (o *GetServiceDisplayNameARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetServiceDisplayNameARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceDisplayNameAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServiceDisplayNameAResponse structure represents the RGetServiceDisplayNameA operation response
type GetServiceDisplayNameAResponse struct {
	// lpDisplayName: A pointer to a buffer that receives the null-terminated ANSI string
	// that contains the service display name.
	DisplayName string `idl:"name:lpDisplayName;size_is:(lpcchBuffer);string" json:"display_name"`
	// lpcchBuffer: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the pointer
	// to a variable that specifies the size, in chars, of the buffer. On output, this variable
	// receives the size of the service's display name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
	// Return: The RGetServiceDisplayNameA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServiceDisplayNameAResponse) xxx_ToOp(ctx context.Context) *xxx_GetServiceDisplayNameAOperation {
	if o == nil {
		return &xxx_GetServiceDisplayNameAOperation{}
	}
	return &xxx_GetServiceDisplayNameAOperation{
		DisplayName:  o.DisplayName,
		BufferLength: o.BufferLength,
		Return:       o.Return,
	}
}

func (o *GetServiceDisplayNameAResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServiceDisplayNameAOperation) {
	if o == nil {
		return
	}
	o.DisplayName = op.DisplayName
	o.BufferLength = op.BufferLength
	o.Return = op.Return
}
func (o *GetServiceDisplayNameAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetServiceDisplayNameAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceDisplayNameAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServiceKeyNameAOperation structure represents the RGetServiceKeyNameA operation
type xxx_GetServiceKeyNameAOperation struct {
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	DisplayName    string  `idl:"name:lpDisplayName;string" json:"display_name"`
	KeyName        string  `idl:"name:lpKeyName;size_is:(lpcchBuffer);string" json:"key_name"`
	BufferLength   uint32  `idl:"name:lpcchBuffer" json:"buffer_length"`
	Return         uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServiceKeyNameAOperation) OpNum() int { return 33 }

func (o *xxx_GetServiceKeyNameAOperation) OpName() string { return "/svcctl/v2/RGetServiceKeyNameA" }

func (o *xxx_GetServiceKeyNameAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpDisplayName {in} (1:{string, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.DisplayName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, range=(0,257), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.DisplayName); err != nil {
			return err
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.KeyName != "" && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.KeyName))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpKeyName {out} (1:{string, alias=LPSTR}*(1)[dim:0,size_is=lpcchBuffer,string,null](char))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		dimLength1 := ndr.CharNLen(o.KeyName)
		if dimLength1 > sizeInfo[0] {
			dimLength1 = sizeInfo[0]
		} else {
			sizeInfo[0] = dimLength1
		}
		if err := w.WriteSize(0); err != nil {
			return err
		}
		if err := w.WriteSize(dimLength1); err != nil {
			return err
		}
		_KeyName_buf := []byte(o.KeyName)
		if uint64(len(_KeyName_buf)) > sizeInfo[0]-1 {
			_KeyName_buf = _KeyName_buf[:sizeInfo[0]-1]
		}
		if o.KeyName != ndr.ZeroString {
			_KeyName_buf = append(_KeyName_buf, byte(0))
		}
		for i1 := range _KeyName_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_KeyName_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_KeyName_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServiceKeyNameAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpKeyName {out} (1:{string, alias=LPSTR,pointer=ref}*(1)[dim:0,size_is=lpcchBuffer,string,null](char))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _KeyName_buf []byte
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _KeyName_buf", sizeInfo[0])
		}
		_KeyName_buf = make([]byte, sizeInfo[0])
		for i1 := range _KeyName_buf {
			i1 := i1
			if err := w.ReadData(&_KeyName_buf[i1]); err != nil {
				return err
			}
		}
		o.KeyName = strings.TrimRight(string(_KeyName_buf), ndr.ZeroString)
	}
	// lpcchBuffer {in, out} (1:{alias=LPBOUNDED_DWORD_4K,pointer=ref}*(1))(2:{range=(0,4096), alias=BOUNDED_DWORD_4K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServiceKeyNameARequest structure represents the RGetServiceKeyNameA operation request
type GetServiceKeyNameARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created previously, using one of the open methods specified in section
	// 3.1.4.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpDisplayName: A pointer to a null-terminated ANSI string that specifies the service
	// display name.
	DisplayName string `idl:"name:lpDisplayName;string" json:"display_name"`
	// lpcchBuffer: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the pointer
	// to a variable that specifies the size, in chars, of the buffer. On output, this variable
	// receives the size of the service name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
}

func (o *GetServiceKeyNameARequest) xxx_ToOp(ctx context.Context) *xxx_GetServiceKeyNameAOperation {
	if o == nil {
		return &xxx_GetServiceKeyNameAOperation{}
	}
	return &xxx_GetServiceKeyNameAOperation{
		ServiceManager: o.ServiceManager,
		DisplayName:    o.DisplayName,
		BufferLength:   o.BufferLength,
	}
}

func (o *GetServiceKeyNameARequest) xxx_FromOp(ctx context.Context, op *xxx_GetServiceKeyNameAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.DisplayName = op.DisplayName
	o.BufferLength = op.BufferLength
}
func (o *GetServiceKeyNameARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetServiceKeyNameARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceKeyNameAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServiceKeyNameAResponse structure represents the RGetServiceKeyNameA operation response
type GetServiceKeyNameAResponse struct {
	// lpKeyName: A pointer to a buffer that receives the null-terminated ANSI string that
	// contains the service name.
	KeyName string `idl:"name:lpKeyName;size_is:(lpcchBuffer);string" json:"key_name"`
	// lpcchBuffer: An LPBOUNDED_DWORD_4K (section 2.2.7) data type that defines the pointer
	// to a variable that specifies the size, in chars, of the buffer. On output, this variable
	// receives the size of the service name, excluding the terminating null character.
	BufferLength uint32 `idl:"name:lpcchBuffer" json:"buffer_length"`
	// Return: The RGetServiceKeyNameA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServiceKeyNameAResponse) xxx_ToOp(ctx context.Context) *xxx_GetServiceKeyNameAOperation {
	if o == nil {
		return &xxx_GetServiceKeyNameAOperation{}
	}
	return &xxx_GetServiceKeyNameAOperation{
		KeyName:      o.KeyName,
		BufferLength: o.BufferLength,
		Return:       o.Return,
	}
}

func (o *GetServiceKeyNameAResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServiceKeyNameAOperation) {
	if o == nil {
		return
	}
	o.KeyName = op.KeyName
	o.BufferLength = op.BufferLength
	o.Return = op.Return
}
func (o *GetServiceKeyNameAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetServiceKeyNameAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServiceKeyNameAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumServiceGroupWOperation structure represents the REnumServiceGroupW operation
type xxx_EnumServiceGroupWOperation struct {
	ServiceManager    *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceType       uint32  `idl:"name:dwServiceType" json:"service_type"`
	ServiceState      uint32  `idl:"name:dwServiceState" json:"service_state"`
	Buffer            []byte  `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32  `idl:"name:lpServicesReturned" json:"services_returned"`
	ResumeIndex       uint32  `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	GroupName         string  `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumServiceGroupWOperation) OpNum() int { return 35 }

func (o *xxx_EnumServiceGroupWOperation) OpName() string { return "/svcctl/v2/REnumServiceGroupW" }

func (o *xxx_EnumServiceGroupWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if len(o.GroupName) > int(257) {
		return fmt.Errorf("GroupName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServiceGroupWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GroupName != "" {
			_ptr_pszGroupName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupName, _ptr_pszGroupName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServiceGroupWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pszGroupName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
				return err
			}
			return nil
		})
		_s_pszGroupName := func(ptr interface{}) { o.GroupName = *ptr.(*string) }
		if err := w.ReadPointer(&o.GroupName, _s_pszGroupName, _ptr_pszGroupName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServiceGroupWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServiceGroupWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServiceGroupWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumServiceGroupWRequest structure represents the REnumServiceGroupW operation request
type EnumServiceGroupWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM created using one of the open methods specified in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE
	// access right MUST have been granted to the caller when the RPC context handle was
	// created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// dwServiceType: A value that specifies the service records to enumerate based on their
	// Type. This MUST be one or a combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs in its own process.                                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// their ServiceStatus.dwCurrentState. This MUST be one of the following values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records with the ServiceStatus.dwCurrentState value           |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the array pointed to by lpBuffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// pszGroupName: A pointer to a string that specifies service records to enumerate based
	// on their ServiceGroup value.
	GroupName string `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
}

func (o *EnumServiceGroupWRequest) xxx_ToOp(ctx context.Context) *xxx_EnumServiceGroupWOperation {
	if o == nil {
		return &xxx_EnumServiceGroupWOperation{}
	}
	return &xxx_EnumServiceGroupWOperation{
		ServiceManager: o.ServiceManager,
		ServiceType:    o.ServiceType,
		ServiceState:   o.ServiceState,
		BufferLength:   o.BufferLength,
		ResumeIndex:    o.ResumeIndex,
		GroupName:      o.GroupName,
	}
}

func (o *EnumServiceGroupWRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumServiceGroupWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceType = op.ServiceType
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
	o.ResumeIndex = op.ResumeIndex
	o.GroupName = op.GroupName
}
func (o *EnumServiceGroupWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumServiceGroupWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServiceGroupWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumServiceGroupWResponse structure represents the REnumServiceGroupW operation response
type EnumServiceGroupWResponse struct {
	// lpBuffer: A pointer to an array of ENUM_SERVICE_STATUSW (section 2.2.11) structures
	// that contain the name and service status information for each dependent service in
	// the database.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to store the array of service entries.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// specifies the current position in the status enumeration. The server MUST assign
	// a unique number to each service for the boot session, in increasing order, and increment
	// that number by one for each service addition. The value of the lpResumeIndex parameter
	// is one of these numbers, which the server can use to determine the resumption point
	// for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// Return: The REnumServiceGroupW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumServiceGroupWResponse) xxx_ToOp(ctx context.Context) *xxx_EnumServiceGroupWOperation {
	if o == nil {
		return &xxx_EnumServiceGroupWOperation{}
	}
	return &xxx_EnumServiceGroupWOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		ResumeIndex:       o.ResumeIndex,
		Return:            o.Return,
	}
}

func (o *EnumServiceGroupWResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumServiceGroupWOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.ResumeIndex = op.ResumeIndex
	o.Return = op.Return
}
func (o *EnumServiceGroupWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumServiceGroupWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServiceGroupWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeServiceConfig2AOperation structure represents the RChangeServiceConfig2A operation
type xxx_ChangeServiceConfig2AOperation struct {
	Service *Handle      `idl:"name:hService" json:"service"`
	Info    *ConfigInfoA `idl:"name:Info" json:"info"`
	Return  uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeServiceConfig2AOperation) OpNum() int { return 36 }

func (o *xxx_ChangeServiceConfig2AOperation) OpName() string {
	return "/svcctl/v2/RChangeServiceConfig2A"
}

func (o *xxx_ChangeServiceConfig2AOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2AOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Info {in} (1:{alias=SC_RPC_CONFIG_INFOA}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoA{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2AOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Info {in} (1:{alias=SC_RPC_CONFIG_INFOA}(struct))
	{
		if o.Info == nil {
			o.Info = &ConfigInfoA{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2AOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2AOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2AOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeServiceConfig2ARequest structure represents the RChangeServiceConfig2A operation request
type ChangeServiceConfig2ARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_CHANGE_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// Info: An SC_RPC_CONFIG_INFOA (section 2.2.21) structure that contains optional configuration
	// information.
	Info *ConfigInfoA `idl:"name:Info" json:"info"`
}

func (o *ChangeServiceConfig2ARequest) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfig2AOperation {
	if o == nil {
		return &xxx_ChangeServiceConfig2AOperation{}
	}
	return &xxx_ChangeServiceConfig2AOperation{
		Service: o.Service,
		Info:    o.Info,
	}
}

func (o *ChangeServiceConfig2ARequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfig2AOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Info = op.Info
}
func (o *ChangeServiceConfig2ARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeServiceConfig2ARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfig2AOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeServiceConfig2AResponse structure represents the RChangeServiceConfig2A operation response
type ChangeServiceConfig2AResponse struct {
	// Return: The RChangeServiceConfig2A return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeServiceConfig2AResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfig2AOperation {
	if o == nil {
		return &xxx_ChangeServiceConfig2AOperation{}
	}
	return &xxx_ChangeServiceConfig2AOperation{
		Return: o.Return,
	}
}

func (o *ChangeServiceConfig2AResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfig2AOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ChangeServiceConfig2AResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeServiceConfig2AResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfig2AOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChangeServiceConfig2WOperation structure represents the RChangeServiceConfig2W operation
type xxx_ChangeServiceConfig2WOperation struct {
	Service *Handle      `idl:"name:hService" json:"service"`
	Info    *ConfigInfoW `idl:"name:Info" json:"info"`
	Return  uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ChangeServiceConfig2WOperation) OpNum() int { return 37 }

func (o *xxx_ChangeServiceConfig2WOperation) OpName() string {
	return "/svcctl/v2/RChangeServiceConfig2W"
}

func (o *xxx_ChangeServiceConfig2WOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2WOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Info {in} (1:{alias=SC_RPC_CONFIG_INFOW}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2WOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Info {in} (1:{alias=SC_RPC_CONFIG_INFOW}(struct))
	{
		if o.Info == nil {
			o.Info = &ConfigInfoW{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2WOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2WOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChangeServiceConfig2WOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChangeServiceConfig2WRequest structure represents the RChangeServiceConfig2W operation request
type ChangeServiceConfig2WRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_CHANGE_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// Info: An SC_RPC_CONFIG_INFOW (section 2.2.22) structure that contains optional configuration
	// information.
	Info *ConfigInfoW `idl:"name:Info" json:"info"`
}

func (o *ChangeServiceConfig2WRequest) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfig2WOperation {
	if o == nil {
		return &xxx_ChangeServiceConfig2WOperation{}
	}
	return &xxx_ChangeServiceConfig2WOperation{
		Service: o.Service,
		Info:    o.Info,
	}
}

func (o *ChangeServiceConfig2WRequest) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfig2WOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Info = op.Info
}
func (o *ChangeServiceConfig2WRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ChangeServiceConfig2WRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfig2WOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChangeServiceConfig2WResponse structure represents the RChangeServiceConfig2W operation response
type ChangeServiceConfig2WResponse struct {
	// Return: The RChangeServiceConfig2W return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ChangeServiceConfig2WResponse) xxx_ToOp(ctx context.Context) *xxx_ChangeServiceConfig2WOperation {
	if o == nil {
		return &xxx_ChangeServiceConfig2WOperation{}
	}
	return &xxx_ChangeServiceConfig2WOperation{
		Return: o.Return,
	}
}

func (o *ChangeServiceConfig2WResponse) xxx_FromOp(ctx context.Context, op *xxx_ChangeServiceConfig2WOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ChangeServiceConfig2WResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ChangeServiceConfig2WResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChangeServiceConfig2WOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceConfig2AOperation structure represents the RQueryServiceConfig2A operation
type xxx_QueryServiceConfig2AOperation struct {
	Service           *Handle `idl:"name:hService" json:"service"`
	InfoLevel         uint32  `idl:"name:dwInfoLevel" json:"info_level"`
	Buffer            []byte  `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceConfig2AOperation) OpNum() int { return 38 }

func (o *xxx_QueryServiceConfig2AOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceConfig2A"
}

func (o *xxx_QueryServiceConfig2AOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(8192) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2AOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InfoLevel); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2AOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InfoLevel); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2AOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2AOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2AOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K,pointer=ref}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceConfig2ARequest structure represents the RQueryServiceConfig2A operation request
type QueryServiceConfig2ARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwInfoLevel: A value that specifies the configuration information to query. This
	// SHOULD be one of the following values.
	//
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                        |                                                                                  |
	//	|                         VALUE                          |                                     MEANING                                      |
	//	|                                                        |                                                                                  |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_DESCRIPTION 0x00000001                  | The lpBuffer parameter is a pointer to a SERVICE_DESCRIPTIONA structure.         |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_FAILURE_ACTIONS 0x00000002              | The lpBuffer parameter is a pointer to a SERVICE_FAILURE_ACTIONSA structure.     |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_DELAYED_AUTO_START_INFO 0x00000003<56>  | The lpBuffer parameter is a pointer to a SERVICE_DELAYED_AUTO_START_INFO         |
	//	|                                                        | structure.                                                                       |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_FAILURE_ACTIONS_FLAG 0x00000004<57>     | The lpBuffer parameter is a pointer to a SERVICE_FAILURE_ACTIONS_FLAG structure. |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_SERVICE_SID_INFO 0x00000005<58>         | The lpBuffer parameter is a pointer to a SERVICE_SID_INFO structure.             |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO 0x00000006<59> | The lpBuffer parameter is a pointer to a SERVICE_RPC_REQUIRED_PRIVILEGES_INFO    |
	//	|                                                        | structure.                                                                       |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_PRESHUTDOWN_INFO 0x00000007<60>         | The lpBuffer parameter is a pointer to a SERVICE_PRESHUTDOWN_INFO structure.     |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_PREFERRED_NODE 0x00000009<61>           | The lpBuffer parameter is a pointer to a SERVICE_PREFERRED_NODE_INFO             |
	//	|                                                        | structure.<62>                                                                   |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	InfoLevel uint32 `idl:"name:dwInfoLevel" json:"info_level"`
	// cbBufSize: The size, in bytes, of the lpBuffer parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceConfig2ARequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfig2AOperation {
	if o == nil {
		return &xxx_QueryServiceConfig2AOperation{}
	}
	return &xxx_QueryServiceConfig2AOperation{
		Service:      o.Service,
		InfoLevel:    o.InfoLevel,
		BufferLength: o.BufferLength,
	}
}

func (o *QueryServiceConfig2ARequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfig2AOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.InfoLevel = op.InfoLevel
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceConfig2ARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceConfig2ARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfig2AOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceConfig2AResponse structure represents the RQueryServiceConfig2A operation response
type QueryServiceConfig2AResponse struct {
	// lpBuffer: A pointer to the buffer that contains the service configuration information.
	// The format of this data depends on the value of the dwInfoLevel parameter.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_8K (section 2.2.8) data type that defines the
	// pointer to a variable that contains the number of bytes needed to return the configuration
	// information.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceConfig2A return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceConfig2AResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfig2AOperation {
	if o == nil {
		return &xxx_QueryServiceConfig2AOperation{}
	}
	return &xxx_QueryServiceConfig2AOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceConfig2AResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfig2AOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceConfig2AResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceConfig2AResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfig2AOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceConfig2WOperation structure represents the RQueryServiceConfig2W operation
type xxx_QueryServiceConfig2WOperation struct {
	Service           *Handle `idl:"name:hService" json:"service"`
	InfoLevel         uint32  `idl:"name:dwInfoLevel" json:"info_level"`
	Buffer            []byte  `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32  `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32  `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceConfig2WOperation) OpNum() int { return 39 }

func (o *xxx_QueryServiceConfig2WOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceConfig2W"
}

func (o *xxx_QueryServiceConfig2WOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(8192) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2WOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InfoLevel); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2WOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InfoLevel); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2WOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2WOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfig2WOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K,pointer=ref}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceConfig2WRequest structure represents the RQueryServiceConfig2W operation request
type QueryServiceConfig2WRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	//
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                        |                                                                                  |
	//	|                         VALUE                          |                                     MEANING                                      |
	//	|                                                        |                                                                                  |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_DESCRIPTION 0x00000001                  | The lpBuffer parameter is a pointer to a SERVICE_DESCRIPTION_WOW64 (section      |
	//	|                                                        | 2.2.36) structure.                                                               |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_FAILURE_ACTIONS 0x00000002              | The lpBuffer parameter is a pointer to a SERVICE_FAILURE_ACTIONS_WOW64 (section  |
	//	|                                                        | 2.2.37) structure.                                                               |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_DELAYED_AUTO_START_INFO 0x00000003<65>  | The lpBuffer parameter is a pointer to a SERVICE_DELAYED_AUTO_START_INFO         |
	//	|                                                        | structure.                                                                       |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_FAILURE_ACTIONS_FLAG 0x00000004<66>     | The lpBuffer parameter is a pointer to a SERVICE_FAILURE_ACTIONS_FLAG structure. |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_SERVICE_SID_INFO 0x00000005<67>         | The lpBuffer parameter is a pointer to a SERVICE_SID_INFO structure.             |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO 0x00000006<68> | The lpBuffer parameter is a pointer to a SERVICE_REQUIRED_PRIVILEGES_INFO_WOW64  |
	//	|                                                        | (section 2.2.38) structure.                                                      |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_PRESHUTDOWN_INFO 0x00000007<69>         | The lpBuffer parameter is a pointer to a SERVICE_PRESHUTDOWN_INFO structure.     |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONFIG_PREFERRED_NODE 0x00000009<70>           | The lpBuffer parameter is a pointer to a SERVICE_PREFERRED_NODE_INFO             |
	//	|                                                        | structure.<71>                                                                   |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	Service *Handle `idl:"name:hService" json:"service"`
	// dwInfoLevel: A value that specifies the configuration information to query. This
	// MUST be one of the following values.
	InfoLevel uint32 `idl:"name:dwInfoLevel" json:"info_level"`
	// cbBufSize: The size, in bytes, of the lpBuffer parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceConfig2WRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfig2WOperation {
	if o == nil {
		return &xxx_QueryServiceConfig2WOperation{}
	}
	return &xxx_QueryServiceConfig2WOperation{
		Service:      o.Service,
		InfoLevel:    o.InfoLevel,
		BufferLength: o.BufferLength,
	}
}

func (o *QueryServiceConfig2WRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfig2WOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.InfoLevel = op.InfoLevel
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceConfig2WRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceConfig2WRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfig2WOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceConfig2WResponse structure represents the RQueryServiceConfig2W operation response
type QueryServiceConfig2WResponse struct {
	// lpBuffer: A pointer to the buffer that contains the service configuration information.
	// The format of this data depends on the value of the dwInfoLevel parameter.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_8K (section 2.2.8) data type that defines the
	// pointer to a variable that receives the number of bytes needed to return the configuration
	// information.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceConfig2W return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceConfig2WResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfig2WOperation {
	if o == nil {
		return &xxx_QueryServiceConfig2WOperation{}
	}
	return &xxx_QueryServiceConfig2WOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceConfig2WResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfig2WOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceConfig2WResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceConfig2WResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfig2WOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceStatusExOperation structure represents the RQueryServiceStatusEx operation
type xxx_QueryServiceStatusExOperation struct {
	Service           *Handle    `idl:"name:hService" json:"service"`
	InfoLevel         StatusType `idl:"name:InfoLevel" json:"info_level"`
	Buffer            []byte     `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32     `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32     `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	Return            uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceStatusExOperation) OpNum() int { return 40 }

func (o *xxx_QueryServiceStatusExOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceStatusEx"
}

func (o *xxx_QueryServiceStatusExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(8192) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_STATUS_TYPE}(enum))
	{
		if err := w.WriteData(uint32(o.InfoLevel)); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_STATUS_TYPE}(enum))
	{
		if err := w.ReadData((*uint32)(&o.InfoLevel)); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,8192), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceStatusExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_8K,pointer=ref}*(1))(2:{range=(0,8192), alias=BOUNDED_DWORD_8K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceStatusExRequest structure represents the RQueryServiceStatusEx operation request
type QueryServiceStatusExRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_STATUS access right MUST have been
	// granted to the caller when the RPC context handle to the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// InfoLevel: An enumerated value from SC_STATUS_TYPE (section 2.2.29) that specifies
	// which service attributes are returned. MUST be SC_STATUS_PROCESS_INFO.
	InfoLevel StatusType `idl:"name:InfoLevel" json:"info_level"`
	// cbBufSize: The size, in bytes, of the lpBuffer parameter.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
}

func (o *QueryServiceStatusExRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceStatusExOperation {
	if o == nil {
		return &xxx_QueryServiceStatusExOperation{}
	}
	return &xxx_QueryServiceStatusExOperation{
		Service:      o.Service,
		InfoLevel:    o.InfoLevel,
		BufferLength: o.BufferLength,
	}
}

func (o *QueryServiceStatusExRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceStatusExOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.InfoLevel = op.InfoLevel
	o.BufferLength = op.BufferLength
}
func (o *QueryServiceStatusExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceStatusExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceStatusExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceStatusExResponse structure represents the RQueryServiceStatusEx operation response
type QueryServiceStatusExResponse struct {
	// lpBuffer: A pointer to the buffer that contains the status information in the form
	// of a SERVICE_STATUS_PROCESS (section 2.2.49) structure.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_8K (section 2.2.8) data type that defines the
	// pointer to a variable that contains the number of bytes needed to return the configuration
	// information.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// Return: The RQueryServiceStatusEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceStatusExResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceStatusExOperation {
	if o == nil {
		return &xxx_QueryServiceStatusExOperation{}
	}
	return &xxx_QueryServiceStatusExOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		Return:            o.Return,
	}
}

func (o *QueryServiceStatusExResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceStatusExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.Return = op.Return
}
func (o *QueryServiceStatusExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceStatusExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceStatusExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumServicesStatusExAOperation structure represents the REnumServicesStatusExA operation
type xxx_EnumServicesStatusExAOperation struct {
	ServiceManager    *Handle  `idl:"name:hSCManager" json:"service_manager"`
	InfoLevel         EnumType `idl:"name:InfoLevel" json:"info_level"`
	ServiceType       uint32   `idl:"name:dwServiceType" json:"service_type"`
	ServiceState      uint32   `idl:"name:dwServiceState" json:"service_state"`
	Buffer            []byte   `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32   `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32   `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32   `idl:"name:lpServicesReturned" json:"services_returned"`
	ResumeIndex       uint32   `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	GroupName         string   `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
	Return            uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumServicesStatusExAOperation) OpNum() int { return 41 }

func (o *xxx_EnumServicesStatusExAOperation) OpName() string {
	return "/svcctl/v2/REnumServicesStatusExA"
}

func (o *xxx_EnumServicesStatusExAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if len(o.GroupName) > int(257) {
		return fmt.Errorf("GroupName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_ENUM_TYPE}(enum))
	{
		if err := w.WriteData(uint32(o.InfoLevel)); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCSTR}*(1)[dim:0,string,null](char))
	{
		if o.GroupName != "" {
			_ptr_pszGroupName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.GroupName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupName, _ptr_pszGroupName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_ENUM_TYPE}(enum))
	{
		if err := w.ReadData((*uint32)(&o.InfoLevel)); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_pszGroupName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.GroupName); err != nil {
				return err
			}
			return nil
		})
		_s_pszGroupName := func(ptr interface{}) { o.GroupName = *ptr.(*string) }
		if err := w.ReadPointer(&o.GroupName, _s_pszGroupName, _ptr_pszGroupName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumServicesStatusExARequest structure represents the REnumServicesStatusExA operation request
type EnumServicesStatusExARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE access right MUST have
	// been granted to the caller when the RPC context handle to the SCM was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// InfoLevel: An SC_ENUM_TYPE (section 2.2.20) structure that specifies which service
	// attributes to return. MUST be SC_ENUM_PROCESS_INFO.
	InfoLevel EnumType `idl:"name:InfoLevel" json:"info_level"`
	// dwServiceType: A value that specifies what type of service records to enumerate.
	// This MUST be one or a combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------+
	//	|                                        |                                                          |
	//	|                 VALUE                  |                         MEANING                          |
	//	|                                        |                                                          |
	//	+----------------------------------------+----------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x0000000F       | Enumerates services of type SERVICE_KERNEL_DRIVER.       |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | Enumerates services of type SERVICE_FILE_SYSTEM_DRIVER.  |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Enumerates services of type SERVICE_WIN32_OWN_PROCESS.   |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Enumerates services of type SERVICE_WIN32_SHARE_PROCESS. |
	//	+----------------------------------------+----------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwServiceState: Value that specifies the service records to enumerate based on their
	// ServiceStatus.dwCurrentState. This MUST be one of the following values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records with the ServiceStatus.dwCurrentState value           |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the buffer pointed to by lpBuffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the current index in the enumerated list of service entries. The server
	// MUST assign a unique number to each service for the boot session, in increasing order,
	// and increment that number by one for each service addition. The value of the lpResumeIndex
	// parameter is one of these numbers, which the server can use to determine the resumption
	// point for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// pszGroupName: A pointer to a string that specifies service records to enumerate based
	// on their ServiceGroup values.
	GroupName string `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
}

func (o *EnumServicesStatusExARequest) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusExAOperation {
	if o == nil {
		return &xxx_EnumServicesStatusExAOperation{}
	}
	return &xxx_EnumServicesStatusExAOperation{
		ServiceManager: o.ServiceManager,
		InfoLevel:      o.InfoLevel,
		ServiceType:    o.ServiceType,
		ServiceState:   o.ServiceState,
		BufferLength:   o.BufferLength,
		ResumeIndex:    o.ResumeIndex,
		GroupName:      o.GroupName,
	}
}

func (o *EnumServicesStatusExARequest) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusExAOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.InfoLevel = op.InfoLevel
	o.ServiceType = op.ServiceType
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
	o.ResumeIndex = op.ResumeIndex
	o.GroupName = op.GroupName
}
func (o *EnumServicesStatusExARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumServicesStatusExARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusExAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumServicesStatusExAResponse structure represents the REnumServicesStatusExA operation response
type EnumServicesStatusExAResponse struct {
	// lpBuffer: A pointer to the buffer that contains the status information in the form
	// of an array of ENUM_SERVICE_STATUS_PROCESSA (section 2.2.12) structures.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to return the configuration information.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the current index in the enumerated list of service entries. The server
	// MUST assign a unique number to each service for the boot session, in increasing order,
	// and increment that number by one for each service addition. The value of the lpResumeIndex
	// parameter is one of these numbers, which the server can use to determine the resumption
	// point for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// Return: The REnumServicesStatusExA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumServicesStatusExAResponse) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusExAOperation {
	if o == nil {
		return &xxx_EnumServicesStatusExAOperation{}
	}
	return &xxx_EnumServicesStatusExAOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		ResumeIndex:       o.ResumeIndex,
		Return:            o.Return,
	}
}

func (o *EnumServicesStatusExAResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusExAOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.ResumeIndex = op.ResumeIndex
	o.Return = op.Return
}
func (o *EnumServicesStatusExAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumServicesStatusExAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusExAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumServicesStatusExWOperation structure represents the REnumServicesStatusExW operation
type xxx_EnumServicesStatusExWOperation struct {
	ServiceManager    *Handle  `idl:"name:hSCManager" json:"service_manager"`
	InfoLevel         EnumType `idl:"name:InfoLevel" json:"info_level"`
	ServiceType       uint32   `idl:"name:dwServiceType" json:"service_type"`
	ServiceState      uint32   `idl:"name:dwServiceState" json:"service_state"`
	Buffer            []byte   `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	BufferLength      uint32   `idl:"name:cbBufSize" json:"buffer_length"`
	BytesNeededLength uint32   `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	ServicesReturned  uint32   `idl:"name:lpServicesReturned" json:"services_returned"`
	ResumeIndex       uint32   `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	GroupName         string   `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
	Return            uint32   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumServicesStatusExWOperation) OpNum() int { return 42 }

func (o *xxx_EnumServicesStatusExWOperation) OpName() string {
	return "/svcctl/v2/REnumServicesStatusExW"
}

func (o *xxx_EnumServicesStatusExWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.BufferLength > uint32(262144) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if len(o.GroupName) > int(257) {
		return fmt.Errorf("GroupName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_ENUM_TYPE}(enum))
	{
		if err := w.WriteData(uint32(o.InfoLevel)); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GroupName != "" {
			_ptr_pszGroupName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupName, _ptr_pszGroupName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// InfoLevel {in} (1:{v1_enum, alias=SC_ENUM_TYPE}(enum))
	{
		if err := w.ReadData((*uint32)(&o.InfoLevel)); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwServiceState {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceState); err != nil {
			return err
		}
	}
	// cbBufSize {in} (1:{range=(0,262144), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferLength); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pszGroupName {in} (1:{string, pointer=unique, range=(0,257), alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pszGroupName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
				return err
			}
			return nil
		})
		_s_pszGroupName := func(ptr interface{}) { o.GroupName = *ptr.(*string) }
		if err := w.ReadPointer(&o.GroupName, _s_pszGroupName, _ptr_pszGroupName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		dimSize1 := uint64(o.BufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumServicesStatusExWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{alias=LPBYTE,pointer=ref}*(1))(2:{alias=BYTE}[dim:0,size_is=cbBufSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// pcbBytesNeeded {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BytesNeededLength); err != nil {
			return err
		}
	}
	// lpServicesReturned {out} (1:{alias=LPBOUNDED_DWORD_256K,pointer=ref}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServicesReturned); err != nil {
			return err
		}
	}
	// lpResumeIndex {in, out} (1:{pointer=unique, alias=LPBOUNDED_DWORD_256K}*(1))(2:{range=(0,262144), alias=BOUNDED_DWORD_256K, names=DWORD}(uint32))
	{
		_ptr_lpResumeIndex := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ResumeIndex); err != nil {
				return err
			}
			return nil
		})
		_s_lpResumeIndex := func(ptr interface{}) { o.ResumeIndex = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ResumeIndex, _s_lpResumeIndex, _ptr_lpResumeIndex); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumServicesStatusExWRequest structure represents the REnumServicesStatusExW operation request
type EnumServicesStatusExWRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE access right MUST have
	// been granted to the caller when the RPC context handle to the SCM was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// InfoLevel: An SC_ENUM_TYPE (section 2.2.20) structure that specifies which service
	// attributes are returned. This MUST be SC_ENUM_PROCESS_INFO.
	InfoLevel EnumType `idl:"name:InfoLevel" json:"info_level"`
	// dwServiceType: A value that specifies the service records to enumerate based on their
	// Type. This MUST be one or a combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------+
	//	|                                        |                                                          |
	//	|                 VALUE                  |                         MEANING                          |
	//	|                                        |                                                          |
	//	+----------------------------------------+----------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | Enumerates services of type SERVICE_KERNEL_DRIVER.       |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | Enumerates services of type SERVICE_FILE_SYSTEM_DRIVER.  |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Enumerates services of type SERVICE_WIN32_OWN_PROCESS.   |
	//	+----------------------------------------+----------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Enumerates services of type SERVICE_WIN32_SHARE_PROCESS. |
	//	+----------------------------------------+----------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwServiceState: A value that specifies the service records to enumerate based on
	// their ServiceStatus.dwCurrentState. This MUST be one of the following values.
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ACTIVE 0x00000001    | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INACTIVE 0x00000002  | Enumerates service records with the ServiceStatus.dwCurrentState value           |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_STATE_ALL 0x00000003 | Enumerates service records with ServiceStatus.dwCurrentState values from         |
	//	|                              | the following: SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING,     |
	//	|                              | SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and             |
	//	|                              | SERVICE_STOPPED.                                                                 |
	//	+------------------------------+----------------------------------------------------------------------------------+
	ServiceState uint32 `idl:"name:dwServiceState" json:"service_state"`
	// cbBufSize: The size, in bytes, of the buffer pointed to by lpBuffer.
	BufferLength uint32 `idl:"name:cbBufSize" json:"buffer_length"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the current index in the enumerated list of service entries. The server
	// MUST assign a unique number to each service for the boot session, in increasing order,
	// and increment that number by one for each service addition. The value of the lpResumeIndex
	// parameter is one of these numbers, which the server can use to determine the resumption
	// point for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// pszGroupName: A pointer to a string that specifies service records to enumerate based
	// on their ServiceGroup values.
	GroupName string `idl:"name:pszGroupName;string;pointer:unique" json:"group_name"`
}

func (o *EnumServicesStatusExWRequest) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusExWOperation {
	if o == nil {
		return &xxx_EnumServicesStatusExWOperation{}
	}
	return &xxx_EnumServicesStatusExWOperation{
		ServiceManager: o.ServiceManager,
		InfoLevel:      o.InfoLevel,
		ServiceType:    o.ServiceType,
		ServiceState:   o.ServiceState,
		BufferLength:   o.BufferLength,
		ResumeIndex:    o.ResumeIndex,
		GroupName:      o.GroupName,
	}
}

func (o *EnumServicesStatusExWRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusExWOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.InfoLevel = op.InfoLevel
	o.ServiceType = op.ServiceType
	o.ServiceState = op.ServiceState
	o.BufferLength = op.BufferLength
	o.ResumeIndex = op.ResumeIndex
	o.GroupName = op.GroupName
}
func (o *EnumServicesStatusExWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *EnumServicesStatusExWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusExWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumServicesStatusExWResponse structure represents the REnumServicesStatusExW operation response
type EnumServicesStatusExWResponse struct {
	// lpBuffer: A pointer to the buffer that contains the status information in the form
	// of an array of ENUM_SERVICE_STATUS_PROCESSW (section 2.2.13) structures.
	Buffer []byte `idl:"name:lpBuffer;size_is:(cbBufSize)" json:"buffer"`
	// pcbBytesNeeded: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the number of bytes needed to return the configuration information if the
	// method fails.
	BytesNeededLength uint32 `idl:"name:pcbBytesNeeded" json:"bytes_needed_length"`
	// lpServicesReturned: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable
	// that contains the number of service entries returned.
	ServicesReturned uint32 `idl:"name:lpServicesReturned" json:"services_returned"`
	// lpResumeIndex: An LPBOUNDED_DWORD_256K (section 2.2.9) pointer to a variable that
	// contains the current index in the enumerated list of service entries. The server
	// MUST assign a unique number to each service for the boot session, in increasing order,
	// and increment that number by one for each service addition. The value of the lpResumeIndex
	// parameter is one of these numbers, which the server can use to determine the resumption
	// point for the enumeration.
	ResumeIndex uint32 `idl:"name:lpResumeIndex;pointer:unique" json:"resume_index"`
	// Return: The REnumServicesStatusExW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumServicesStatusExWResponse) xxx_ToOp(ctx context.Context) *xxx_EnumServicesStatusExWOperation {
	if o == nil {
		return &xxx_EnumServicesStatusExWOperation{}
	}
	return &xxx_EnumServicesStatusExWOperation{
		Buffer:            o.Buffer,
		BytesNeededLength: o.BytesNeededLength,
		ServicesReturned:  o.ServicesReturned,
		ResumeIndex:       o.ResumeIndex,
		Return:            o.Return,
	}
}

func (o *EnumServicesStatusExWResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumServicesStatusExWOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BytesNeededLength = op.BytesNeededLength
	o.ServicesReturned = op.ServicesReturned
	o.ResumeIndex = op.ResumeIndex
	o.Return = op.Return
}
func (o *EnumServicesStatusExWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *EnumServicesStatusExWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumServicesStatusExWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateServiceWOW64AOperation structure represents the RCreateServiceWOW64A operation
type xxx_CreateServiceWOW64AOperation struct {
	ServiceManager   *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName      string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	DesiredAccess    uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	Service          *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateServiceWOW64AOperation) OpNum() int { return 44 }

func (o *xxx_CreateServiceWOW64AOperation) OpName() string { return "/svcctl/v2/RCreateServiceWOW64A" }

func (o *xxx_CreateServiceWOW64AOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64AOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, range=(0,32768), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if err := ndr.WriteCharNString(ctx, w, o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteCharNString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64AOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, range=(0,257), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, range=(0,32768), alias=LPSTR,pointer=ref}*(1)[dim:0,string,null](char))
	{
		if err := ndr.ReadCharNString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048), alias=LPSTR}*(1)[dim:0,string,null](char))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadCharNString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64AOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64AOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64AOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateServiceWOW64ARequest structure represents the RCreateServiceWOW64A operation request
type CreateServiceWOW64ARequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SC_MANAGER_CREATE_SERVICE access right MUST have
	// been granted to the caller when the RPC context handle to the SCM was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated ANSI string that specifies the name
	// of the service to install. This MUST not be null.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpDisplayName: A pointer to a null-terminated ANSI string that contains the display
	// name by which user interface programs identify the service.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	// dwDesiredAccess: A value that specifies the access to the service. This MUST be one
	// of the values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	// dwServiceType: A value that specifies the type of service. This MUST be one or a
	// combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs within its own process.                                        |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares an execution process with other services.                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A value that specifies when to start the service. This MUST be one of
	// the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: A value that specifies the severity of the error if the service fails
	// to start and determines the action that the SCM takes. This MUST be one of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: A pointer to a null-terminated ANSI string that contains the fully
	// qualified path to the service binary file. The path MAY include arguments. If the
	// path contains a space, it MUST be quoted so that it is correctly interpreted. For
	// example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup: A pointer to a null-terminated ANSI string that names the load-ordering
	// group of which this service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: A pointer to an array of null-separated names of services or load
	// ordering groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is ANSI. Dependency on a service means that this service can only run
	// if the service it depends on is running. Dependency on a group means that this service
	// can run if at least one member of the group is running after an attempt to start
	// all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the dwDependSize parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: A pointer to a null-terminated ANSI that specifies the name of
	// the account under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A pointer to a null-terminated ANSI string that contains the password
	// of the account whose name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
}

func (o *CreateServiceWOW64ARequest) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOW64AOperation {
	if o == nil {
		return &xxx_CreateServiceWOW64AOperation{}
	}
	return &xxx_CreateServiceWOW64AOperation{
		ServiceManager:   o.ServiceManager,
		ServiceName:      o.ServiceName,
		DisplayName:      o.DisplayName,
		DesiredAccess:    o.DesiredAccess,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
	}
}

func (o *CreateServiceWOW64ARequest) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOW64AOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DisplayName = op.DisplayName
	o.DesiredAccess = op.DesiredAccess
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
}
func (o *CreateServiceWOW64ARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateServiceWOW64ARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOW64AOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateServiceWOW64AResponse structure represents the RCreateServiceWOW64A operation response
type CreateServiceWOW64AResponse struct {
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly created service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The RCreateServiceWOW64A return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateServiceWOW64AResponse) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOW64AOperation {
	if o == nil {
		return &xxx_CreateServiceWOW64AOperation{}
	}
	return &xxx_CreateServiceWOW64AOperation{
		TagID:   o.TagID,
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *CreateServiceWOW64AResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOW64AOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Service = op.Service
	o.Return = op.Return
}
func (o *CreateServiceWOW64AResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateServiceWOW64AResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOW64AOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateServiceWOW64WOperation structure represents the RCreateServiceWOW64W operation
type xxx_CreateServiceWOW64WOperation struct {
	ServiceManager   *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName      string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	DesiredAccess    uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	Service          *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateServiceWOW64WOperation) OpNum() int { return 45 }

func (o *xxx_CreateServiceWOW64WOperation) OpName() string { return "/svcctl/v2/RCreateServiceWOW64W" }

func (o *xxx_CreateServiceWOW64WOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64WOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64WOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64WOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64WOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateServiceWOW64WOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateServiceWOW64WRequest structure represents the RCreateServiceWOW64W operation request
type CreateServiceWOW64WRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The SC_MANAGER_CREATE_SERVICE access right MUST have been granted to the caller when
	// the RPC context handle to the SCM was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated UNICODE string that specifies the name
	// of the service to install. This MUST NOT be NULL.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpDisplayName: A pointer to a null-terminated UNICODE string that contains the display
	// name by which user interface programs identify the service.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	// dwDesiredAccess: A value that specifies the access to the service. This MUST be one
	// of the values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	// dwServiceType: A value that specifies the type of service. This MUST be one or a
	// combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs within its own process.                                        |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A value that specifies when to start the service. This MUST be one of
	// the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: A value that specifies the severity of the error if the service fails
	// to start and determines the action that the SCM takes. This MUST be one of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: A pointer to a null-terminated UNICODE string that contains the
	// fully qualified path to the service binary file. The path MAY include arguments.
	// If the path contains a space, it MUST be quoted so that it is correctly interpreted.
	// For example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup: A pointer to a null-terminated UNICODE string that names the load-ordering
	// group of which this service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: A pointer to an array of null-separated names of services or load
	// ordering groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is Unicode. Dependency on a service means that this service can only
	// run if the service it depends on is running. Dependency on a group means that this
	// service can run if at least one member of the group is running after an attempt to
	// start all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the dwDependSize parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: A pointer to a null-terminated UNICODE string that specifies
	// the name of the account under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A pointer to a null-terminated UNICODE string that contains the password
	// of the account whose name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
}

func (o *CreateServiceWOW64WRequest) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOW64WOperation {
	if o == nil {
		return &xxx_CreateServiceWOW64WOperation{}
	}
	return &xxx_CreateServiceWOW64WOperation{
		ServiceManager:   o.ServiceManager,
		ServiceName:      o.ServiceName,
		DisplayName:      o.DisplayName,
		DesiredAccess:    o.DesiredAccess,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
	}
}

func (o *CreateServiceWOW64WRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOW64WOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DisplayName = op.DisplayName
	o.DesiredAccess = op.DesiredAccess
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
}
func (o *CreateServiceWOW64WRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateServiceWOW64WRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOW64WOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateServiceWOW64WResponse structure represents the RCreateServiceWOW64W operation response
type CreateServiceWOW64WResponse struct {
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly created service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The RCreateServiceWOW64W return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateServiceWOW64WResponse) xxx_ToOp(ctx context.Context) *xxx_CreateServiceWOW64WOperation {
	if o == nil {
		return &xxx_CreateServiceWOW64WOperation{}
	}
	return &xxx_CreateServiceWOW64WOperation{
		TagID:   o.TagID,
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *CreateServiceWOW64WResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateServiceWOW64WOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Service = op.Service
	o.Return = op.Return
}
func (o *CreateServiceWOW64WResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateServiceWOW64WResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateServiceWOW64WOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NotifyServiceStatusChangeOperation structure represents the RNotifyServiceStatusChange operation
type xxx_NotifyServiceStatusChangeOperation struct {
	Service           *Handle       `idl:"name:hService" json:"service"`
	NotifyParams      *NotifyParams `idl:"name:NotifyParams" json:"notify_params"`
	ClientProcessGUID *dtyp.GUID    `idl:"name:pClientProcessGuid" json:"client_process_guid"`
	SCMProcessGUID    *dtyp.GUID    `idl:"name:pSCMProcessGuid" json:"scm_process_guid"`
	CreateRemoteQueue bool          `idl:"name:pfCreateRemoteQueue" json:"create_remote_queue"`
	Notify            *Notify       `idl:"name:phNotify" json:"notify"`
	Return            uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_NotifyServiceStatusChangeOperation) OpNum() int { return 47 }

func (o *xxx_NotifyServiceStatusChangeOperation) OpName() string {
	return "/svcctl/v2/RNotifyServiceStatusChange"
}

func (o *xxx_NotifyServiceStatusChangeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyServiceStatusChangeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// NotifyParams {in} (1:{alias=SC_RPC_NOTIFY_PARAMS}(struct))
	{
		if o.NotifyParams != nil {
			if err := o.NotifyParams.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NotifyParams{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pClientProcessGuid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.ClientProcessGUID != nil {
			if err := o.ClientProcessGUID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_NotifyServiceStatusChangeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// NotifyParams {in} (1:{alias=SC_RPC_NOTIFY_PARAMS}(struct))
	{
		if o.NotifyParams == nil {
			o.NotifyParams = &NotifyParams{}
		}
		if err := o.NotifyParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pClientProcessGuid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.ClientProcessGUID == nil {
			o.ClientProcessGUID = &dtyp.GUID{}
		}
		if err := o.ClientProcessGUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyServiceStatusChangeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyServiceStatusChangeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pSCMProcessGuid {out} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.SCMProcessGUID != nil {
			if err := o.SCMProcessGUID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pfCreateRemoteQueue {out} (1:{alias=PBOOL}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.CreateRemoteQueue {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// phNotify {out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NotifyServiceStatusChangeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pSCMProcessGuid {out} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.SCMProcessGUID == nil {
			o.SCMProcessGUID = &dtyp.GUID{}
		}
		if err := o.SCMProcessGUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pfCreateRemoteQueue {out} (1:{alias=PBOOL,pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		var _bCreateRemoteQueue int32
		if err := w.ReadData(&_bCreateRemoteQueue); err != nil {
			return err
		}
		o.CreateRemoteQueue = _bCreateRemoteQueue != 0
	}
	// phNotify {out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NotifyServiceStatusChangeRequest structure represents the RNotifyServiceStatusChange operation request
type NotifyServiceStatusChangeRequest struct {
	// hService: An SC_RPC_HANDLE data type that defines the handle to the SCM for SERVICE_NOTIFY_CREATED
	// and SERVICE_NOTIFY_DELETED notifications or to the service record for all other notification
	// types that MUST have been created previously, using one of the open methods specified
	// in section 3.1.4. The SC_MANAGER_ENUMERATE_SERVICE access right MUST have been granted
	// to the caller when the RPC context handle to the SCM was created, or the SERVICE_QUERY_STATUS
	// access right MUST have been granted to the caller when the RPC context handle to
	// the service record was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// NotifyParams: An SC_RPC_NOTIFY_PARAMS (section 2.2.23) data type that defines the
	// service status notification information.
	NotifyParams *NotifyParams `idl:"name:NotifyParams" json:"notify_params"`
	// pClientProcessGuid: Not used. This MUST be ignored.
	ClientProcessGUID *dtyp.GUID `idl:"name:pClientProcessGuid" json:"client_process_guid"`
}

func (o *NotifyServiceStatusChangeRequest) xxx_ToOp(ctx context.Context) *xxx_NotifyServiceStatusChangeOperation {
	if o == nil {
		return &xxx_NotifyServiceStatusChangeOperation{}
	}
	return &xxx_NotifyServiceStatusChangeOperation{
		Service:           o.Service,
		NotifyParams:      o.NotifyParams,
		ClientProcessGUID: o.ClientProcessGUID,
	}
}

func (o *NotifyServiceStatusChangeRequest) xxx_FromOp(ctx context.Context, op *xxx_NotifyServiceStatusChangeOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.NotifyParams = op.NotifyParams
	o.ClientProcessGUID = op.ClientProcessGUID
}
func (o *NotifyServiceStatusChangeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *NotifyServiceStatusChangeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NotifyServiceStatusChangeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NotifyServiceStatusChangeResponse structure represents the RNotifyServiceStatusChange operation response
type NotifyServiceStatusChangeResponse struct {
	// pSCMProcessGuid: Not used. This MUST be ignored.
	SCMProcessGUID *dtyp.GUID `idl:"name:pSCMProcessGuid" json:"scm_process_guid"`
	// pfCreateRemoteQueue: Not used. This MUST be ignored.
	CreateRemoteQueue bool `idl:"name:pfCreateRemoteQueue" json:"create_remote_queue"`
	// phNotify: An LPSC_NOTIFY_RPC_HANDLE (section 2.2.6) data type that defines a handle
	// to the notification status associated with the client for the specified service.
	Notify *Notify `idl:"name:phNotify" json:"notify"`
	// Return: The RNotifyServiceStatusChange return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NotifyServiceStatusChangeResponse) xxx_ToOp(ctx context.Context) *xxx_NotifyServiceStatusChangeOperation {
	if o == nil {
		return &xxx_NotifyServiceStatusChangeOperation{}
	}
	return &xxx_NotifyServiceStatusChangeOperation{
		SCMProcessGUID:    o.SCMProcessGUID,
		CreateRemoteQueue: o.CreateRemoteQueue,
		Notify:            o.Notify,
		Return:            o.Return,
	}
}

func (o *NotifyServiceStatusChangeResponse) xxx_FromOp(ctx context.Context, op *xxx_NotifyServiceStatusChangeOperation) {
	if o == nil {
		return
	}
	o.SCMProcessGUID = op.SCMProcessGUID
	o.CreateRemoteQueue = op.CreateRemoteQueue
	o.Notify = op.Notify
	o.Return = op.Return
}
func (o *NotifyServiceStatusChangeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *NotifyServiceStatusChangeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NotifyServiceStatusChangeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNotifyResultsOperation structure represents the RGetNotifyResults operation
type xxx_GetNotifyResultsOperation struct {
	Notify       *Notify           `idl:"name:hNotify" json:"notify"`
	NotifyParams *NotifyParamsList `idl:"name:ppNotifyParams" json:"notify_params"`
	Return       uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNotifyResultsOperation) OpNum() int { return 48 }

func (o *xxx_GetNotifyResultsOperation) OpName() string { return "/svcctl/v2/RGetNotifyResults" }

func (o *xxx_GetNotifyResultsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyResultsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hNotify {in} (1:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetNotifyResultsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hNotify {in} (1:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyResultsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyResultsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppNotifyParams {out} (1:{pointer=ref}*(2))(2:{alias=PSC_RPC_NOTIFY_PARAMS_LIST}*(1))(3:{alias=SC_RPC_NOTIFY_PARAMS_LIST}(struct))
	{
		if o.NotifyParams != nil {
			_ptr_ppNotifyParams := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.NotifyParams != nil {
					if err := o.NotifyParams.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&NotifyParamsList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.NotifyParams, _ptr_ppNotifyParams); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNotifyResultsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppNotifyParams {out} (1:{pointer=ref}*(2))(2:{alias=PSC_RPC_NOTIFY_PARAMS_LIST,pointer=ref}*(1))(3:{alias=SC_RPC_NOTIFY_PARAMS_LIST}(struct))
	{
		_ptr_ppNotifyParams := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.NotifyParams == nil {
				o.NotifyParams = &NotifyParamsList{}
			}
			if err := o.NotifyParams.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppNotifyParams := func(ptr interface{}) { o.NotifyParams = *ptr.(**NotifyParamsList) }
		if err := w.ReadPointer(&o.NotifyParams, _s_ppNotifyParams, _ptr_ppNotifyParams); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNotifyResultsRequest structure represents the RGetNotifyResults operation request
type GetNotifyResultsRequest struct {
	// hNotify: An SC_NOTIFY_RPC_HANDLE (section 2.2.6) data type that defines a handle
	// to the notification status associated with the client. This is the handle returned
	// by an RNotifyServiceStatusChange call.
	Notify *Notify `idl:"name:hNotify" json:"notify"`
}

func (o *GetNotifyResultsRequest) xxx_ToOp(ctx context.Context) *xxx_GetNotifyResultsOperation {
	if o == nil {
		return &xxx_GetNotifyResultsOperation{}
	}
	return &xxx_GetNotifyResultsOperation{
		Notify: o.Notify,
	}
}

func (o *GetNotifyResultsRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyResultsOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *GetNotifyResultsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *GetNotifyResultsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyResultsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNotifyResultsResponse structure represents the RGetNotifyResults operation response
type GetNotifyResultsResponse struct {
	// ppNotifyParams: A pointer to a buffer that receives an SC_RPC_NOTIFY_PARAMS_LIST
	// (section 2.2.24) data type.
	NotifyParams *NotifyParamsList `idl:"name:ppNotifyParams" json:"notify_params"`
	// Return: The RGetNotifyResults return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNotifyResultsResponse) xxx_ToOp(ctx context.Context) *xxx_GetNotifyResultsOperation {
	if o == nil {
		return &xxx_GetNotifyResultsOperation{}
	}
	return &xxx_GetNotifyResultsOperation{
		NotifyParams: o.NotifyParams,
		Return:       o.Return,
	}
}

func (o *GetNotifyResultsResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNotifyResultsOperation) {
	if o == nil {
		return
	}
	o.NotifyParams = op.NotifyParams
	o.Return = op.Return
}
func (o *GetNotifyResultsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *GetNotifyResultsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNotifyResultsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CloseNotifyOperation structure represents the RCloseNotifyHandle operation
type xxx_CloseNotifyOperation struct {
	Notify   *Notify `idl:"name:phNotify" json:"notify"`
	ApcFired bool    `idl:"name:pfApcFired" json:"apc_fired"`
	Return   uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CloseNotifyOperation) OpNum() int { return 49 }

func (o *xxx_CloseNotifyOperation) OpName() string { return "/svcctl/v2/RCloseNotifyHandle" }

func (o *xxx_CloseNotifyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// phNotify {in, out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// phNotify {in, out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phNotify {in, out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify != nil {
			if err := o.Notify.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Notify{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pfApcFired {out} (1:{alias=PBOOL}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.ApcFired {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CloseNotifyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phNotify {in, out} (1:{alias=LPSC_NOTIFY_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_NOTIFY_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Notify == nil {
			o.Notify = &Notify{}
		}
		if err := o.Notify.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pfApcFired {out} (1:{alias=PBOOL,pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		var _bApcFired int32
		if err := w.ReadData(&_bApcFired); err != nil {
			return err
		}
		o.ApcFired = _bApcFired != 0
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CloseNotifyRequest structure represents the RCloseNotifyHandle operation request
type CloseNotifyRequest struct {
	// phNotify: An SC_NOTIFY_RPC_HANDLE (section 2.2.6) data type that defines a handle
	// to the notification status associated with the client. This is the handle returned
	// by an RNotifyServiceStatusChange call.
	Notify *Notify `idl:"name:phNotify" json:"notify"`
}

func (o *CloseNotifyRequest) xxx_ToOp(ctx context.Context) *xxx_CloseNotifyOperation {
	if o == nil {
		return &xxx_CloseNotifyOperation{}
	}
	return &xxx_CloseNotifyOperation{
		Notify: o.Notify,
	}
}

func (o *CloseNotifyRequest) xxx_FromOp(ctx context.Context, op *xxx_CloseNotifyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
}
func (o *CloseNotifyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CloseNotifyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNotifyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CloseNotifyResponse structure represents the RCloseNotifyHandle operation response
type CloseNotifyResponse struct {
	// phNotify: An SC_NOTIFY_RPC_HANDLE (section 2.2.6) data type that defines a handle
	// to the notification status associated with the client. This is the handle returned
	// by an RNotifyServiceStatusChange call.
	Notify *Notify `idl:"name:phNotify" json:"notify"`
	// pfApcFired: Not used.
	ApcFired bool `idl:"name:pfApcFired" json:"apc_fired"`
	// Return: The RCloseNotifyHandle return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CloseNotifyResponse) xxx_ToOp(ctx context.Context) *xxx_CloseNotifyOperation {
	if o == nil {
		return &xxx_CloseNotifyOperation{}
	}
	return &xxx_CloseNotifyOperation{
		Notify:   o.Notify,
		ApcFired: o.ApcFired,
		Return:   o.Return,
	}
}

func (o *CloseNotifyResponse) xxx_FromOp(ctx context.Context, op *xxx_CloseNotifyOperation) {
	if o == nil {
		return
	}
	o.Notify = op.Notify
	o.ApcFired = op.ApcFired
	o.Return = op.Return
}
func (o *CloseNotifyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CloseNotifyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CloseNotifyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ControlServiceExAOperation structure represents the RControlServiceExA operation
type xxx_ControlServiceExAOperation struct {
	Service          *Handle                   `idl:"name:hService" json:"service"`
	Control          uint32                    `idl:"name:dwControl" json:"control"`
	InfoLevel        uint32                    `idl:"name:dwInfoLevel" json:"info_level"`
	ControlInParams  *ServiceControlInParamsA  `idl:"name:pControlInParams;switch_is:dwInfoLevel" json:"control_in_params"`
	ControlOutParams *ServiceControlOutParamsA `idl:"name:pControlOutParams;switch_is:dwInfoLevel" json:"control_out_params"`
	Return           uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_ControlServiceExAOperation) OpNum() int { return 50 }

func (o *xxx_ControlServiceExAOperation) OpName() string { return "/svcctl/v2/RControlServiceExA" }

func (o *xxx_ControlServiceExAOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExAOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Control); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InfoLevel); err != nil {
			return err
		}
	}
	// pControlInParams {in} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_IN_PARAMSA}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_IN_PARAMSA}(union))
	{
		_swControlInParams := uint32(o.InfoLevel)
		if o.ControlInParams != nil {
			if err := o.ControlInParams.MarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlInParamsA{}).MarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExAOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Control); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InfoLevel); err != nil {
			return err
		}
	}
	// pControlInParams {in} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_IN_PARAMSA,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_IN_PARAMSA}(union))
	{
		if o.ControlInParams == nil {
			o.ControlInParams = &ServiceControlInParamsA{}
		}
		_swControlInParams := uint32(o.InfoLevel)
		if err := o.ControlInParams.UnmarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExAOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExAOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pControlOutParams {out} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_OUT_PARAMSA}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_OUT_PARAMSA}(union))
	{
		_swControlOutParams := uint32(o.InfoLevel)
		if o.ControlOutParams != nil {
			if err := o.ControlOutParams.MarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlOutParamsA{}).MarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExAOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pControlOutParams {out} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_OUT_PARAMSA,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_OUT_PARAMSA}(union))
	{
		if o.ControlOutParams == nil {
			o.ControlOutParams = &ServiceControlOutParamsA{}
		}
		_swControlOutParams := uint32(o.InfoLevel)
		if err := o.ControlOutParams.UnmarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ControlServiceExARequest structure represents the RControlServiceExA operation request
type ControlServiceExARequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwControl: Requested control code. This MUST be one of the following values.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                           |                                                                                  |
	//	|                   VALUE                   |                                     MEANING                                      |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_STOP 0x00000001           | Notifies a service to stop. The SERVICE_STOP access right MUST have been         |
	//	|                                           | granted to the caller when the RPC control handle to the service record was      |
	//	|                                           | created. The service record MUST have the SERVICE_ACCEPT_STOP bit set in the     |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PAUSE 0x00000002          | Notifies a service to pause. The SERVICE_PAUSE_CONTINUE access right MUST have   |
	//	|                                           | been granted to the caller when the RPC control handle to the service record was |
	//	|                                           | created. The service record MUST have the SERVICE_ACCEPT_PAUSE_CONTINUE bit set  |
	//	|                                           | in the ServiceStatus.dwControlsAccepted field of the service record.             |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_CONTINUE 0x00000003       | Notifies a paused service to resume. The SERVICE_PAUSE_CONTINUE access           |
	//	|                                           | right MUST have been granted to the caller when the RPC control handle           |
	//	|                                           | to the service record was created. The service record MUST have the              |
	//	|                                           | SERVICE_ACCEPT_PAUSE_CONTINUE bit set in the ServiceStatus.dwControlsAccepted    |
	//	|                                           | field of the service record.                                                     |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_INTERROGATE 0x00000004    | Notifies a service to report its current status information to the SCM. The      |
	//	|                                           | SERVICE_INTERROGATE access right MUST have been granted to the caller when the   |
	//	|                                           | RPC control handle to the service record was created.                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PARAMCHANGE 0x00000006    | Notifies a service that its startup parameters have changed. The                 |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_PARAMCHANGE bit set in the           |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDADD 0x00000007     | Notifies a service that there is a new component for binding. The                |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDREMOVE 0x00000008  | Notifies a network service that a component for binding has been removed.        |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDENABLE 0x00000009  | Notifies a network service that a disabled binding has been enabled.             |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDDISABLE 0x0000000A | Notifies a network service that one of its bindings has been disabled.           |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	Control uint32 `idl:"name:dwControl" json:"control"`
	// dwInfoLevel: The information level for the service control parameters. This MUST
	// be set to 0x00000001.
	InfoLevel uint32 `idl:"name:dwInfoLevel" json:"info_level"`
	// pControlInParams: A pointer to a SERVICE_CONTROL_STATUS_REASON_IN_PARAMSA (section
	// 2.2.30) structure that contains the reason associated with the SERVICE_CONTROL_STOP
	// control.
	ControlInParams *ServiceControlInParamsA `idl:"name:pControlInParams;switch_is:dwInfoLevel" json:"control_in_params"`
}

func (o *ControlServiceExARequest) xxx_ToOp(ctx context.Context) *xxx_ControlServiceExAOperation {
	if o == nil {
		return &xxx_ControlServiceExAOperation{}
	}
	return &xxx_ControlServiceExAOperation{
		Service:         o.Service,
		Control:         o.Control,
		InfoLevel:       o.InfoLevel,
		ControlInParams: o.ControlInParams,
	}
}

func (o *ControlServiceExARequest) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceExAOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Control = op.Control
	o.InfoLevel = op.InfoLevel
	o.ControlInParams = op.ControlInParams
}
func (o *ControlServiceExARequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ControlServiceExARequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceExAOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ControlServiceExAResponse structure represents the RControlServiceExA operation response
type ControlServiceExAResponse struct {
	// pControlOutParams: A pointer to a buffer that contains a SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS
	// (section 2.2.32) structure to receive the current status on the service.
	ControlOutParams *ServiceControlOutParamsA `idl:"name:pControlOutParams;switch_is:dwInfoLevel" json:"control_out_params"`
	// Return: The RControlServiceExA return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ControlServiceExAResponse) xxx_ToOp(ctx context.Context) *xxx_ControlServiceExAOperation {
	if o == nil {
		return &xxx_ControlServiceExAOperation{}
	}
	return &xxx_ControlServiceExAOperation{
		ControlOutParams: o.ControlOutParams,
		Return:           o.Return,
	}
}

func (o *ControlServiceExAResponse) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceExAOperation) {
	if o == nil {
		return
	}
	o.ControlOutParams = op.ControlOutParams
	o.Return = op.Return
}
func (o *ControlServiceExAResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ControlServiceExAResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceExAOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ControlServiceExWOperation structure represents the RControlServiceExW operation
type xxx_ControlServiceExWOperation struct {
	Service          *Handle                   `idl:"name:hService" json:"service"`
	Control          uint32                    `idl:"name:dwControl" json:"control"`
	InfoLevel        uint32                    `idl:"name:dwInfoLevel" json:"info_level"`
	ControlInParams  *ServiceControlInParamsW  `idl:"name:pControlInParams;switch_is:dwInfoLevel" json:"control_in_params"`
	ControlOutParams *ServiceControlOutParamsW `idl:"name:pControlOutParams;switch_is:dwInfoLevel" json:"control_out_params"`
	Return           uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_ControlServiceExWOperation) OpNum() int { return 51 }

func (o *xxx_ControlServiceExWOperation) OpName() string { return "/svcctl/v2/RControlServiceExW" }

func (o *xxx_ControlServiceExWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Control); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InfoLevel); err != nil {
			return err
		}
	}
	// pControlInParams {in} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_IN_PARAMSW}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_IN_PARAMSW}(union))
	{
		_swControlInParams := uint32(o.InfoLevel)
		if o.ControlInParams != nil {
			if err := o.ControlInParams.MarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlInParamsW{}).MarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Control); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InfoLevel); err != nil {
			return err
		}
	}
	// pControlInParams {in} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_IN_PARAMSW,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_IN_PARAMSW}(union))
	{
		if o.ControlInParams == nil {
			o.ControlInParams = &ServiceControlInParamsW{}
		}
		_swControlInParams := uint32(o.InfoLevel)
		if err := o.ControlInParams.UnmarshalUnionNDR(ctx, w, _swControlInParams); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pControlOutParams {out} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_OUT_PARAMSW}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_OUT_PARAMSW}(union))
	{
		_swControlOutParams := uint32(o.InfoLevel)
		if o.ControlOutParams != nil {
			if err := o.ControlOutParams.MarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
				return err
			}
		} else {
			if err := (&ServiceControlOutParamsW{}).MarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlServiceExWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pControlOutParams {out} (1:{switch_type={alias=DWORD}(uint32), alias=PSC_RPC_SERVICE_CONTROL_OUT_PARAMSW,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=SC_RPC_SERVICE_CONTROL_OUT_PARAMSW}(union))
	{
		if o.ControlOutParams == nil {
			o.ControlOutParams = &ServiceControlOutParamsW{}
		}
		_swControlOutParams := uint32(o.InfoLevel)
		if err := o.ControlOutParams.UnmarshalUnionNDR(ctx, w, _swControlOutParams); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ControlServiceExWRequest structure represents the RControlServiceExW operation request
type ControlServiceExWRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwControl: Requested control code. MUST be one of the following values.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                           |                                                                                  |
	//	|                   VALUE                   |                                     MEANING                                      |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_STOP 0x00000001           | Notifies a service to stop. The SERVICE_STOP access right MUST have been         |
	//	|                                           | granted to the caller when the RPC control handle to the service record was      |
	//	|                                           | created. The service record MUST have the SERVICE_ACCEPT_STOP bit set in the     |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PAUSE 0x00000002          | Notifies a service to pause. The SERVICE_PAUSE_CONTINUE access right MUST have   |
	//	|                                           | been granted to the caller when the RPC control handle to the service record was |
	//	|                                           | created. The service record MUST have the SERVICE_ACCEPT_PAUSE_CONTINUE bit set  |
	//	|                                           | in the ServiceStatus.dwControlsAccepted field of the service record.             |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_CONTINUE 0x00000003       | Notifies a paused service to resume. The SERVICE_PAUSE_CONTINUE access           |
	//	|                                           | right MUST have been granted to the caller when the RPC control handle           |
	//	|                                           | to the service record was created. The service record MUST have the              |
	//	|                                           | SERVICE_ACCEPT_PAUSE_CONTINUE bit set in the ServiceStatus.dwControlsAccepted    |
	//	|                                           | field of the service record.                                                     |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_INTERROGATE 0x00000004    | Notifies a service to report its current status information to the SCM. The      |
	//	|                                           | SERVICE_INTERROGATE access right MUST have been granted to the caller when the   |
	//	|                                           | RPC control handle to the service record was created.                            |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_PARAMCHANGE 0x00000006    | Notifies a service that its startup parameters have changed. The                 |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_PARAMCHANGE bit set in the           |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDADD 0x00000007     | Notifies a service that there is a new component for binding. The                |
	//	|                                           | SERVICE_PAUSE_CONTINUE access right MUST have been granted to the caller         |
	//	|                                           | when the RPC control handle to the service record was created. The               |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDREMOVE 0x00000008  | Notifies a network service that a component for binding has been removed.        |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDENABLE 0x00000009  | Notifies a network service that a disabled binding has been enabled.             |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_CONTROL_NETBINDDISABLE 0x0000000A | Notifies a network service that one of its bindings has been disabled.           |
	//	|                                           | The SERVICE_PAUSE_CONTINUE access right MUST have been granted to the            |
	//	|                                           | caller when the RPC control handle to the service record was created. The        |
	//	|                                           | service record MUST have the SERVICE_ACCEPT_NETBINDCHANGE bit set in the         |
	//	|                                           | ServiceStatus.dwControlsAccepted field of the service record.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	Control uint32 `idl:"name:dwControl" json:"control"`
	// dwInfoLevel: The information level for the service control parameters. This MUST
	// be set to 0x00000001.
	InfoLevel uint32 `idl:"name:dwInfoLevel" json:"info_level"`
	// pControlInParams: A pointer to a SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW (section
	// 2.2.31) structure that contains the reason associated with the SERVICE_CONTROL_STOP
	// control.
	ControlInParams *ServiceControlInParamsW `idl:"name:pControlInParams;switch_is:dwInfoLevel" json:"control_in_params"`
}

func (o *ControlServiceExWRequest) xxx_ToOp(ctx context.Context) *xxx_ControlServiceExWOperation {
	if o == nil {
		return &xxx_ControlServiceExWOperation{}
	}
	return &xxx_ControlServiceExWOperation{
		Service:         o.Service,
		Control:         o.Control,
		InfoLevel:       o.InfoLevel,
		ControlInParams: o.ControlInParams,
	}
}

func (o *ControlServiceExWRequest) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceExWOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.Control = op.Control
	o.InfoLevel = op.InfoLevel
	o.ControlInParams = op.ControlInParams
}
func (o *ControlServiceExWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *ControlServiceExWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceExWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ControlServiceExWResponse structure represents the RControlServiceExW operation response
type ControlServiceExWResponse struct {
	// pControlOutParams: A pointer to a buffer that contains a SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS
	// (section 2.2.32) structure to receive the current status on the service.
	ControlOutParams *ServiceControlOutParamsW `idl:"name:pControlOutParams;switch_is:dwInfoLevel" json:"control_out_params"`
	// Return: The RControlServiceExW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ControlServiceExWResponse) xxx_ToOp(ctx context.Context) *xxx_ControlServiceExWOperation {
	if o == nil {
		return &xxx_ControlServiceExWOperation{}
	}
	return &xxx_ControlServiceExWOperation{
		ControlOutParams: o.ControlOutParams,
		Return:           o.Return,
	}
}

func (o *ControlServiceExWResponse) xxx_FromOp(ctx context.Context, op *xxx_ControlServiceExWOperation) {
	if o == nil {
		return
	}
	o.ControlOutParams = op.ControlOutParams
	o.Return = op.Return
}
func (o *ControlServiceExWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *ControlServiceExWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlServiceExWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryServiceConfigExOperation structure represents the RQueryServiceConfigEx operation
type xxx_QueryServiceConfigExOperation struct {
	Service   *Handle      `idl:"name:hService" json:"service"`
	InfoLevel uint32       `idl:"name:dwInfoLevel" json:"info_level"`
	Info      *ConfigInfoW `idl:"name:pInfo" json:"info"`
	Return    uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryServiceConfigExOperation) OpNum() int { return 56 }

func (o *xxx_QueryServiceConfigExOperation) OpName() string {
	return "/svcctl/v2/RQueryServiceConfigEx"
}

func (o *xxx_QueryServiceConfigExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InfoLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hService {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInfoLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InfoLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pInfo {out} (1:{pointer=ref}*(1))(2:{alias=SC_RPC_CONFIG_INFOW}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConfigInfoW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryServiceConfigExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pInfo {out} (1:{pointer=ref}*(1))(2:{alias=SC_RPC_CONFIG_INFOW}(struct))
	{
		if o.Info == nil {
			o.Info = &ConfigInfoW{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryServiceConfigExRequest structure represents the RQueryServiceConfigEx operation request
type QueryServiceConfigExRequest struct {
	// hService: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to the
	// service record that MUST have been created previously, using one of the open methods
	// specified in section 3.1.4. The SERVICE_QUERY_CONFIG access right MUST have been
	// granted to the caller when the RPC context handle was created.
	Service *Handle `idl:"name:hService" json:"service"`
	// dwInfoLevel: The information level for the service configuration parameters. This
	// MUST be set to 0x00000008 which corresponds to the service's trigger information.
	InfoLevel uint32 `idl:"name:dwInfoLevel" json:"info_level"`
}

func (o *QueryServiceConfigExRequest) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigExOperation {
	if o == nil {
		return &xxx_QueryServiceConfigExOperation{}
	}
	return &xxx_QueryServiceConfigExOperation{
		Service:   o.Service,
		InfoLevel: o.InfoLevel,
	}
}

func (o *QueryServiceConfigExRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigExOperation) {
	if o == nil {
		return
	}
	o.Service = op.Service
	o.InfoLevel = op.InfoLevel
}
func (o *QueryServiceConfigExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *QueryServiceConfigExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryServiceConfigExResponse structure represents the RQueryServiceConfigEx operation response
type QueryServiceConfigExResponse struct {
	// pInfo: A pointer to an SC_RPC_CONFIG_INFOW (section 2.2.22) structure that contains
	// optional configuration information.
	Info *ConfigInfoW `idl:"name:pInfo" json:"info"`
	// Return: The RQueryServiceConfigEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryServiceConfigExResponse) xxx_ToOp(ctx context.Context) *xxx_QueryServiceConfigExOperation {
	if o == nil {
		return &xxx_QueryServiceConfigExOperation{}
	}
	return &xxx_QueryServiceConfigExOperation{
		Info:   o.Info,
		Return: o.Return,
	}
}

func (o *QueryServiceConfigExResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryServiceConfigExOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.Return = op.Return
}
func (o *QueryServiceConfigExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *QueryServiceConfigExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryServiceConfigExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateWOWServiceOperation structure represents the RCreateWowService operation
type xxx_CreateWOWServiceOperation struct {
	ServiceManager   *Handle `idl:"name:hSCManager" json:"service_manager"`
	ServiceName      string  `idl:"name:lpServiceName;string" json:"service_name"`
	DisplayName      string  `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	DesiredAccess    uint32  `idl:"name:dwDesiredAccess" json:"desired_access"`
	ServiceType      uint32  `idl:"name:dwServiceType" json:"service_type"`
	StartType        uint32  `idl:"name:dwStartType" json:"start_type"`
	ErrorControl     uint32  `idl:"name:dwErrorControl" json:"error_control"`
	BinaryPathName   string  `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	LoadOrderGroup   string  `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	TagID            uint32  `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	Dependencies     []byte  `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	DependSize       uint32  `idl:"name:dwDependSize" json:"depend_size"`
	ServiceStartName string  `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	Password         []byte  `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	PasswordSize     uint32  `idl:"name:dwPwSize" json:"password_size"`
	ServiceWOWType   uint16  `idl:"name:dwServiceWowType" json:"service_wow_type"`
	Service          *Handle `idl:"name:lpServiceHandle" json:"service"`
	Return           uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateWOWServiceOperation) OpNum() int { return 60 }

func (o *xxx_CreateWOWServiceOperation) OpName() string { return "/svcctl/v2/RCreateWowService" }

func (o *xxx_CreateWOWServiceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Dependencies != nil && o.DependSize == 0 {
		o.DependSize = uint32(len(o.Dependencies))
	}
	if o.Password != nil && o.PasswordSize == 0 {
		o.PasswordSize = uint32(len(o.Password))
	}
	if len(o.ServiceName) > int(257) {
		return fmt.Errorf("ServiceName is out of range")
	}
	if len(o.DisplayName) > int(257) {
		return fmt.Errorf("DisplayName is out of range")
	}
	if len(o.BinaryPathName) > int(32768) {
		return fmt.Errorf("BinaryPathName is out of range")
	}
	if len(o.LoadOrderGroup) > int(257) {
		return fmt.Errorf("LoadOrderGroup is out of range")
	}
	if o.DependSize > uint32(4096) {
		return fmt.Errorf("DependSize is out of range")
	}
	if len(o.ServiceStartName) > int(2048) {
		return fmt.Errorf("ServiceStartName is out of range")
	}
	if o.PasswordSize > uint32(514) {
		return fmt.Errorf("PasswordSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateWOWServiceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager != nil {
			if err := o.ServiceManager.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DisplayName != "" {
			_ptr_lpDisplayName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DisplayName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DisplayName, _ptr_lpDisplayName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.LoadOrderGroup != "" {
			_ptr_lpLoadOrderGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LoadOrderGroup); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		if o.Dependencies != nil || o.DependSize > 0 {
			_ptr_lpDependencies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DependSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Dependencies {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Dependencies[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Dependencies); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Dependencies, _ptr_lpDependencies); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		if o.ServiceStartName != "" {
			_ptr_lpServiceStartName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServiceStartName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServiceStartName, _ptr_lpServiceStartName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		if o.Password != nil || o.PasswordSize > 0 {
			_ptr_lpPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.PasswordSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Password {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Password[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Password); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_lpPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PasswordSize); err != nil {
			return err
		}
	}
	// dwServiceWowType {in} (1:{alias=USHORT}(uint16))
	{
		if err := w.WriteData(o.ServiceWOWType); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateWOWServiceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hSCManager {in} (1:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ServiceManager == nil {
			o.ServiceManager = &Handle{}
		}
		if err := o.ServiceManager.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpServiceName {in} (1:{string, pointer=ref, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceName); err != nil {
			return err
		}
	}
	// lpDisplayName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpDisplayName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DisplayName); err != nil {
				return err
			}
			return nil
		})
		_s_lpDisplayName := func(ptr interface{}) { o.DisplayName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DisplayName, _s_lpDisplayName, _ptr_lpDisplayName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	// dwServiceType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// dwStartType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartType); err != nil {
			return err
		}
	}
	// dwErrorControl {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ErrorControl); err != nil {
			return err
		}
	}
	// lpBinaryPathName {in} (1:{string, pointer=ref, range=(0,32768)}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.BinaryPathName); err != nil {
			return err
		}
	}
	// lpLoadOrderGroup {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpLoadOrderGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LoadOrderGroup); err != nil {
				return err
			}
			return nil
		})
		_s_lpLoadOrderGroup := func(ptr interface{}) { o.LoadOrderGroup = *ptr.(*string) }
		if err := w.ReadPointer(&o.LoadOrderGroup, _s_lpLoadOrderGroup, _ptr_lpLoadOrderGroup); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpDependencies {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDependSize](uchar))
	{
		_ptr_lpDependencies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Dependencies", sizeInfo[0])
			}
			o.Dependencies = make([]byte, sizeInfo[0])
			for i1 := range o.Dependencies {
				i1 := i1
				if err := w.ReadData(&o.Dependencies[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpDependencies := func(ptr interface{}) { o.Dependencies = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Dependencies, _s_lpDependencies, _ptr_lpDependencies); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwDependSize {in} (1:{range=(0,4096), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DependSize); err != nil {
			return err
		}
	}
	// lpServiceStartName {in} (1:{string, pointer=unique, range=(0,2048)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpServiceStartName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServiceStartName); err != nil {
				return err
			}
			return nil
		})
		_s_lpServiceStartName := func(ptr interface{}) { o.ServiceStartName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServiceStartName, _s_lpServiceStartName, _ptr_lpServiceStartName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpPassword {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwPwSize](uchar))
	{
		_ptr_lpPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Password", sizeInfo[0])
			}
			o.Password = make([]byte, sizeInfo[0])
			for i1 := range o.Password {
				i1 := i1
				if err := w.ReadData(&o.Password[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpPassword := func(ptr interface{}) { o.Password = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Password, _s_lpPassword, _ptr_lpPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwPwSize {in} (1:{range=(0,514), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PasswordSize); err != nil {
			return err
		}
	}
	// dwServiceWowType {in} (1:{alias=USHORT}(uint16))
	{
		if err := w.ReadData(&o.ServiceWOWType); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateWOWServiceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateWOWServiceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.TagID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TagID, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service != nil {
			if err := o.Service.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateWOWServiceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwTagId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwTagId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.TagID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwTagId := func(ptr interface{}) { o.TagID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.TagID, _s_lpdwTagId, _ptr_lpdwTagId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpServiceHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Service == nil {
			o.Service = &Handle{}
		}
		if err := o.Service.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateWOWServiceRequest structure represents the RCreateWowService operation request
type CreateWOWServiceRequest struct {
	// hSCManager: An SC_RPC_HANDLE (section 2.2.4) data type that defines the handle to
	// the SCM database created using one of the open methods specified in section 3.1.4.
	// The SC_MANAGER_CREATE_SERVICE access right MUST have been granted to the caller when
	// the RPC context handle to the SCM was created.
	ServiceManager *Handle `idl:"name:hSCManager" json:"service_manager"`
	// lpServiceName: A pointer to a null-terminated Unicode string that specifies the name
	// of the service to install. This MUST NOT be NULL.
	ServiceName string `idl:"name:lpServiceName;string" json:"service_name"`
	// lpDisplayName: A pointer to a null-terminated Unicode string that contains the display
	// name by which user interface programs identify the service.
	DisplayName string `idl:"name:lpDisplayName;string;pointer:unique" json:"display_name"`
	// dwDesiredAccess: A value that specifies the access to the service. This MUST be one
	// of the values as specified in section 3.1.4.
	DesiredAccess uint32 `idl:"name:dwDesiredAccess" json:"desired_access"`
	// dwServiceType: A value that specifies the type of service. This MUST be one or a
	// combination of the following values.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_KERNEL_DRIVER 0x00000001       | A driver service. These are services that manage devices on the system.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_FILE_SYSTEM_DRIVER 0x00000002  | A file system driver service. These are services that manage file systems on the |
	//	|                                        | system.                                                                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_OWN_PROCESS 0x00000010   | Service that runs within its own process.                                        |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_WIN32_SHARE_PROCESS 0x00000020 | Service that shares a process with other services.                               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_INTERACTIVE_PROCESS 0x00000100 | The service can interact with the desktop.                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	ServiceType uint32 `idl:"name:dwServiceType" json:"service_type"`
	// dwStartType: A value that specifies when to start the service. This MUST be one of
	// the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_BOOT_START 0x00000000   | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services.                                                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_SYSTEM_START 0x00000001 | Starts the driver service when the system boots up. This value is valid only for |
	//	|                                 | driver services. The services marked SERVICE_SYSTEM_START are started after all  |
	//	|                                 | SERVICE_BOOT_START services have been started.                                   |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_AUTO_START 0x00000002   | Starts the service automatically during system startup.                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DEMAND_START 0x00000003 | Starts the service when a client requests the SCM to start the service.          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_DISABLED 0x00000004     | Service cannot be started.                                                       |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	StartType uint32 `idl:"name:dwStartType" json:"start_type"`
	// dwErrorControl: A value that specifies the severity of the error if the service fails
	// to start and determines the action that the SCM takes. This MUST be one of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_IGNORE 0x00000000   | The SCM ignores the error and continues the startup operation.                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_NORMAL 0x00000001   | The SCM logs the error, but continues the startup operation.                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_SEVERE 0x00000002   | The SCM logs the error. If the last-known good configuration is being started,   |
	//	|                                   | the startup operation continues. Otherwise, the system is restarted with the     |
	//	|                                   | last-known good configuration.                                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SERVICE_ERROR_CRITICAL 0x00000003 | The SCM SHOULD log the error if possible. If the last-known good configuration   |
	//	|                                   | is being started, the startup operation fails. Otherwise, the system is          |
	//	|                                   | restarted with the last-known good configuration.                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	ErrorControl uint32 `idl:"name:dwErrorControl" json:"error_control"`
	// lpBinaryPathName: A pointer to a null-terminated UNICODE string that contains the
	// fully qualified path to the service binary file. The path MAY include arguments.
	// If the path contains a space, it MUST be quoted so that it is correctly interpreted.
	// For example, "d:\\my share\\myservice.exe" is specified as "\"d:\\my share\\myservice.exe\"".
	BinaryPathName string `idl:"name:lpBinaryPathName;string" json:"binary_path_name"`
	// lpLoadOrderGroup: A pointer to a null-terminated UNICODE string that names the load-ordering
	// group of which this service is a member.
	LoadOrderGroup string `idl:"name:lpLoadOrderGroup;string;pointer:unique" json:"load_order_group"`
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpDependencies: A pointer to an array of null-separated names of services or load
	// ordering groups that MUST start before this service. The array is doubly null-terminated.
	// Load ordering group names are prefixed with a "+" character (to distinguish them
	// from service names). If the pointer is NULL or if it points to an empty string, the
	// service has no dependencies. Cyclic dependency between services is not allowed. The
	// character set is Unicode. Dependency on a service means that this service can run
	// only if the service it depends on is running. Dependency on a group means that this
	// service can run if at least one member of the group is running after an attempt to
	// start all members of the group.
	Dependencies []byte `idl:"name:lpDependencies;size_is:(dwDependSize);pointer:unique" json:"dependencies"`
	// dwDependSize: The size, in bytes, of the string specified by the dwDependSize parameter.
	DependSize uint32 `idl:"name:dwDependSize" json:"depend_size"`
	// lpServiceStartName: A pointer to a null-terminated UNICODE string that specifies
	// the name of the account under which the service runs.
	ServiceStartName string `idl:"name:lpServiceStartName;string;pointer:unique" json:"service_start_name"`
	// lpPassword: A pointer to a null-terminated UNICODE string that contains the password
	// of the account whose name was specified by the lpServiceStartName parameter.
	Password []byte `idl:"name:lpPassword;size_is:(dwPwSize);pointer:unique" json:"password"`
	// dwPwSize: The size, in bytes, of the password specified by the lpPassword parameter.
	PasswordSize uint32 `idl:"name:dwPwSize" json:"password_size"`
	// dwServiceWowType: The image file machine constant corresponding to the architecture
	// that the service binary is compiled for. This MUST be one of the following values.
	//
	//	+---------------------------------------+-----------------------------------------------------------+
	//	|                                       |                                                           |
	//	|                 VALUE                 |                          MEANING                          |
	//	|                                       |                                                           |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_UNKNOWN 0          | Unknown or unspecified                                    |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_TARGET_HOST 0x0001 | Interacts with the host and not a WOW64 guest<84>         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_I386 0x014c        | Intel 386 (also known as x86)                             |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_R3000 0x0160       | MIPS 32-bit big-endian (R3000)                            |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_R3000 0x0162       | MIPS 32-bit little-endian (R3000)                         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_R4000 0x0166       | MIPS 64-bit little-endian (R4000)                         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_R10000 0x0168      | MIPS 64-bit little-endian (R10000 MIPS IV)                |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169   | MIPS little-endian Windows Compact Edition (WCE) v2       |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_ALPHA 0x0184       | DEC Alpha AXP 32-bit                                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_SH3 0x01a2         | Hitachi SH-3 32-bit little-endian                         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_SH3DSP 0x01a3      | Hitachi SH-3 DSP 32-bit                                   |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_SH3E 0x01a4        | Hitachi SH-3E 32-bit little-endian                        |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_SH4 0x01a6         | Hitachi SH-4 32-bit little-endian                         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_SH5 0x01a8         | Hitachi SH-5 64-bit                                       |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_ARM 0x01c0         | ARM Little-Endian                                         |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_THUMB 0x01c2       | ARM Thumb/Thumb-2 Little-Endian                           |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_ARMNT 0x01c4       | ARM Thumb-2 Little-Endian<85>                             |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_AM33 0x01d3        | Matsushita AM33, now Panasonic MN103                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_POWERPC 0x01F0     | IBM PowerPC 32-bit Little-Endian                          |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_POWERPCFP 0x01f1   | PowerPC 32-bit with FPU                                   |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_IA64 0x0200        | Intel IA-64 (also known as Itanium Architecture)          |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_MIPS16 0x0266      | MIPS 16-bit                                               |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_ALPHA64 0x0284     | DEC Alpha AXP 64-bit (same as IMAGE_FILE_MACHINE_AXP64)   |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_MIPSFPU 0x0366     | MIPS 32-bit with FPU                                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_MIPSFPU16 0x0466   | MIPS 16-bit with FPU                                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_AXP64 0x0284       | DEC Alpha AXP 64-bit (same as IMAGE_FILE_MACHINE_ALPHA64) |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_TRICORE 0x0520     | Infineon AUDO 32-bit                                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_CEF 0x0CEF         | CEF                                                       |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_EBC 0x0EBC         | EFI/UEFI Byte Code                                        |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_AMD64 0x8664       | AMD64 (also known as x64)                                 |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_M32R 0x9041        | Mitsubishi M32R 32-bit little-endian                      |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_ARM64 0xAA64       | ARM64 little-endian<86>                                   |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| IMAGE_FILE_MACHINE_CEE 0xC0EE         | CEE                                                       |
	//	+---------------------------------------+-----------------------------------------------------------+
	ServiceWOWType uint16 `idl:"name:dwServiceWowType" json:"service_wow_type"`
}

func (o *CreateWOWServiceRequest) xxx_ToOp(ctx context.Context) *xxx_CreateWOWServiceOperation {
	if o == nil {
		return &xxx_CreateWOWServiceOperation{}
	}
	return &xxx_CreateWOWServiceOperation{
		ServiceManager:   o.ServiceManager,
		ServiceName:      o.ServiceName,
		DisplayName:      o.DisplayName,
		DesiredAccess:    o.DesiredAccess,
		ServiceType:      o.ServiceType,
		StartType:        o.StartType,
		ErrorControl:     o.ErrorControl,
		BinaryPathName:   o.BinaryPathName,
		LoadOrderGroup:   o.LoadOrderGroup,
		TagID:            o.TagID,
		Dependencies:     o.Dependencies,
		DependSize:       o.DependSize,
		ServiceStartName: o.ServiceStartName,
		Password:         o.Password,
		PasswordSize:     o.PasswordSize,
		ServiceWOWType:   o.ServiceWOWType,
	}
}

func (o *CreateWOWServiceRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateWOWServiceOperation) {
	if o == nil {
		return
	}
	o.ServiceManager = op.ServiceManager
	o.ServiceName = op.ServiceName
	o.DisplayName = op.DisplayName
	o.DesiredAccess = op.DesiredAccess
	o.ServiceType = op.ServiceType
	o.StartType = op.StartType
	o.ErrorControl = op.ErrorControl
	o.BinaryPathName = op.BinaryPathName
	o.LoadOrderGroup = op.LoadOrderGroup
	o.TagID = op.TagID
	o.Dependencies = op.Dependencies
	o.DependSize = op.DependSize
	o.ServiceStartName = op.ServiceStartName
	o.Password = op.Password
	o.PasswordSize = op.PasswordSize
	o.ServiceWOWType = op.ServiceWOWType
}
func (o *CreateWOWServiceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *CreateWOWServiceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateWOWServiceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateWOWServiceResponse structure represents the RCreateWowService operation response
type CreateWOWServiceResponse struct {
	// lpdwTagId: A pointer to a variable that receives a tag value. The value is unique
	// to the group specified in the lpLoadOrderGroup parameter.
	TagID uint32 `idl:"name:lpdwTagId;pointer:unique" json:"tag_id"`
	// lpServiceHandle: An LPSC_RPC_HANDLE (section 2.2.4) data type that defines the handle
	// to the newly created service record.
	Service *Handle `idl:"name:lpServiceHandle" json:"service"`
	// Return: The RCreateWowService return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateWOWServiceResponse) xxx_ToOp(ctx context.Context) *xxx_CreateWOWServiceOperation {
	if o == nil {
		return &xxx_CreateWOWServiceOperation{}
	}
	return &xxx_CreateWOWServiceOperation{
		TagID:   o.TagID,
		Service: o.Service,
		Return:  o.Return,
	}
}

func (o *CreateWOWServiceResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateWOWServiceOperation) {
	if o == nil {
		return
	}
	o.TagID = op.TagID
	o.Service = op.Service
	o.Return = op.Return
}
func (o *CreateWOWServiceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *CreateWOWServiceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateWOWServiceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenSCM2Operation structure represents the ROpenSCManager2 operation
type xxx_OpenSCM2Operation struct {
	DatabaseName  string  `idl:"name:DatabaseName;string;pointer:unique" json:"database_name"`
	DesiredAccess uint32  `idl:"name:DesiredAccess" json:"desired_access"`
	SCM           *Handle `idl:"name:ScmHandle" json:"scm"`
	Return        uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenSCM2Operation) OpNum() int { return 61 }

func (o *xxx_OpenSCM2Operation) OpName() string { return "/svcctl/v2/ROpenSCManager2" }

func (o *xxx_OpenSCM2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if len(o.DatabaseName) > int(257) {
		return fmt.Errorf("DatabaseName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCM2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// DatabaseName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		if o.DatabaseName != "" {
			_ptr_DatabaseName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DatabaseName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DatabaseName, _ptr_DatabaseName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCM2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// DatabaseName {in} (1:{string, pointer=unique, range=(0,257)}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DatabaseName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DatabaseName); err != nil {
				return err
			}
			return nil
		})
		_s_DatabaseName := func(ptr interface{}) { o.DatabaseName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DatabaseName, _s_DatabaseName, _ptr_DatabaseName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DesiredAccess {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DesiredAccess); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCM2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCM2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ScmHandle {out} (1:{alias=LPSC_RPC_HANDLE}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM != nil {
			if err := o.SCM.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenSCM2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ScmHandle {out} (1:{alias=LPSC_RPC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SC_RPC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.SCM == nil {
			o.SCM = &Handle{}
		}
		if err := o.SCM.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenSCM2Request structure represents the ROpenSCManager2 operation request
type OpenSCM2Request struct {
	DatabaseName  string `idl:"name:DatabaseName;string;pointer:unique" json:"database_name"`
	DesiredAccess uint32 `idl:"name:DesiredAccess" json:"desired_access"`
}

func (o *OpenSCM2Request) xxx_ToOp(ctx context.Context) *xxx_OpenSCM2Operation {
	if o == nil {
		return &xxx_OpenSCM2Operation{}
	}
	return &xxx_OpenSCM2Operation{
		DatabaseName:  o.DatabaseName,
		DesiredAccess: o.DesiredAccess,
	}
}

func (o *OpenSCM2Request) xxx_FromOp(ctx context.Context, op *xxx_OpenSCM2Operation) {
	if o == nil {
		return
	}
	o.DatabaseName = op.DatabaseName
	o.DesiredAccess = op.DesiredAccess
}
func (o *OpenSCM2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRRequest(ctx, w)
}
func (o *OpenSCM2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCM2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenSCM2Response structure represents the ROpenSCManager2 operation response
type OpenSCM2Response struct {
	SCM *Handle `idl:"name:ScmHandle" json:"scm"`
	// Return: The ROpenSCManager2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenSCM2Response) xxx_ToOp(ctx context.Context) *xxx_OpenSCM2Operation {
	if o == nil {
		return &xxx_OpenSCM2Operation{}
	}
	return &xxx_OpenSCM2Operation{
		SCM:    o.SCM,
		Return: o.Return,
	}
}

func (o *OpenSCM2Response) xxx_FromOp(ctx context.Context, op *xxx_OpenSCM2Operation) {
	if o == nil {
		return
	}
	o.SCM = op.SCM
	o.Return = op.Return
}
func (o *OpenSCM2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx).MarshalNDRResponse(ctx, w)
}
func (o *OpenSCM2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenSCM2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
